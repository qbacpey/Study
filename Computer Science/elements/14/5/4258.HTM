<P width=0><SPAN class=sidebar_name><B><I><SPAN class=headers>Title:</SPAN></B><SPAN class=RefText> 4.5 Thread Life Cycle : Where is my TCB?</SPAN></FONT></I></B></SPAN></P>
<P>A remarkably tricky implementation question is how to find the current thread&#8217;s TCB. The thread library needs access to the current TCB for a number of reasons, e.g., to change its priority or to access thread-local variables. </P>
<P><SPAN class=extract>One might think finding the TCB would be simple: just store a pointer to the TCB in a global variable. However, recall that every thread running in the same process uses exactly the same code, and therefore each thread would look in exactly the same place for the TCB. On a uniprocessor, this works: the global variable can hold the value of the current TCB, and the library can change the value whenever it switches between threads</SPAN>. </P>
<P><SPAN class=extract>This does not work on a multiprocessor, however. Some systems, such as the Intel x86, have hardware support for fetching the ID of the current processor. In these systems, the thread library can maintain a global array of pointers, with the i&#8217;th entry pointing to the TCB of the thread running on the i&#8217;th processor. A running thread can then find its TCB by looking up its processor ID and then finding the corresponding entry in the array</SPAN>. </P>
<P><SPAN class=extract>For systems without this feature, however, there is another approach: the stack pointer is always unique to each thread. The thread library can store a pointer to the thread TCB at the very bottom of the stack, underneath the procedure frames. (Some systems take this one step farther, and put the entire TCB at the bottom of the stack.) As long as thread stacks are aligned to start at a fixed block boundary, the low order bits of the current stack pointer can be masked to locate the pointer to the current TCB</SPAN>.