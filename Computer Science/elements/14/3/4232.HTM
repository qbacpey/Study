<STRONG><FONT color=blue>Operating Systems: Principles and Practice (Second Edition) Volume II : 4. Concurrency and Threads : 4.4 Thread Data Structures and Life Cycle : </FONT></STRONG>
<H4 class=subsectionHead><SPAN class=headers>Title:</SPAN></B><SPAN class=RefText>&nbsp; 4.4.1 Per-Thread State and Thread Control Block (TCB)</SPAN></FONT></H4>
<P><SPAN class=extract>The operating system needs a data structure to represent a thread&#8217;s state; a thread is like any other object in this regard. This data structure is called the <EM><A data-9uzdtcnnj6xqoalwmdp3qa='{"name": "OEBPS/Text/part0000.xhtml", "frag": "glo:thread control block"}'>thread control block</A></EM> (TCB). For every thread the operating system creates, it creates one TCB.</SPAN> </P>
<P>The thread control block holds two types of per-thread information: </P>
<OL class=enumerate1>
<LI class=enumerate><A id=x1-20002x1 name=x1-20002x1></A>
<P>The state of the computation being performed by the thread. </P>
<LI class=enumerate><A id=x1-20004x2 name=x1-20004x2></A>
<P>Metadata about the thread that is used to manage the thread.</P></LI></OL>
<P><B>Per-thread Computation State.</B> To create multiple threads and to be able to start and stop each thread as needed, the operating system must allocate space in the TCB for the current state of each thread&#8217;s computation: a pointer to the thread&#8217;s stack and a copy of its processor registers. </P>
<UL class=itemize1>
<LI class=itemize>
<P><B>Stack.</B> A thread&#8217;s stack is the same as the stack for a single-threaded computation &#8212; it stores information needed by the nested procedures the thread is currently running. For example, if a thread calls foo(), foo() calls bar(), and bar() calls bas(), then the stack would contain a <EM><A data-9uzdtcnnj6xqoalwmdp3qa='{"name": "OEBPS/Text/part0000.xhtml", "frag": "glo:stack frame"}'>stack frame</A></EM> for each of these three procedures; each stack frame contains the local variables used by the procedure, the parameters the procedure was called with, and the return address to jump to when the procedure completes. </P>
<P>Because at any given time different threads can be in different states in their sequential computations &#8212; each can be in a different place in a different procedure called with different arguments from a different nesting of enclosing procedures &#8212; each thread needs its own stack. <SPAN class=extract>When a new thread is created, the operating system allocates it a new stack and stores a pointer to that stack in the thread&#8217;s TCB</SPAN>. </P>
<LI class=itemize>
<P><B>Copy of processor registers.</B> A processor&#8217;s registers include not only its general-purpose registers for storing intermediate values for ongoing computations, but they also include special-purpose registers, such as the instruction pointer and stack pointer. </P>
<P>To be able to suspend a thread, run another thread, and later resume the original thread, the operating system needs a place to store a thread&#8217;s registers when that thread is not actively running. <SPAN class=extract>In some systems, the general-purpose registers for a stopped thread are stored on the top of the stack, and the TCB contains only a pointer to the stack. In other systems, the TCB contains space for a copy of all processor registers.</SPAN></P></LI></UL>
<P></P>
<DIV class=sidebar align=center>
<HR>

<TABLE cellPadding=10>
<TBODY>
<TR>
<TD style="BACKGROUND-COLOR: #f0f0f0" align=left>
<P width=0><SPAN class=sidebar_name><B><I>How big a stack?</I></B></SPAN> </P>
<P>An implementation question for thread systems is: how large a stack should be allocated for each thread? A stack grows and shrinks as procedure calls are made and those calls return. The size of the stack must be large enough to accommodate the deepest nesting level needed during in the thread&#8217;s lifetime. With hundreds or thousands of threads, it can be wasteful to allocate more than the minimum needed. </P>
<P><SPAN class=extract>Most modern operating systems allocate kernel stacks in physical memory, putting space at a premium.</SPAN> However, the maximum procedure nesting depth in the kernel is usually small. <SPAN class=extract>Thus, kernels typically allocate a very small fixed sized region for each thread stack, e.g., 8 KB by default in Linux on an Intel x86. The kernel stays within this bound due to an important kernel coding convention: buffers and data structures are always allocated on the heap and never as procedure local variables</SPAN>. Although most programming languages allow arbitrary data structures to be defined as procedure local or &#8220;automatic&#8221; &#8212; allocated when a procedure starts and de-allocated when the procedure exits &#8212; that can cause problems when the stack is of limited size. </P>
<P><SPAN class=extract>User-level stacks are allocated in virtual memory and so there is less need for a tight space constraint.</SPAN> <SPAN class=extract>In a single threaded process, the stack is located at the top end of the address space, where it can grow nearly without bound.</SPAN> <SPAN class=extract>To catch program errors, most operating systems will trigger an error if the user program stack grows too large too quickly, as that is usually an indication of unbounded recursion, rather than something that was the programmer&#8217;s intent. </SPAN></P>
<P><SPAN class=extract></SPAN><SPAN class=extract>In a multi-threaded user application, it is not possible to have each stack grow without constraint. Although some programming languages, such as Google&#8217;s Go, will automatically grow the stack as needed, this is still uncommon.</SPAN> POSIX allows the default stack size to be library dependent (e.g., larger on a desktop machine, smaller on a smartphone). As one POSIX thread tutorial put it dryly, &#8220;Exceeding the default stack limit is often very easy to do, with the usual results: program termination and/or corrupted data.&#8221;&nbsp;[<A data-9uzdtcnnj6xqoalwmdp3qa='{"name": "OEBPS/Text/part0000.xhtml", "frag": "Xbarney"}'>10</A>]. <SPAN class=extract>Most implementations try to detect when programs exceed the default stack limit by placing a known value at the very top and bottom of the stack to serve as a guard. The guard values can be checked on every context switch; if the value changes, it is likely the thread exceeded its stack</SPAN>. </P>
<P>To support application portability, the POSIX thread standard allows the user to redefine the default stack size to whatever is needed for the correct execution of a particular program. The thread library provided with the textbook sets the default stack size to 1 MB. This is almost certainly large enough provided you adopt the kernel approach of never putting large data objects on the stack. </P>
<P></P></TD></TR></TBODY></TABLE>
<HR>
</DIV>
<P><B>Per-thread Metadata.</B> The TCB also includes <EM>per-thread metadata</EM> &#8212; information for managing the thread. <SPAN class=extract>For example, each thread might have a thread ID, scheduling priority, and status (e.g., whether the thread is waiting for an event or is ready to be placed onto a processor). </SPAN><A id=x1-20005r38 name=x1-20005r38></A>