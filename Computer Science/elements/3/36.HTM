<STRONG>: </STRONG>How does the communication between a client and server work? </P>
<H3 class=sectionHead><SPAN class=headers>Title:</SPAN></B><SPAN class=RefText> 3.4 Case Study: Interprocess Communication</SPAN></H3>
<H3 class=sectionHead><SPAN class=RefText></SPAN></A><FONT size=3>For many of the same reasons it makes sense to construct complex applications from simpler modules, it often makes sense to create applications that can specialize on a specific task, and then combine those applications into more complex structures. We gave an example above with the C compiler, but many parts of the operating system are structured this way. For example, instead of every program needing to know how to coordinate access to a printer, UNIX has a printer server, a specialized program for managing the printer queue.</FONT> </H3>
<P>For this to work, we need a way for processes to communicate with each other. Three widely used forms of interprocess communication are: </P>
<UL class=itemize1>
<LI class=itemize>
<P><B>Producer-consumer.</B> In this model, programs are structured to accept as input the output of other programs. Communication is one-way: the producer only writes, and the consumer only reads. As we explained above, this allows chaining: a consumer can be, in turn, a producer for a different process. Much of the success of UNIX was due to its ability to easily compose many different programs together in this fashion. </P>
<LI class=itemize>
<P><B>Client-server.</B> An alternative model is to allow two-way communication between processes, as in client-server computing. The server implements some specialized task, such as managing the printer queue or managing the display. Clients send requests to the server to do some task, and when the operation is complete, the server replies back to the client. </P>
<LI class=itemize>
<P><B>File system.</B> Another way programs can be connected together is through reading and writing files. A text editor can import an image created by a drawing program, and the editor can in turn write an HTML file that a web server can read to know how to display a web page. A key distinction is that, unlike the first two modes, communication through the file system can be separated in <EM>time</EM>: the writer of the file does not need to be running at the same time as the file reader. Therefore, data needs to be stored persistently on disk or other stable storage, and the data needs to be named so that you can find the file when needed later on. </P></LI></UL>
<P>All three models are widely used both on a single system and over a network. For example, the Google MapReduce utility operates over a network in a producer-consumer fashion: the output of the map function is sent to the machines running the reduce function. The web is an example of client-server computing, and many enterprises and universities run centralized file servers to connect a text editor on one computer with a compiler running on another. </P>
<P>As persistent storage, file naming, and distributed computing are each complex topics in their own right, we defer the discussions of those topics to later chapters. Here we focus on interprocess communication, where both processes are running simultaneously on the same machine. <A id=x1-62001r98 name=x1-62001r98></A></P>
<H4 class=subsectionHead>3.4.1 <A id=x1-630001 name=x1-630001></A>Producer-Consumer Communication</H4><A id=x1-630019 name=x1-630019></A>
<HR>

<CENTER><img alt="" src="" data-calibre-src="OEBPS/Images/image00210.gif"> </CENTER>
<P>
<TABLE cellPadding=10>
<TBODY>
<TR>
<TD align=left>
<P class=caption width=0><B>Figure&nbsp;3.9: </B>Interprocess communication between a producer application and a consumer. The producer uses the write system call to put data into the buffer; the consumer uses the read system call to take data out of the buffer.</P></TD></TR></TBODY></TABLE></P>
<HR>

<P>Figure&nbsp;<A data-ixbpernmnjoud4qz9ktzkg='{"name": "OEBPS/Text/part0000.xhtml", "frag": "x1-630019"}'>3.9</A> illustrates how two processes communicate through the operating system in a producer-consumer relationship. Via the shell, we establish a pipe between the producer and the consumer. As one process computes and produces a stream of output data, it issues a sequence of write system calls on the pipe into the kernel. Each write can be of variable size. Assuming there is room in the kernel buffer, the kernel copies the data into the buffer, and returns immediately back to the producer. </P>
<P>At some point later, the operating system will schedule the consumer process to run. (On a multicore system, the producer and consumer could be running at the same time.) The consumer issues a sequence of read calls. Because the pipe is just a stream of bytes, the consumer can read the data out in any convenient chunking &#8212; the consumer can read in 1 KB chunks, while the producer wrote its data in 4 KB chunks, or vice versa. Each system call read made by the consumer returns the next successive chunk of data out of the kernel buffer. The consumer process can then compute on its input, sending its output to the display, a file, or onto the next consumer. </P>
<P>The kernel buffer allows each process to run at its own pace. There is no requirement that each process have equivalent amounts of work to do. If the producer is faster than the consumer, the kernel buffer fills up, and when the producer tries to write to a full buffer, the kernel stalls the process until there is room to store the data. Equivalently, if the consumer is faster than the producer, the buffer will empty and the next read request will stall until the producer creates more data. </P>
<P>In UNIX, when the producer finishes, it closes its side of the pipe, but there may still be data queued in the kernel for the consumer. Eventually, the consumer reads the last of the data, and the read system call will return an &#8220;end of file&#8221; marker. Thus, to the consumer, there is no difference between reading from a pipe and reading from a file. </P>
<P>Using kernel buffers to decouple the execution of the producer and consumer reduces the number and cost of context switches. Modern computers make extensive use of hardware caches to improve performance, but caches are ineffective if a program only runs for a short period of time before it must yield the processor to another task. The kernel buffer allows the operating system to run each process long enough to benefit from reuse, rather than alternating between the producer and consumer on each system call. <A id=x1-63002r109 name=x1-63002r109></A></P>
<H4 class=subsectionHead>3.4.2 <A id=x1-640002 name=x1-640002></A>Client-Server Communication</H4><A id=x1-6400110 name=x1-6400110></A>
<HR>

<CENTER><img alt="" src="" data-calibre-src="OEBPS/Images/image00211.gif"> </CENTER>
<P>
<TABLE cellPadding=10>
<TBODY>
<TR>
<TD align=left>
<P class=caption width=0><B>Figure&nbsp;3.10: </B>Interprocess communication between a client process and a server process. Once the client and server are connected, the client sends a request to the server by writing it into a kernel buffer. The server reads the request out of the buffer, and returns the result by writing it into a separate buffer read by the client.</P></TD></TR></TBODY></TABLE></P>
<HR>

<P>We can generalize the above to illustrate client-server communication, shown in Figure&nbsp;<A data-ixbpernmnjoud4qz9ktzkg='{"name": "OEBPS/Text/part0000.xhtml", "frag": "x1-6400110"}'>3.10</A>. Instead of a single pipe, we create two, one for each direction. To make a request, the client writes the data into one pipe, and reads the response from the other. The server does the opposite: it reads requests from the first pipe, performs whatever is requested (provided the client has permission to make the request), and writes the response onto the second pipe. </P>
<P>The client and server code are shown in Figure&nbsp;<A data-ixbpernmnjoud4qz9ktzkg='{"name": "OEBPS/Text/part0000.xhtml", "frag": "x1-6400211"}'>3.11</A>. To simplify the code, we assume that the requests and responses are fixed-size. <A id=x1-6400211 name=x1-6400211></A></P>
<HR>
<PRE class=code>&nbsp;Client:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;request[RequestSize];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;reply[ReplySize]
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;..compute..
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Put&nbsp;the&nbsp;request&nbsp;into&nbsp;the&nbsp;buffer.
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Send&nbsp;the&nbsp;buffer&nbsp;to&nbsp;the&nbsp;server.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;write(output,&nbsp;request,&nbsp;RequestSize);
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Wait&nbsp;for&nbsp;response.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;read(input,&nbsp;reply,&nbsp;ReplySize);
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;..compute..
&nbsp;
&nbsp;Server:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;request[RequestSize];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;reply[ReplySize];
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Loop&nbsp;waiting&nbsp;for&nbsp;requests.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(1)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Read&nbsp;incoming&nbsp;command.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;read(input,&nbsp;request,&nbsp;RequestSize);
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Do&nbsp;operation.
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Send&nbsp;result.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;write(output,&nbsp;reply,&nbsp;ReplySize);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</PRE>
<DIV class=caption align=center>
<TABLE cellPadding=10>
<TBODY>
<TR>
<TD align=left>
<P class=caption width=0><B>Figure&nbsp;3.11: </B>Example code for client-server interaction.</P></TD></TR></TBODY></TABLE></DIV>
<HR>

<P></P>
<DIV class=sidebar align=center>
<HR>

<TABLE cellPadding=10>
<TBODY>
<TR>
<TD align=left>
<P width=0><SPAN class=sidebar_name><B><I>Streamlining client-server communication</I></B></SPAN> </P>
<P>Client-server communication is a common pattern in many systems, and so one can ask: how can we improve its performance? One step is to recognize that both the client and the server issue a write immediately followed by a read, to wait for the other side to reply; at the cost of adding a system call, these can be combined to eliminate two kernel crossings per round trip. Further, the client will always need to wait for the server, so it makes sense for it to donate its processor to run the server code, reducing delay. Microsoft added support for this optimization to Windows in the early 1990&#8217;s when it converted to a microkernel design (explained a bit later in this chapter). However, as we noted earlier, modern computer architectures make extensive use of caches, so for this to work we need code and data for both the client and the server to be able to be in cache simultaneously. We will talk about mechanisms to accomplish that in a later chapter. </P>
<P>We can take this streamlining even further. On a multicore system, it is possible or even likely that both the client and server each have their own processor. If the kernel sets up a shared memory region accessible to both the client and the server and no other processes, then the client and server can (safely) pass requests and replies back and forth, as fast as the memory system will allow, without ever traversing into the kernel or relinquishing their processors. </P>
<P></P></TD></TR></TBODY></TABLE>
<HR>
</DIV>
<P>Frequently, we want to allow many clients to talk to the same server. For example, there is one server to manage the print queue, although there can be many processes that want to be able to print. For this, the server uses the select system call to identify the pipe containing the request, as shown in Figure&nbsp;<A data-ixbpernmnjoud4qz9ktzkg='{"name": "OEBPS/Text/part0000.xhtml", "frag": "x1-6400312"}'>3.12</A>. The client code is unchanged. <A id=x1-6400312 name=x1-6400312></A></P>
<HR>
<PRE class=code>&nbsp;Server:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;request[RequestSize];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;reply[ReplySize];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FileDescriptor&nbsp;clientInput[NumClients];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FileDescriptor&nbsp;clientOutput[NumClients];
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Loop&nbsp;waiting&nbsp;for&nbsp;a&nbsp;request&nbsp;from&nbsp;any&nbsp;client.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(fd&nbsp;=&nbsp;select(clientInput,&nbsp;NumClients)&nbsp;{
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Read&nbsp;incoming&nbsp;command&nbsp;from&nbsp;a&nbsp;specific&nbsp;client.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;read(clientInput[fd],&nbsp;request,&nbsp;RequestSize);
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Do&nbsp;operation.
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Send&nbsp;result.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;write(clientOutput[fd],&nbsp;reply,&nbsp;ReplySize);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</PRE>
<DIV class=caption align=center>
<TABLE cellPadding=10>
<TBODY>
<TR>
<TD align=left>
<P class=caption width=0><B>Figure&nbsp;3.12: </B>Server code for communicating with multiple clients.</P></TD></TR></TBODY></TABLE></DIV>
<HR>
<A id=x1-64004r108 name=x1-64004r108></A><A id=x1-650005 name=x1-650005></A>