<SPAN class=headers>Title:</SPAN></B><SPAN class=RefText> 2.4.2 Interrupt Stack</SPAN></FONT> 
<P></P>
<P>You might think you could use the process&#8217;s user-level stack to store its state. However, a separate, kernel-level interrupt stack is needed for two reasons.</P>
<P></P>
<P><SPAN class=extract>&#19981;&#30452;&#25509;&#20351;&#29992;&#36827;&#31243;&#26632;&#65292;&#32780;&#26159;&#19987;&#38376;&#20351;&#29992;&#20013;&#26029;&#26632;&#26469;&#20445;&#23384;&#20013;&#26029;&#20449;&#24687;&#65292;&#20027;&#35201;&#26159;&#32771;&#34385;&#21040;&#20197;&#19979;&#20004;&#20010;&#22240;&#32032;&#65306;&#21487;&#20381;&#36182;&#24615;&#12289;&#23433;&#20840;&#24615;</SPAN>&nbsp;</P>
<P></P>
<UL class=itemize1>
<LI class=itemize>
<P><B>Reliability.</B> The process&#8217;s user-level stack pointer might not be a valid memory address (e.g., if the program has a bug), but the kernel handler must continue to work properly.<BR><BR><SPAN class=extract>&#24341;&#20837;&#20013;&#26029;&#26632;&#25152;&#30830;&#20445;&#30340;&#21487;&#20381;&#36182;&#24615;&#25351;&#30340;&#26159;&#65306;&#22312;&#29992;&#25143;&#36827;&#31243;&#26632;&#25351;&#38024;&#25152;&#25351;&#22320;&#22336;&#21487;&#33021;&#19981;&#21512;&#27861;&#30340;&#24773;&#20917;&#19979;&#65292;&#20013;&#26029;&#22788;&#29702;&#31243;&#24207;&#20381;&#28982;&#38656;&#35201;&#30830;&#20445;&#27491;&#30830;&#36816;&#34892;</SPAN></P>
<LI class=itemize>
<P><B>Security.</B> On a multiprocessor, other threads running in the same process can modify user memory during the system call. If the kernel handler stores its local variables on the user-level stack, the user program might be able to modify the kernel&#8217;s return address, potentially causing the kernel to jump to arbitrary code. <BR><BR><SPAN class=extract>&#24341;&#20837;&#20013;&#26029;&#26632;&#25152;&#30830;&#20445;&#30340;&#23433;&#20840;&#24615;&#25351;&#30340;&#26159;&#65306;&#20027;&#35201;&#26159;&#32771;&#34385;&#21040;&#22810;&#32447;&#31243;&#24212;&#29992;&#31243;&#24207;&#20849;&#20139;&#20869;&#23384;&#31354;&#38388;&#65292;&#37027;&#20040;&#22312;&#26576;&#19968;&#20010;&#32447;&#31243;&#25191;&#34892;&#31995;&#32479;&#35843;&#29992;&#26399;&#38388;&#65288;&#20063;&#23601;&#26159;&#27491;&#22312;&#25191;&#34892;&#20869;&#26680;&#20013;&#26029;&#22788;&#29702;&#31243;&#24207;&#65289;&#22914;&#26524;&#20869;&#26680;&#22788;&#29702;&#22120;&#23558;&#23427;&#30340;&#26412;&#22320;&#21464;&#37327;&#20445;&#23384;&#21040;&#29992;&#25143;&#26632;&#20013;&#30340;&#35805;&#65292;&#20854;&#20182;&#32447;&#31243;&#23601;&#20250;&#36890;&#36807;&#20462;&#25913;&#19978;&#36848;&#26412;&#22320;&#21464;&#37327;&#65292;&#20351;&#20869;&#26680;&#22788;&#29702;&#22120;&#21457;&#29983;&#24847;&#26009;&#20043;&#22806;&#30340;&#38169;&#35823;</SPAN></P></LI></UL><SPAN class=extract>
<P>On a multiprocessor, each processor needs to have its own interrupt stack so that, for example, the kernel can handle simultaneous system calls and exceptions across multiple processors. For each processor, the kernel allocates a separate region of memory as that processor&#8217;s interrupt stack. 
<P><SPAN class=extract>&#22788;&#29702;&#22120;&#30340;&#20013;&#26029;&#26632;&#30001;&#20869;&#26680;&#20998;&#37197; </SPAN>
<P>&#20869;&#26680;&#20026;&#27599;&#20010;&#22788;&#29702;&#22120;&#20998;&#37197;&#20102;&#19968;&#22359;&#29305;&#21035;&#30340;&#20869;&#23384;&#21306;&#22495;&#20316;&#20026;&#22788;&#29702;&#22120;&#30340;&#20013;&#26029;&#26632;<BR></P>
<P></SPAN>