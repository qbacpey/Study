<STRONG><FONT color=blue>Operating Systems: Principles and Practice (Second Edition) Volume II : </FONT></STRONG>
<H3 class=sectionHead><SPAN class=headers>Title:</SPAN></B><SPAN class=RefText> 4.7 Combining Kernel Threads and Single-Threaded User Processes</SPAN></FONT></H3></A><FONT style="BACKGROUND-COLOR: #ffffff">Previously, Figure&nbsp;</FONT><A data-9uzdtcnnj6xqoalwmdp3qa='{"name": "OEBPS/Text/part0000.xhtml", "frag": "x1-2300111"}'>4.11</A><FONT style="BACKGROUND-COLOR: #ffffff"> illustrated a system with both kernel threads and single-threaded user processes. A process is a sequential execution of instructions, so each user-level process includes the process&#8217;s thread. However, a process is more than just a thread because it has its own address space. Process 1 has its own view of memory, its own code, its own heap, and its own global variables that differ from those of process 2 (and from the kernel&#8217;s). </FONT>
<P><SPAN class=extract>Because a process contains more than just a thread, each process&#8217;s process control block (PCB) needs more information than a thread control block (TCB) for a kernel thread.</SPAN> Like a TCB, a PCB for a single-threaded process must store the processor registers when the process&#8217;s thread is not running.<SPAN class=extract>In addition, the PCB has information about the process&#8217;s address space; when a context switch occurs from one process to another, the operating system must change the virtual memory mappings as well as the register state.</SPAN> </P>
<P><SPAN class=extract>Since the PCB and TCB each represent one thread, the kernel&#8217;s ready list can contain a mix of PCBs for processes and TCBs for kernel threads. </SPAN>When the scheduler chooses the next thread to run, it can pick either kind. <SPAN class=extract>A thread switch is nearly identical whether switching between kernel threads or switching between a process&#8217;s thread and a kernel thread. In both cases, the switch saves the state of the currently running thread and restores the state of the next thread to run. </SPAN></P>
<P><SPAN class=extract></SPAN><SPAN class=extract>As we mentioned in Chapter&nbsp;2, most operating systems dedicate a kernel interrupt stack for each process. This way, when the process needs to perform a system call, or on an interrupt or processor exception, the hardware traps to the kernel, saves the user-level processor state, and starts running at a specific handler in the kernel. Once inside the kernel, the process thread behaves exactly like a kernel thread &#8212; it can create threads (or other processes), block (e.g., in UNIX process wait or on I/O), and even exit. While inside the kernel, the process can be pre-empted by a timer interrupt or I/O event, and a higher priority process or kernel thread can run in its place. The PCB and kernel stack for the preempted process stores both its current kernel state, as well as the user-level state saved when the process initiated the system call.</SPAN> </P>
<P>We can resume a process in the kernel using thread_switch. However, when we resume execution of the user-level process after the completion of a system call or interrupt, we must restore its state precisely as it was beforehand: with the correct value in its registers, executing in user mode, with the appropriate virtual memory mappings, and so forth. </P>
<P><SPAN class=extract>An important detail is that many processor architectures have extra co-processor state, e.g., floating point registers, for user-level code. Typically, the operating system kernel does not make use of floating point operations. Therefore, the kernel does not need to save those registers when switching between kernel threads, but it does save and restore them when switching between processes.</SPAN> </P>
<P></P>
<DIV class=sidebar align=center>
<HR>

<TABLE cellPadding=10>
<TBODY>
<TR>
<TD style="BACKGROUND-COLOR: #f0f0f0" align=left>
<P width=0><SPAN class=sidebar_name><B><I>One small difference</I></B></SPAN> </P>
<P>You may notice that a mode switch in Chapter&nbsp;2 caused the x86 hardware to save not just the instruction pointer and eflags register but also the <EM>stack pointer</EM> of the interrupted process before starting the handler. For mode switching, the hardware changes the stack pointer to the kernel&#8217;s interrupt stack, so it must save the original user-level stack pointer. </P>
<P><SPAN class=extract>In contrast, when switching from a kernel thread to a kernel handler, the hardware does not switch stacks. Instead, the handler runs on the current stack, not on a separate interrupt stack. Therefore, the hardware does not need to save the original stack pointer; the handler just saves the stack pointer with the other registers as part of the pushad instruction.</SPAN> </P>
<P>Thus, x86 hardware works slightly differently when switching between a kernel thread and a kernel handler than when doing a mode switch: </P>
<UL class=itemize1>
<LI class=itemize>
<P><B><SPAN class=extract><B>Entering the handler.</B> When an interrupt or exception occurs, if the processor detects that it is already in kernel mode (by inspecting the eflags register), it just pushes the instruction pointer and eflags registers (but not the stack pointer) onto the existing stack. On the other hand, if the hardware detects that it is switching from user-mode to kernel-mode, then the processor also changes the stack pointer to the base of the interrupt stack and pushes the original stack pointer along with the instruction pointer and eflags registers onto the new stack.</SPAN></B> </P>
<LI class=itemize>
<P><B><SPAN class=extract><B>Returning from the handler.</B> When the iret instruction is called, it inspects both the current eflags register and the value on the stack that it will use to restore the earlier eflags register. If the mode bit is identical, then iret just pops the instruction pointer and eflags register and continues to use the current stack. On the other hand, if the mode bit differs, then the iret instruction pops not only the instruction pointer and eflags register, but also the saved stack pointer, thus switching the processor&#8217;s stack pointer to the saved one.</SPAN></B> </P></LI></UL>
<P></P></TD></TR></TBODY></TABLE>
<HR>
</DIV><A id=x1-27001r52 name=x1-27001r52></A><A id=x1-280008 name=x1-280008>