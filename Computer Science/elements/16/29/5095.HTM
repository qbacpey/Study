<B><SPAN class=headers>Title:</SPAN></B><SPAN class=RefText> 4.8 Implementing Multi-Threaded Processes : Per-Processor Kernel Threads</SPAN></FONT>. 
<P></P>
<P>It is possible to adapt the green threads approach to work on a multiprocessor. For many parallel scientific applications, the cost of creating and synchronizing threads is paramount, and so an approach that requires a kernel call for most thread operations would be prohibitive. Instead, the library multiplexes user-level threads on top of kernel threads, in exactly the same way that the kernel multiplexes kernel threads on top of physical processors. </P>
<P>&#32447;&#31243;&#24211;&#20250;&#22312;&#20869;&#26680;&#32447;&#31243;&#30340;&#39030;&#19978;&#22810;&#24037;&#22797;&#29992;&#29992;&#25143;&#32447;&#31243;&#65292;&#26041;&#27861;&#31867;&#20284;&#20110;&#20869;&#26680;&#22312;&#29289;&#29702;&#22788;&#29702;&#22120;&#19978;&#22810;&#24037;&#22797;&#29992;&#20869;&#26680;&#32447;&#31243;</P>
<P></P>
<P>When the application starts up, the user-level thread library creates one kernel thread for each processor on the host machine. </P>
<P>&#24403;&#24212;&#29992;&#31243;&#24207;&#21551;&#21160;&#26102;&#65292;&#29992;&#25143;&#32423;&#32447;&#31243;&#24211;&#20250;&#20026;&#27599;&#19968;&#20010;&#22788;&#29702;&#22120;&#21019;&#24314;&#19968;&#20010;&#20869;&#26680;&#32447;&#31243;&#65292;&#31867;&#20284;&#20110;&#23545;&#22788;&#29702;&#22120;&#36827;&#34892;&#19968;&#23450;&#31243;&#24230;&#30340;&#34394;&#25311;&#21270;</P>
<P>As long as there is no other activity on the system, the kernel will assign each of these threads a processor. Each kernel thread executes the user-level scheduler in parallel: pull the next thread off the user-level ready list, and run it. </P>
<P>&#19978;&#36848;&#20869;&#26680;&#32447;&#31243;&#20250;&#24182;&#34892;&#25191;&#34892;&#29992;&#25143;&#32423;&#35843;&#24230;&#22120;&#65292;&#20063;&#23601;&#26159;&#20174;&#20934;&#22791;&#38431;&#21015;&#20013;&#36873;&#21462;&#29992;&#25143;&#32423;&#32447;&#31243;&#24182;&#25191;&#34892;&#23427;&#12290;&#22312;&#20869;&#26680;&#30475;&#26469;&#65292;&#23454;&#38469;&#19978;&#24182;&#19981;&#23384;&#22312;&#29992;&#25143;&#32423;&#32447;&#31243;&#65292;&#23384;&#22312;&#30340;&#20165;&#20165;&#21482;&#26159;&#36825;&#20123;&#34987;&#29992;&#20316;&#34394;&#25311;&#21270;&#22788;&#29702;&#22120;&#30340;&#20869;&#26680;&#32447;&#31243;&#32780;&#24050;&#65292;&#21482;&#19981;&#36807;&#22312;&#20182;&#19981;&#30693;&#36947;&#30340;&#22320;&#26041;&#65292;&#36825;&#20123;&#20869;&#26680;&#32423;&#32447;&#31243;&#23454;&#38469;&#19978;&#26159;&#22312;&#25191;&#34892;&#29992;&#25143;&#32423;&#32447;&#31243;&#30340;&#20195;&#30721;</P>
<P>Because thread scheduling decisions occur at user level, they can be flexible and application-specific; for example, in a parallel graph algorithm, the programmer might adjust the priority of various threads based on the results of the computation on other parts of the graph. </P>
<P>&#20869;&#26680;&#32447;&#31243;&#22312;&#25191;&#34892;&#29992;&#25143;&#32447;&#31243;&#35843;&#24230;&#22120;&#21644;&#29992;&#25143;&#32447;&#31243;&#30340;&#26102;&#20505;&#65292;&#23454;&#38469;&#19978;&#37117;&#20250;&#36716;&#20837;&#29992;&#25143;&#27169;&#24335;&#65292;&#27491;&#22240;&#22914;&#27492;&#65292;&#32447;&#31243;&#35843;&#24230;&#23601;&#26174;&#24471;&#38750;&#24120;&#28789;&#27963;&#65288;&#27605;&#31455;&#21462;&#20915;&#20110;&#24212;&#29992;&#31243;&#24207;&#65289;</P>
<P>Of course, most of the downsides of green threads are still present in these systems: </P>
<UL class=itemize1>
<LI class=itemize>
<P>Any time a user-level thread calls into the kernel, its host kernel thread blocks. This prevents the thread library from running a different user-level thread on that processor in the meantime. <BR>&#20219;&#20309;&#26102;&#20505;&#26576;&#20010;&#29992;&#25143;&#32423;&#32447;&#31243;&#25191;&#34892;&#31995;&#32479;&#35843;&#29992;&#26102;&#65292;&#20854;&#23487;&#20027;&#20869;&#26680;&#32447;&#31243;&#37117;&#20250;&#34987;&#26242;&#20572;&#12290;&#30001;&#20110;&#23487;&#20027;&#36827;&#31243;&#27492;&#26102;&#27809;&#26377;&#21150;&#27861;&#25191;&#34892;&#35843;&#24230;&#22120;&#65292;&#33258;&#28982;&#23601;&#27809;&#26377;&#21150;&#27861;&#20999;&#25442;&#25191;&#34892;&#20854;&#20182;&#32447;&#31243;</P>
<LI class=itemize>
<P>Any time the kernel time-slices a kernel thread, the user-level thread it was running is also suspended. The library cannot resume that thread until the kernel thread resumes.<BR>&#20219;&#20309;&#26102;&#20505;&#22914;&#26524;&#23487;&#20027;&#20869;&#26680;&#32447;&#31243;&#34987;&#20999;&#25442;&#20102;&#65288;time-slice&#65289;&#37027;&#20040;&#20854;&#25152;&#36816;&#34892;&#30340;&#29992;&#25143;&#32423;&#32447;&#31243;&#20063;&#20250;&#34987;&#38543;&#20043;&#26242;&#20572;&#65292;&#30452;&#21040;&#20869;&#26680;&#32447;&#31243;&#34987;&#24674;&#22797;&#26102;&#35813;&#32447;&#31243;&#25165;&#33021;&#24674;&#22797;&#25191;&#34892;&#12290;&#36825;&#20010;&#38382;&#39064;&#22312;&#21333;&#22788;&#29702;&#22120;&#19978;&#26159;&#20307;&#29616;&#19981;&#20986;&#26469;&#30340;&#65292;&#21482;&#26377;&#22312;&#22810;&#22788;&#29702;&#22120;&#19978;&#36825;&#20010;&#38382;&#39064;&#25165;&#24471;&#20197;&#26174;&#29616;&#65292;&#27605;&#31455;&#36825;&#20250;&#35753;&#35813;&#29992;&#25143;&#32447;&#31243;&#34987;&#38145;&#22312;&#36825;&#37324;&#22788;&#29702;&#22120;&#19978;&#65292;&#19981;&#33021;&#22312;&#20854;&#23427;&#22788;&#29702;&#22120;&#19978;&#36816;&#34892;</P></LI></UL>