<STRONG><FONT color=blue>Operating Systems: Principles and Practice (Second Edition) Volume II : 4. Concurrency and Threads : </FONT></STRONG>
<H4 class=subsectionHead><SPAN class=headers>Title:</SPAN></B><SPAN class=RefText> 4.8.2 Implementing User-Level Threads Without Kernel Support</SPAN></FONT></H4>It is also possible to implement threads as a library completely at user level, without any operating system support. Early thread libraries took this pure user-level approach for the simple reason that few operating systems supported multi-threaded processes. Even once operating system support for threads became widespread, pure user-level threads were sometimes used to minimize dependencies on specific operating systems and to maximize portability; <SPAN class=extract>for example, the earliest implementations of Sun&#8217;s Java Virtual Machine (JVM) implemented what were called <EM><A data-9uzdtcnnj6xqoalwmdp3qa='{"name": "OEBPS/Text/part0000.xhtml", "frag": "glo:green threads"}'>green threads</A></EM>, a pure user-level implementation of threads. 
<P>The basic idea is simple. The thread library instantiates all of its data structures within the process: TCBs, the ready list, the finished list, and the waiting lists all are just data structures in the process&#8217;s address space. Then, calls to the thread library are just procedure calls, akin to how the same functions are implemented within a multi-threaded kernel. </P></SPAN>
<P>To the operating system kernel, a multi-threaded application using green threads appears to be a normal, single-threaded process. The process as a whole can make system calls, be time-sliced, etc. Unlike with kernel threads, when a process using green threads is time-sliced, the entire process, including all of its threads, is suspended. </P>
<P>A limitation of green threads is that the operating system kernel is unaware of the state of the user-level ready list. If the application performs a system call that blocks waiting for I/O, the kernel is unable to run a different user-level thread. Likewise, on a multiprocessor, the kernel is unable to run the different threads running within a single process on different processors. </P><B><SPAN class=extract>
<P><B>Preemptive User-level Threads.</B> However, it is possible on most operating systems to implement preemption among user-level threads executing within a process. As we discussed in Chapter&nbsp;2, most operating systems provide an upcall mechanism to deliver asynchronous event notification to a process; on UNIX these are called signal handlers. Typical events or signals include the user hitting &#8220;Escape&#8221; or on UNIX &#8220;Control-C&#8221;; this informs the application to attempt to cleanly exit. Another common event is a timer interrupt to signal elapsed real time. To deliver an event, the kernel suspends the process execution and then resumes it running at a handler specified by the user code, typically on a separate upcall or signal stack. </P>
<P>To implement preemptive multi-threading for some process P : </P>
<OL class=enumerate1>
<LI class=enumerate><A id=x1-30002x1 name=x1-30002x1></A>
<P>The user-level thread library makes a system call to register a timer signal handler and signal stack with the kernel. </P>
<LI class=enumerate><A id=x1-30004x2 name=x1-30004x2></A>
<P>When a hardware timer interrupt occurs, the hardware saves P &#8217;s register state and runs the kernel&#8217;s handler. </P>
<LI class=enumerate><A id=x1-30006x3 name=x1-30006x3></A>
<P>Instead of restoring P &#8217;s register state and resuming P where it was interrupted, the kernel&#8217;s handler copies P &#8217;s saved registers onto P &#8217;s signal stack. </P>
<LI class=enumerate><A id=x1-30008x4 name=x1-30008x4></A>
<P>The kernel resumes execution in P at the registered signal handler on the signal stack. </P>
<LI class=enumerate><A id=x1-30010x5 name=x1-30010x5></A>
<P>The signal handler copies the processor state of the preempted user-level thread from the signal stack to that thread&#8217;s TCB. </P>
<LI class=enumerate><A id=x1-30012x6 name=x1-30012x6></A>
<P>The signal handler chooses the next thread to run, re-enables the signal handler (the equivalent of re-enabling interrupts), and restores the new thread&#8217;s state from its TCB into the processor. execution with the state (newly) stored on the signal stack.</P></LI></OL>
<P>This approach virtualizes interrupts and processor exceptions, providing a user-level process with a very similar picture to the one the kernel gets when these events occur. </P>
<P></SPAN></B><A id=x1-30013r55 name=x1-30013r55></A>