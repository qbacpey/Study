<H1><FONT style="BACKGROUND-COLOR: #7be1e1"><SPAN class=headers>Title:</SPAN></B><SPAN class=RefText> How does thread/process switching work in Pintos?</SPAN></FONT></FONT></FONT></H1>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">This page explains how thread switching, as well as process switching works in Pintos. We recommend reading it alongside the Pintos source code (the text below also includes several links to pertinent parts of the Pintos source code).</FONT></P>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">We begin by reviewing how kernel threads are represented in memory, and then explain what happens when a kernel thread is interrupted (e.g., by a timer interrupt), first in the simple case where the thread isn&#8217;t preempted, and then in the case where we switch to a different thread. We build on this to then explain how context switching works with processes, after first explaining how we can go from userspace to kernelspace (and back again)</FONT></P>
<DIV id=threads-in-memory class=section>
<H2><FONT style="BACKGROUND-COLOR: #7be1e1">Threads in memory</FONT><A title="Permalink to this headline" class=headerlink href="https://uchicago-cs.github.io/mpcs52030/switch.html#threads-in-memory"></A></H2>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">All the information for a thread is contained in a single page of memory (4 KB in Pintos). The<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">thread</FONT></SPAN></CODE><SPAN>&nbsp;</SPAN>struct containing information about the thread is stored at the bottom of the page, and the stack grows from the top to the bottom (see<SPAN>&nbsp;</SPAN></FONT><A class="reference external" href="https://uchicago-cs.github.io/pintos/pintos_6.html#SEC97"><FONT style="BACKGROUND-COLOR: #7be1e1" color=#0066cc>A.2.1 struct thread</FONT></A><FONT style="BACKGROUND-COLOR: #7be1e1"><SPAN>&nbsp;</SPAN>in the Pintos documentation for more details).</FONT></P>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">Suppose we have a thread that runs a function called<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">thread_one()</FONT></SPAN></CODE><SPAN>&nbsp;</SPAN>(i.e., when we called<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">thread_create</FONT></SPAN></CODE>, we passed<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">thread_one</FONT></SPAN></CODE><SPAN>&nbsp;</SPAN>as the<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">function</FONT></SPAN></CODE><SPAN>&nbsp;</SPAN>parameter). We do not need to worry about the details of how the thread is created; we will simply assume it is running.</FONT></P>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">The first entry in the stack for this thread actually isn&#8217;t<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">thread_one</FONT></SPAN></CODE><SPAN>&nbsp;</SPAN>but, rather, an entry for a Pintos function called<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">kernel_thread</FONT></SPAN></CODE>. This function acts as a wrapper for the thread&#8217;s<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">function</FONT></SPAN></CODE>, ensuring that the thread exits as soon as the function returns. This is the code for<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">kernel_thread</FONT></SPAN></CODE>:</FONT></P>
<DIV class=highlight-default>
<DIV class=highlight><PRE><SPAN></SPAN><FONT style="BACKGROUND-COLOR: #7be1e1"><SPAN class=o>/*</SPAN> <SPAN class=n>Function</SPAN> <SPAN class=n>used</SPAN> <SPAN class=k>as</SPAN> <SPAN class=n>the</SPAN> <SPAN class=n>basis</SPAN> <SPAN class=k>for</SPAN> <SPAN class=n>a</SPAN> <SPAN class=n>kernel</SPAN> <SPAN class=n>thread</SPAN><SPAN class=o>.</SPAN> <SPAN class=o>*/</SPAN>
<SPAN class=n>static</SPAN> <SPAN class=n>void</SPAN>
<SPAN class=n>kernel_thread</SPAN> <SPAN class=p>(</SPAN><SPAN class=n>thread_func</SPAN> <SPAN class=o>*</SPAN><SPAN class=n>function</SPAN><SPAN class=p>,</SPAN> <SPAN class=n>void</SPAN> <SPAN class=o>*</SPAN><SPAN class=n>aux</SPAN><SPAN class=p>)</SPAN>
<SPAN class=p>{</SPAN>
  <SPAN class=n>ASSERT</SPAN> <SPAN class=p>(</SPAN><SPAN class=n>function</SPAN> <SPAN class=o>!=</SPAN> <SPAN class=n>NULL</SPAN><SPAN class=p>);</SPAN>

  <SPAN class=n>intr_enable</SPAN> <SPAN class=p>();</SPAN>       <SPAN class=o>/*</SPAN> <SPAN class=n>The</SPAN> <SPAN class=n>scheduler</SPAN> <SPAN class=n>runs</SPAN> <SPAN class=k>with</SPAN> <SPAN class=n>interrupts</SPAN> <SPAN class=n>off</SPAN><SPAN class=o>.</SPAN> <SPAN class=o>*/</SPAN>
  <SPAN class=n>function</SPAN> <SPAN class=p>(</SPAN><SPAN class=n>aux</SPAN><SPAN class=p>);</SPAN>       <SPAN class=o>/*</SPAN> <SPAN class=n>Execute</SPAN> <SPAN class=n>the</SPAN> <SPAN class=n>thread</SPAN> <SPAN class=n>function</SPAN><SPAN class=o>.</SPAN> <SPAN class=o>*/</SPAN>
  <SPAN class=n>thread_exit</SPAN> <SPAN class=p>();</SPAN>       <SPAN class=o>/*</SPAN> <SPAN class=n>If</SPAN> <SPAN class=n>function</SPAN><SPAN class=p>()</SPAN> <SPAN class=n>returns</SPAN><SPAN class=p>,</SPAN> <SPAN class=n>kill</SPAN> <SPAN class=n>the</SPAN> <SPAN class=n>thread</SPAN><SPAN class=o>.</SPAN> <SPAN class=o>*/</SPAN>
<SPAN class=p>}</SPAN>
</FONT></PRE></DIV></DIV>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">That<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">thread_one</FONT></SPAN></CODE><SPAN>&nbsp;</SPAN>function may itself call other functions, which may call other functions, etc. The information about each function call is added to the stack (see<SPAN>&nbsp;</SPAN></FONT><A class="reference external" href="https://uchicago-cs.github.io/pintos/pintos_3.html#SEC50"><FONT style="BACKGROUND-COLOR: #7be1e1" color=#0066cc>3.5 80x86 Calling Convention</FONT></A><FONT style="BACKGROUND-COLOR: #7be1e1"><SPAN>&nbsp;</SPAN>in the Pintos documentation for details on the exact format for each stack entry).</FONT></P>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">Let&#8217;s say the thread is in the middle of running function<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">foobar()</FONT></SPAN></CODE>. The thread&#8217;s memory may look like this:</FONT></P><FONT style="BACKGROUND-COLOR: #7be1e1"><img alt=_images/stack1.png src="https://uchicago-cs.github.io/mpcs52030/_images/stack1.png"> </FONT>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">During the execution of the thread, the CPU&#8217;s<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">esp</FONT></SPAN></CODE><SPAN>&nbsp;</SPAN>register will point to the bottom-most address of the stack (or the &#8220;top&#8221; of the stack).</FONT></P></DIV>
<DIV id=what-happens-during-an-interrupt class=section>
<H2><FONT style="BACKGROUND-COLOR: #7be1e1">What happens during an interrupt</FONT><A title="Permalink to this headline" class=headerlink href="https://uchicago-cs.github.io/mpcs52030/switch.html#what-happens-during-an-interrupt"></A></H2>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">When an interrupt happens, the CPU automatically pushes the value of the following CPU registers onto the stack:</FONT></P>
<UL class=simple>
<LI><FONT style="BACKGROUND-COLOR: #7be1e1"><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">ss</FONT></SPAN></CODE>: Stack Segment Selector </FONT>
<LI><FONT style="BACKGROUND-COLOR: #7be1e1"><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">esp</FONT></SPAN></CODE>: Stack pointer </FONT>
<LI><FONT style="BACKGROUND-COLOR: #7be1e1"><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">eflags</FONT></SPAN></CODE>: CPU flags </FONT>
<LI><FONT style="BACKGROUND-COLOR: #7be1e1"><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">cs</FONT></SPAN></CODE>: Code Segment Selector </FONT>
<LI><FONT style="BACKGROUND-COLOR: #7be1e1"><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">eip</FONT></SPAN></CODE>: Instruction Pointer (i.e., the Program Counter)</FONT></LI></UL>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">For now, we can ignore the segment selectors. However, notice how the CPU saves enough information to be able to resume the execution of the thread: it saved the address of the next instruction to run (in<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">eip</FONT></SPAN></CODE>) and a pointer to the top of the thread&#8217;s stack (so we can return to the exact chain of function calls when the interrupt happened).</FONT></P>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">Next, the CPU will inspect the<SPAN>&nbsp;</SPAN></FONT><A class="reference external" href="http://wiki.osdev.org/Interrupt_Descriptor_Table"><FONT style="BACKGROUND-COLOR: #7be1e1" color=#0066cc>Interrupt Descriptor Table</FONT></A><FONT style="BACKGROUND-COLOR: #7be1e1"><SPAN>&nbsp;</SPAN>(IDT) and look for the entry corresponding to the interrupt that just happened. This entry will contain a memory location containing the<SPAN>&nbsp;</SPAN><EM>interrupt handler</EM><SPAN>&nbsp;</SPAN>for that interrupt, and the CPU will jump to that location.</FONT></P>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">In Pintos, the IDT is actually set up to always jump to a function called<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">intr_entry</FONT></SPAN></CODE><SPAN>&nbsp;</SPAN>(</FONT><A class="reference external" href="https://github.com/uchicago-cs/pintos/blob/master/src/threads/intr-stubs.S#L5-L39"><FONT style="BACKGROUND-COLOR: #7be1e1" color=#0066cc>source code</FONT></A><FONT style="BACKGROUND-COLOR: #7be1e1">) that is implemented in x86 assembly. This function pushes additional data into the stack (mostly CPU registers). The combination of the values pushed by the CPU and by<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">intr_entry</FONT></SPAN></CODE><SPAN>&nbsp;</SPAN>is called the<SPAN>&nbsp;</SPAN><EM>interrupt stack frame</EM>, which is used to save information about the interrupted thread (or process) and to provide the interrupt handler with the information it needs to handle the interrupt.</FONT></P>
<P><FONT style="BACKGROUND-COLOR: #7be1e1"><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">intr_entry</FONT></SPAN></CODE><SPAN>&nbsp;</SPAN>also sets up a call to a function called<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">intr_handler</FONT></SPAN></CODE><SPAN>&nbsp;</SPAN>that is implemented in C (</FONT><A class="reference external" href="https://github.com/uchicago-cs/pintos/blob/master/src/threads/interrupt.c#L345"><FONT style="BACKGROUND-COLOR: #7be1e1" color=#0066cc>source code</FONT></A><FONT style="BACKGROUND-COLOR: #7be1e1">). This function has a single parameter: a pointer to a<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">intr_frame</FONT></SPAN></CODE><SPAN>&nbsp;</SPAN>struct (</FONT><A class="reference external" href="https://github.com/uchicago-cs/pintos/blob/master/src/threads/interrupt.h#L19-L56"><FONT style="BACKGROUND-COLOR: #7be1e1" color=#0066cc>source code</FONT></A><FONT style="BACKGROUND-COLOR: #7be1e1">) that encapsulates all the values in the interrupt stack frame.</FONT></P>
<P><FONT style="BACKGROUND-COLOR: #7be1e1"><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">intr_handler</FONT></SPAN></CODE><SPAN>&nbsp;</SPAN>is the function that will determine what function to call based on the interrupt type. During Pintos&#8217;s initialization (in the<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">main</FONT></SPAN></CODE><SPAN>&nbsp;</SPAN>function) certain functions are associated with certain interrupts. For example, the<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">timer_init</FONT></SPAN></CODE><SPAN>&nbsp;</SPAN>function (<SPAN>&nbsp;</SPAN></FONT><A class="reference external" href="https://github.com/uchicago-cs/pintos/blob/master/src/devices/timer.c#L33-L40"><FONT style="BACKGROUND-COLOR: #7be1e1" color=#0066cc>source code</FONT></A><FONT style="BACKGROUND-COLOR: #7be1e1">, called from<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">main</FONT></SPAN></CODE>) assigns the<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">timer_interrupt</FONT></SPAN></CODE><SPAN>&nbsp;</SPAN>function to handle interrupts from the timer.</FONT></P>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">If the interrupt we&#8217;re handling is a timer interrupt, then<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">intr_handler</FONT></SPAN></CODE><SPAN>&nbsp;</SPAN>would call<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">timer_interrupt</FONT></SPAN></CODE><SPAN>&nbsp;</SPAN>which, in turn, would call<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">thread_tick</FONT></SPAN></CODE>. At that point, the stack would look like this:</FONT></P><FONT style="BACKGROUND-COLOR: #7be1e1"><img alt=_images/stack2.png src="https://uchicago-cs.github.io/mpcs52030/_images/stack2.png"> </FONT>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">In the case where<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">thread_tick</FONT></SPAN></CODE><SPAN>&nbsp;</SPAN>does not preempt the running thread, it would return to<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">timer_interrupt</FONT></SPAN></CODE>, which will return to<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">intr_handler</FONT></SPAN></CODE>, which will return to the<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">intr_entry</FONT></SPAN></CODE><SPAN>&nbsp;</SPAN>function. The assembly code for this function &#8220;falls through&#8221; to<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">intr_exit</FONT></SPAN></CODE>, which restores the saved values in the stack (using the<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">popal</FONT></SPAN></CODE>,<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">popl</FONT></SPAN></CODE><SPAN>&nbsp;</SPAN>instructions) and discards the Pintos-saved information from the interrupt stack frame, leaving only the values that were automatically saved by the CPU. At this point, we run the assembly instruction<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">iret</FONT></SPAN></CODE>. This instruction will restore the values stored in the interrupt stack frame created by the CPU (<CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">ss</FONT></SPAN></CODE>,<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">esp</FONT></SPAN></CODE>,<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">eflags</FONT></SPAN></CODE>,<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">cs</FONT></SPAN></CODE>, and<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">eip</FONT></SPAN></CODE>), restoring the state of the CPU to the point where the interrupt happened (thus doing an &#8220;Interrupt RETurn&#8221;).</FONT></P></DIV>
<DIV id=what-happens-during-a-thread-switch class=section>
<H2><FONT style="BACKGROUND-COLOR: #7be1e1">What happens during a thread switch</FONT><A title="Permalink to this headline" class=headerlink href="https://uchicago-cs.github.io/mpcs52030/switch.html#what-happens-during-a-thread-switch"></A></H2>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">If a thread has used up its timeslice,<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">thread_tick</FONT></SPAN></CODE><SPAN>&nbsp;</SPAN>will call the function<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">intr_yield_on_return</FONT></SPAN></CODE>. However,<SPAN>&nbsp;</SPAN><EM>this doesn&#8217;t yield to the next thread at that point</EM>. Instead, it modifies a flag to let the interrupt handler know that, before returning from the interrupt, it should perform a context switch to a different thread (so that, when we return from the interrupt, we do so with the context, i.e., stack and program counter, of a different thread).</FONT></P>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">So, after<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">thread_tick</FONT></SPAN></CODE><SPAN>&nbsp;</SPAN>and<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">timer_interrupt</FONT></SPAN></CODE><SPAN>&nbsp;</SPAN>return,<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">intr_handler</FONT></SPAN></CODE><SPAN>&nbsp;</SPAN>will call<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">thread_yield</FONT></SPAN></CODE>, which will call<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">schedule</FONT></SPAN></CODE>.<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">schedule</FONT></SPAN></CODE><SPAN>&nbsp;</SPAN>picks the next thread to run and calls a function<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">switch_threads</FONT></SPAN></CODE>, implemented in x86 assembly, with two parameters:<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">cur</FONT></SPAN></CODE><SPAN>&nbsp;</SPAN>(a pointer to the<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">thread</FONT></SPAN></CODE><SPAN>&nbsp;</SPAN>struct of the current thread, i.e., the one that is being preempted) and<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">next</FONT></SPAN></CODE><SPAN>&nbsp;</SPAN>(a pointer to the<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">thread</FONT></SPAN></CODE><SPAN>&nbsp;</SPAN>struct of the next thread to run).</FONT></P>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">So, the stack will look like this:</FONT></P><FONT style="BACKGROUND-COLOR: #7be1e1"><img alt=_images/stack3.png src="https://uchicago-cs.github.io/mpcs52030/_images/stack3.png"> </FONT>
<P><FONT style="BACKGROUND-COLOR: #7be1e1"><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">switch_threads</FONT></SPAN></CODE><SPAN>&nbsp;</SPAN>is implemented in<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">switch.S</FONT></SPAN></CODE><SPAN>&nbsp;</SPAN>(</FONT><A class="reference external" href="https://github.com/uchicago-cs/pintos/blob/master/src/threads/switch.S"><FONT style="BACKGROUND-COLOR: #7be1e1" color=#0066cc>source code</FONT></A><FONT style="BACKGROUND-COLOR: #7be1e1">)</FONT></P>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">The key to understanding<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">switch_threads</FONT></SPAN></CODE><SPAN>&nbsp;</SPAN>is to first understand that, if we&#8217;re switching to another thread, that other thread must&#8217;ve also been running<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">switch_threads</FONT></SPAN></CODE><SPAN>&nbsp;</SPAN>when it was preempted. In fact, a thread that voluntarily or involuntarily yielded the CPU will always have a stack that looks like one of the following:</FONT></P><FONT style="BACKGROUND-COLOR: #7be1e1"><img alt=_images/stack4.png src="https://uchicago-cs.github.io/mpcs52030/_images/stack4.png"> </FONT>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">The intuition behind<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">switch_threads</FONT></SPAN></CODE><SPAN>&nbsp;</SPAN>is that, to switch to another thread, we just need to &#8220;switch the stacks&#8221; (because every thread is guaranteed to be running<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">switch_threads</FONT></SPAN></CODE><SPAN>&nbsp;</SPAN>at the point it was preempted), and we can do this simply by changing the value of<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">esp</FONT></SPAN></CODE>. Let&#8217;s take a closer look at how this happens.</FONT></P>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">Right after calling<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">switch_threads</FONT></SPAN></CODE>, the bottom of the stack will look like this:</FONT></P><FONT style="BACKGROUND-COLOR: #7be1e1"><img alt=_images/stack5.png src="https://uchicago-cs.github.io/mpcs52030/_images/stack5.png"> </FONT>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">The address of the start of the<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">switch_threads</FONT></SPAN></CODE><SPAN>&nbsp;</SPAN>stack frame (<CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">0x0C00</FONT></SPAN></CODE>) is arbitrary and has no deep significance. However, all the other values shown would be consistent with the<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">switch_threads</FONT></SPAN></CODE><SPAN>&nbsp;</SPAN>stack frame starting at<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">0x0C00</FONT></SPAN></CODE>.</FONT></P>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">First of all,<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">switch_threads</FONT></SPAN></CODE><SPAN>&nbsp;</SPAN>needs to save some registers (this is simply required by the x86 architecture):</FONT></P>
<DIV class=highlight-default>
<DIV class=highlight><PRE><SPAN></SPAN><FONT style="BACKGROUND-COLOR: #7be1e1"><SPAN class=n>pushl</SPAN> <SPAN class=o>%</SPAN><SPAN class=n>ebx</SPAN>
<SPAN class=n>pushl</SPAN> <SPAN class=o>%</SPAN><SPAN class=n>ebp</SPAN>
<SPAN class=n>pushl</SPAN> <SPAN class=o>%</SPAN><SPAN class=n>esi</SPAN>
<SPAN class=n>pushl</SPAN> <SPAN class=o>%</SPAN><SPAN class=n>edi</SPAN>
</FONT></PRE></DIV></DIV>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">And our stack will now look like this:</FONT></P><FONT style="BACKGROUND-COLOR: #7be1e1"><img alt=_images/stack6.png src="https://uchicago-cs.github.io/mpcs52030/_images/stack6.png"> </FONT>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">Before we see what happens next, recall that the<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">thread</FONT></SPAN></CODE><SPAN>&nbsp;</SPAN>struct stores information about each thread:</FONT></P>
<DIV class=highlight-default>
<DIV class=highlight><PRE><SPAN></SPAN><FONT style="BACKGROUND-COLOR: #7be1e1"><SPAN class=n>struct</SPAN> <SPAN class=n>thread</SPAN>
  <SPAN class=p>{</SPAN>
    <SPAN class=o>/*</SPAN> <SPAN class=n>Owned</SPAN> <SPAN class=n>by</SPAN> <SPAN class=n>thread</SPAN><SPAN class=o>.</SPAN><SPAN class=n>c</SPAN><SPAN class=o>.</SPAN> <SPAN class=o>*/</SPAN>
    <SPAN class=n>tid_t</SPAN> <SPAN class=n>tid</SPAN><SPAN class=p>;</SPAN>                          <SPAN class=o>/*</SPAN> <SPAN class=n>Thread</SPAN> <SPAN class=n>identifier</SPAN><SPAN class=o>.</SPAN> <SPAN class=o>*/</SPAN>
    <SPAN class=n>enum</SPAN> <SPAN class=n>thread_status</SPAN> <SPAN class=n>status</SPAN><SPAN class=p>;</SPAN>          <SPAN class=o>/*</SPAN> <SPAN class=n>Thread</SPAN> <SPAN class=n>state</SPAN><SPAN class=o>.</SPAN> <SPAN class=o>*/</SPAN>
    <SPAN class=n>char</SPAN> <SPAN class=n>name</SPAN><SPAN class=p>[</SPAN><SPAN class=mi>16</SPAN><SPAN class=p>];</SPAN>                      <SPAN class=o>/*</SPAN> <SPAN class=n>Name</SPAN> <SPAN class=p>(</SPAN><SPAN class=k>for</SPAN> <SPAN class=n>debugging</SPAN> <SPAN class=n>purposes</SPAN><SPAN class=p>)</SPAN><SPAN class=o>.</SPAN> <SPAN class=o>*/</SPAN>
    <SPAN class=n>uint8_t</SPAN> <SPAN class=o>*</SPAN><SPAN class=n>stack</SPAN><SPAN class=p>;</SPAN>                     <SPAN class=o>/*</SPAN> <SPAN class=n>Saved</SPAN> <SPAN class=n>stack</SPAN> <SPAN class=n>pointer</SPAN><SPAN class=o>.</SPAN> <SPAN class=o>*/</SPAN>

    <SPAN class=o>/*</SPAN> <SPAN class=n>etc</SPAN><SPAN class=o>.</SPAN> <SPAN class=o>*/</SPAN>

  <SPAN class=p>}</SPAN>
</FONT></PRE></DIV></DIV>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">Notice how it contains a<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">stack</FONT></SPAN></CODE><SPAN>&nbsp;</SPAN>field. This field is used to save the value of<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">esp</FONT></SPAN></CODE><SPAN>&nbsp;</SPAN>when a thread is preempted. However, in x86 assembly we can&#8217;t just write<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">t-&gt;stack</FONT></SPAN></CODE>. Instead, if we want to access that value in the struct, we need the address of the struct in memory<SPAN>&nbsp;</SPAN><EM>and</EM><SPAN>&nbsp;</SPAN>the offset (in bytes) of the field we want to access. This is defined in<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">thread.c</FONT></SPAN></CODE>:</FONT></P>
<DIV class=highlight-default>
<DIV class=highlight><PRE><SPAN></SPAN><FONT style="BACKGROUND-COLOR: #7be1e1"><SPAN class=n>uint32_t</SPAN> <SPAN class=n>thread_stack_ofs</SPAN> <SPAN class=o>=</SPAN> <SPAN class=n>offsetof</SPAN> <SPAN class=p>(</SPAN><SPAN class=n>struct</SPAN> <SPAN class=n>thread</SPAN><SPAN class=p>,</SPAN> <SPAN class=n>stack</SPAN><SPAN class=p>);</SPAN>
</FONT></PRE></DIV></DIV>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">Since we need to use this value in<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">switch_threads</FONT></SPAN></CODE>, we load it into register<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">edx</FONT></SPAN></CODE>:</FONT></P>
<DIV class=highlight-default>
<DIV class=highlight><PRE><SPAN></SPAN><FONT style="BACKGROUND-COLOR: #7be1e1"><SPAN class=o>.</SPAN><SPAN class=n>globl</SPAN> <SPAN class=n>thread_stack_ofs</SPAN>
        <SPAN class=n>mov</SPAN> <SPAN class=n>thread_stack_ofs</SPAN><SPAN class=p>,</SPAN> <SPAN class=o>%</SPAN><SPAN class=n>edx</SPAN>
</FONT></PRE></DIV></DIV>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">Next,<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">switch.h</FONT></SPAN></CODE><SPAN>&nbsp;</SPAN>defines SWITCH_CUR and SWITCH_NEXT as the offset of cur and next within the stack frame (20 and 24; see how this matches with what is shown in the earlier figure). In x86 assembly, the expression<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">SWITCH_CUR(%esp)</FONT></SPAN></CODE><SPAN>&nbsp;</SPAN>becomes<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">20(%esp)</FONT></SPAN></CODE>, which translates to the memory address<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><FONT face="Courier New"><SPAN class=pre>esp</SPAN><SPAN>&nbsp;</SPAN><SPAN class=pre>+</SPAN><SPAN>&nbsp;</SPAN><SPAN class=pre>20</SPAN></FONT></CODE>. In other words, this gives us the address of the current thread (<CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">cur</FONT></SPAN></CODE>).</FONT></P>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">Similary,<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">SWITCH_NEXT(%esp)</FONT></SPAN></CODE><SPAN>&nbsp;</SPAN>gives us the address of the<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">next</FONT></SPAN></CODE><SPAN>&nbsp;</SPAN>thread.</FONT></P>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">So, the following piece of assembly code:</FONT></P>
<DIV class=highlight-default>
<DIV class=highlight><PRE><SPAN></SPAN><FONT style="BACKGROUND-COLOR: #7be1e1"><SPAN class=n>movl</SPAN> <SPAN class=n>SWITCH_CUR</SPAN><SPAN class=p>(</SPAN><SPAN class=o>%</SPAN><SPAN class=n>esp</SPAN><SPAN class=p>),</SPAN> <SPAN class=o>%</SPAN><SPAN class=n>eax</SPAN>
<SPAN class=n>movl</SPAN> <SPAN class=o>%</SPAN><SPAN class=n>esp</SPAN><SPAN class=p>,</SPAN> <SPAN class=p>(</SPAN><SPAN class=o>%</SPAN><SPAN class=n>eax</SPAN><SPAN class=p>,</SPAN><SPAN class=o>%</SPAN><SPAN class=n>edx</SPAN><SPAN class=p>,</SPAN><SPAN class=mi>1</SPAN><SPAN class=p>)</SPAN>
<SPAN class=n>movl</SPAN> <SPAN class=n>SWITCH_NEXT</SPAN><SPAN class=p>(</SPAN><SPAN class=o>%</SPAN><SPAN class=n>esp</SPAN><SPAN class=p>),</SPAN> <SPAN class=o>%</SPAN><SPAN class=n>ecx</SPAN>
<SPAN class=n>movl</SPAN> <SPAN class=p>(</SPAN><SPAN class=o>%</SPAN><SPAN class=n>ecx</SPAN><SPAN class=p>,</SPAN><SPAN class=o>%</SPAN><SPAN class=n>edx</SPAN><SPAN class=p>,</SPAN><SPAN class=mi>1</SPAN><SPAN class=p>),</SPAN> <SPAN class=o>%</SPAN><SPAN class=n>esp</SPAN>
</FONT></PRE></DIV></DIV>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">Is the equivalent of doing this:</FONT></P>
<DIV class=highlight-default>
<DIV class=highlight><PRE><SPAN></SPAN><FONT style="BACKGROUND-COLOR: #7be1e1"><SPAN class=n>cur</SPAN><SPAN class=o>-&gt;</SPAN><SPAN class=n>stack</SPAN> <SPAN class=o>=</SPAN> <SPAN class=n>esp</SPAN><SPAN class=p>;</SPAN>
<SPAN class=n>esp</SPAN> <SPAN class=o>=</SPAN> <SPAN class=nb>next</SPAN><SPAN class=o>-&gt;</SPAN><SPAN class=n>stack</SPAN><SPAN class=p>;</SPAN>
</FONT></PRE></DIV></DIV>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">In other words, we save the stack pointer of the current thread, and set<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">esp</FONT></SPAN></CODE><SPAN>&nbsp;</SPAN>to point to the (previously saved) stack pointer of the next thread to run.</FONT></P>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">Once we&#8217;ve done this, we have switched threads, and all that remains is to restore the registers we had previously pushed onto the stack, and return from<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">switch_threads</FONT></SPAN></CODE>:</FONT></P>
<DIV class=highlight-default>
<DIV class=highlight><PRE><SPAN></SPAN><FONT style="BACKGROUND-COLOR: #7be1e1"><SPAN class=n>popl</SPAN> <SPAN class=o>%</SPAN><SPAN class=n>edi</SPAN>
<SPAN class=n>popl</SPAN> <SPAN class=o>%</SPAN><SPAN class=n>esi</SPAN>
<SPAN class=n>popl</SPAN> <SPAN class=o>%</SPAN><SPAN class=n>ebp</SPAN>
<SPAN class=n>popl</SPAN> <SPAN class=o>%</SPAN><SPAN class=n>ebx</SPAN>
<SPAN class=n>ret</SPAN>
</FONT></PRE></DIV></DIV></DIV>
<DIV id=switching-between-kernelspace-and-userspace class=section>
<H2><FONT style="BACKGROUND-COLOR: #7be1e1">Switching between kernelspace and userspace</FONT><A title="Permalink to this headline" class=headerlink href="https://uchicago-cs.github.io/mpcs52030/switch.html#switching-between-kernelspace-and-userspace"></A></H2>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">Note: The following section assumes knowledge of how paging and segmentation works (although not necessarily in an x86 architecture)</FONT></P>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">To understand how context switching works with user processes, we first need to understand how we can go from running a process to running kernel code (which will have more privileges than the user process&#8217;s code). Understanding this is useful not just for context switches, but for understanding other aspects of the OS, like interrupt handling and system calls (since, in both these cases, the user process must temporarily yield control to the kernel to handle the interrupt or system call).</FONT></P>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">First of all, the x86 architecture has four Privilege Levels (PL), numbered from 0 to 3. When PL=0, we are running in the &#8220;Supervisor&#8221; level, which allows running all instructions. A PL greater than 0 (typically 3) is the &#8220;User&#8221; level and does not allow certain operations (like I/O, updating certain registers, etc.). For now, we can assume that the &#8220;current PL&#8221; is stored in a CPU register (this is not entirely accurate, but will be enough for now, specially since the actual way that PLs are handled in an x86 architecture is pretty elaborate).</FONT></P>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">Now, let&#8217;s look at how physical and virtual memory is laid out. Pintos only uses 64MB of physical memory, laid out like this:</FONT></P>
<DIV class=highlight-default>
<DIV class=highlight><PRE><SPAN></SPAN><FONT style="BACKGROUND-COLOR: #7be1e1"><SPAN class=mh>0x04000000</SPAN> <SPAN class=o>+----------------------------------+</SPAN>
           <SPAN class=o>|</SPAN>                                  <SPAN class=o>|</SPAN>
           <SPAN class=o>|</SPAN>            <SPAN class=n>page</SPAN> <SPAN class=n>pool</SPAN>             <SPAN class=o>|</SPAN>
           <SPAN class=o>|</SPAN>             <SPAN class=p>(</SPAN><SPAN class=mi>63</SPAN> <SPAN class=n>MB</SPAN><SPAN class=p>)</SPAN>              <SPAN class=o>|</SPAN>
           <SPAN class=o>|</SPAN>                                  <SPAN class=o>|</SPAN>
            <SPAN class=n>vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv</SPAN>

            <SPAN class=o>^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</SPAN>
           <SPAN class=o>|</SPAN>                                  <SPAN class=o>|</SPAN>
           <SPAN class=o>|</SPAN>                                  <SPAN class=o>|</SPAN>
<SPAN class=mh>0x00100000</SPAN> <SPAN class=o>+----------------------------------+</SPAN>
           <SPAN class=o>|</SPAN>                                  <SPAN class=o>|</SPAN>
           <SPAN class=o>|</SPAN>                                  <SPAN class=o>|</SPAN>
<SPAN class=mh>0x000A0000</SPAN> <SPAN class=o>+----------------------------------+</SPAN>
           <SPAN class=o>|</SPAN>                                  <SPAN class=o>|</SPAN>
           <SPAN class=o>|</SPAN>        <SPAN class=n>Kernel</SPAN> <SPAN class=n>code</SPAN> <SPAN class=o>+</SPAN> <SPAN class=n>data</SPAN>        <SPAN class=o>|</SPAN>
           <SPAN class=o>|</SPAN>                                  <SPAN class=o>|</SPAN>
<SPAN class=mh>0x00020000</SPAN> <SPAN class=o>+----------------------------------+</SPAN>
           <SPAN class=o>|</SPAN>                                  <SPAN class=o>|</SPAN>
           <SPAN class=o>|</SPAN>                                  <SPAN class=o>|</SPAN>
<SPAN class=mh>0x0000D000</SPAN> <SPAN class=o>+----------------------------------+</SPAN>
           <SPAN class=o>|</SPAN>       <SPAN class=n>initial</SPAN> <SPAN class=n>kernel</SPAN> <SPAN class=n>thread</SPAN>      <SPAN class=o>|</SPAN>
<SPAN class=mh>0x0000E000</SPAN> <SPAN class=o>+----------------------------------+</SPAN>
           <SPAN class=o>|</SPAN>                                  <SPAN class=o>|</SPAN>
<SPAN class=mh>0x00007E00</SPAN> <SPAN class=o>+----------------------------------+</SPAN>
           <SPAN class=o>|</SPAN>            <SPAN class=n>Boot</SPAN> <SPAN class=n>loader</SPAN>           <SPAN class=o>|</SPAN>
<SPAN class=mh>0x00007C00</SPAN> <SPAN class=o>+----------------------------------+</SPAN>
           <SPAN class=o>|</SPAN>                                  <SPAN class=o>|</SPAN>
           <SPAN class=o>|</SPAN>                                  <SPAN class=o>|</SPAN>
         <SPAN class=mi>0</SPAN> <SPAN class=o>+----------------------------------+</SPAN>
</FONT></PRE></DIV></DIV>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">The above figure omits some parts of memory that are not relevant to this discussion. The full memory map can be found in<SPAN>&nbsp;</SPAN></FONT><A class="reference external" href="https://uchicago-cs.github.io/pintos/pintos_6.html#SEC95"><FONT style="BACKGROUND-COLOR: #7be1e1" color=#0066cc>A.1.4 Physical Memory Map</FONT></A><FONT style="BACKGROUND-COLOR: #7be1e1">)</FONT></P>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">A process&#8217;s virtual memory looks like this (let&#8217;s assume it has already been loaded; we&#8217;ll discuss loading later on):</FONT></P>
<DIV class=highlight-default>
<DIV class=highlight><PRE><SPAN></SPAN><FONT style="BACKGROUND-COLOR: #7be1e1"><SPAN class=mh>0xFFFFFFFF</SPAN> <SPAN class=o>+----------------------------------+</SPAN>
           <SPAN class=o>|</SPAN>                                  <SPAN class=o>|</SPAN>
           <SPAN class=o>|</SPAN>              <SPAN class=n>Unused</SPAN>              <SPAN class=o>|</SPAN>
           <SPAN class=o>|</SPAN>                                  <SPAN class=o>|</SPAN>
            <SPAN class=n>vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv</SPAN>

            <SPAN class=o>^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</SPAN>
           <SPAN class=o>|</SPAN>                                  <SPAN class=o>|</SPAN>
<SPAN class=mh>0xC4000000</SPAN> <SPAN class=o>+----------------------------------+</SPAN>
           <SPAN class=o>|</SPAN>                                  <SPAN class=o>|</SPAN>
           <SPAN class=o>|</SPAN>    <SPAN class=n>Mapped</SPAN> <SPAN class=n>to</SPAN> <SPAN class=n>Physical</SPAN> <SPAN class=n>Memory</SPAN>     <SPAN class=o>|</SPAN>
           <SPAN class=o>|</SPAN>                                  <SPAN class=o>|</SPAN>
<SPAN class=mh>0xC0000000</SPAN> <SPAN class=o>+----------------------------------+</SPAN> <SPAN class=n>PHYS_BASE</SPAN>
           <SPAN class=o>|</SPAN>            <SPAN class=n>user</SPAN> <SPAN class=n>stack</SPAN>            <SPAN class=o>|</SPAN>
           <SPAN class=o>|</SPAN>                 <SPAN class=o>|</SPAN>                <SPAN class=o>|</SPAN>
           <SPAN class=o>|</SPAN>                 <SPAN class=o>|</SPAN>                <SPAN class=o>|</SPAN>
           <SPAN class=o>|</SPAN>                 <SPAN class=n>V</SPAN>                <SPAN class=o>|</SPAN>
           <SPAN class=o>|</SPAN>          <SPAN class=n>grows</SPAN> <SPAN class=n>downward</SPAN>          <SPAN class=o>|</SPAN>
           <SPAN class=o>|</SPAN>                                  <SPAN class=o>|</SPAN>
           <SPAN class=o>|</SPAN>                                  <SPAN class=o>|</SPAN>
           <SPAN class=o>|</SPAN>                                  <SPAN class=o>|</SPAN>
           <SPAN class=o>|</SPAN>                                  <SPAN class=o>|</SPAN>
           <SPAN class=o>|</SPAN>           <SPAN class=n>grows</SPAN> <SPAN class=n>upward</SPAN>           <SPAN class=o>|</SPAN>
           <SPAN class=o>|</SPAN>                 <SPAN class=o>^</SPAN>                <SPAN class=o>|</SPAN>
           <SPAN class=o>|</SPAN>                 <SPAN class=o>|</SPAN>                <SPAN class=o>|</SPAN>
           <SPAN class=o>|</SPAN>                 <SPAN class=o>|</SPAN>                <SPAN class=o>|</SPAN>
           <SPAN class=o>+----------------------------------+</SPAN>
           <SPAN class=o>|</SPAN> <SPAN class=n>uninitialized</SPAN> <SPAN class=n>data</SPAN> <SPAN class=n>segment</SPAN> <SPAN class=p>(</SPAN><SPAN class=n>BSS</SPAN><SPAN class=p>)</SPAN> <SPAN class=o>|</SPAN>
           <SPAN class=o>+----------------------------------+</SPAN>
           <SPAN class=o>|</SPAN>     <SPAN class=n>initialized</SPAN> <SPAN class=n>data</SPAN> <SPAN class=n>segment</SPAN>     <SPAN class=o>|</SPAN>
           <SPAN class=o>+----------------------------------+</SPAN>
           <SPAN class=o>|</SPAN>           <SPAN class=n>code</SPAN> <SPAN class=n>segment</SPAN>           <SPAN class=o>|</SPAN>
<SPAN class=mh>0x08048000</SPAN> <SPAN class=o>+----------------------------------+</SPAN>
           <SPAN class=o>|</SPAN>                                  <SPAN class=o>|</SPAN>
           <SPAN class=o>|</SPAN>                                  <SPAN class=o>|</SPAN>
           <SPAN class=o>|</SPAN>                                  <SPAN class=o>|</SPAN>
           <SPAN class=o>|</SPAN>                                  <SPAN class=o>|</SPAN>
           <SPAN class=o>|</SPAN>                                  <SPAN class=o>|</SPAN>
         <SPAN class=mi>0</SPAN> <SPAN class=o>+----------------------------------+</SPAN>
</FONT></PRE></DIV></DIV>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">The memory below<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">PHYS_BASE</FONT></SPAN></CODE><SPAN>&nbsp;</SPAN>is<SPAN>&nbsp;</SPAN><EM>userspace</EM><SPAN>&nbsp;</SPAN>(the memory used by the user process) and the memory above<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">PHYS_BASE</FONT></SPAN></CODE><SPAN>&nbsp;</SPAN>is<SPAN>&nbsp;</SPAN><EM>kernelspace</EM><SPAN>&nbsp;</SPAN>(the memory used by the kernel which, in Pintos, is just a direct mapping to the full 64MB of physical memory).</FONT></P>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">Note: The terms &#8220;userspace&#8221; and &#8220;kernelspace&#8221; (and &#8220;user land&#8221; and &#8220;kernel land&#8221;) are also often used to refer to &#8220;running with user privileges (PL=3)&#8221; and &#8220;running with supervisor privileges (PL=0)&#8221;.</FONT></P>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">However, the above memory map makes it seem like every user process has unfettered access to the entire physical memory (which would seem to defeat the memory protection provided by virtual memory). However, all the mappings above<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">PHYS_BASE</FONT></SPAN></CODE><SPAN>&nbsp;</SPAN>are configured to require PL=0: if a user process (running at PL=3) tries to access them, a page fault will happen.</FONT></P>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">The<SPAN>&nbsp;</SPAN><EM>program loader</EM><SPAN>&nbsp;</SPAN>is the part of the OS in charge of taking an executable file, and loading it into memory, creating a virtual memory map like the one above. In Pintos, the program loader is already provided for you, although you will have to tweak it in the projects. It does the following:</FONT></P>
<OL class="arabic simple">
<LI><FONT style="BACKGROUND-COLOR: #7be1e1">It creates a new kernel thread (</FONT><A class="reference external" href="actualprogramloader.https://github.com/uchicago-cs/pintos/blob/master/src/userprog/process.c#L42"><FONT style="BACKGROUND-COLOR: #7be1e1" color=#0066cc>source code</FONT></A><FONT style="BACKGROUND-COLOR: #7be1e1">). In fact, Pintos has a 1-1 mapping between user processes and kernel threads (and does not allow for multiple threads within a process). This thread is placed on the ready list and will eventually run. </FONT>
<LI><FONT style="BACKGROUND-COLOR: #7be1e1">Once the thread starts running, it creates a page table with no mappings between 0 and 3GB, and with the physical memory mappings between 3GB and 3GB+64MB (requiring PL=0 to access the memory addresses in that range) </FONT>
<LI><FONT style="BACKGROUND-COLOR: #7be1e1">The program loaded then reads the actual program from an ELF executable file. In particular, it loads a text (code) segment and a data segment, allocating pages from the page pool for them, and creating mappings between virtual memory and physical memory for these pages. </FONT>
<LI><FONT style="BACKGROUND-COLOR: #7be1e1">It sets up the stack for the process (you will be doing this in Project 2) </FONT>
<LI><FONT style="BACKGROUND-COLOR: #7be1e1">It obtains the &#8220;entry point&#8221; from the ELF file (i.e., &#8220;where does the program start running?&#8221;)</FONT></LI></OL>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">At this point, we could just use the x86<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">JMP</FONT></SPAN></CODE><SPAN>&nbsp;</SPAN>instruction to jump directly to the entry point. However, we&#8217;re running in PL=0, and we want the process to run in PL=3. While, conceptually, all we need to do is something like &#8220;Switch to PL=3 and JMP&#8221;, the actual mechanism is more complicated than that, involving the x86 segmentation functionality.</FONT></P>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">In particular, the x86 architecture has six CPU registers known as<SPAN>&nbsp;</SPAN><EM>segment selectors</EM>:</FONT></P>
<UL class=simple>
<LI><FONT style="BACKGROUND-COLOR: #7be1e1"><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">cs</FONT></SPAN></CODE>: Code Segment </FONT>
<LI><FONT style="BACKGROUND-COLOR: #7be1e1"><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">ss</FONT></SPAN></CODE>: Stack Segment </FONT>
<LI><FONT style="BACKGROUND-COLOR: #7be1e1"><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">ds</FONT></SPAN></CODE>: Data Segment </FONT>
<LI><FONT style="BACKGROUND-COLOR: #7be1e1"><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">es</FONT></SPAN></CODE>,<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">fs</FONT></SPAN></CODE>,<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">gs</FONT></SPAN></CODE>: More data segments.</FONT></LI></UL>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">The value of<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">cs</FONT></SPAN></CODE>,<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">ss</FONT></SPAN></CODE>,<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">ds</FONT></SPAN></CODE>, etc. is a<SPAN>&nbsp;</SPAN><EM>selector</EM>: an index into a table of segment descriptors, where a descriptor contains information about a single segment (including, for example, the base and limit of that segment). In x86 there are two tables: the<SPAN>&nbsp;</SPAN></FONT><A class="reference external" href="http://wiki.osdev.org/Global_Descriptor_Table"><FONT style="BACKGROUND-COLOR: #7be1e1" color=#0066cc>Global Descriptor Table</FONT></A><FONT style="BACKGROUND-COLOR: #7be1e1"><SPAN>&nbsp;</SPAN>(shared by all processes) and the Local Descriptor Table (one per process), and a selector can point to an entry in either table.</FONT></P>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">However, modern x86 operating systems don&#8217;t create distinct segments per process. Instead, they create<SPAN>&nbsp;</SPAN><EM>global segment descriptors</EM><SPAN>&nbsp;</SPAN>(in the GDT) which define segments as big as the entire virtual memory space. So, they do not use segmentation (in the sense of creating clearly delimited code, data and stack segments per process), but they do use the x86 segmentation functionality because it will be required for switching between Privilege Levels. In particular, the x86 GDT/LDT includes a field that specifies the Privilege Level at which we are running when using a given segment. So, if<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">cs</FONT></SPAN></CODE><SPAN>&nbsp;</SPAN>contains a selector for a segment with PL=0, we will be able to run instructions that require PL=0.</FONT></P>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">So, a modern x86 operating system will often have a GDT with two code segments (one for PL=0 and another for PL=3), and two data segments (one for PL=0 and another for PL=3). The data segments are also used for the stack segment. In Pintos, the GDT looks like this:</FONT></P>
<TABLE class=table border=0>
<COLGROUP><FONT style="BACKGROUND-COLOR: #7be1e1">
<COL width="14%">
<COL width="27%">
<COL width="10%">
<COL width="24%">
<COL width="24%"></FONT></COLGROUP>
<TBODY vAlign=top>
<TR class=row-odd>
<TD><FONT style="BACKGROUND-COLOR: #7be1e1">Index</FONT></TD>
<TD><FONT style="BACKGROUND-COLOR: #7be1e1">Description</FONT></TD>
<TD><FONT style="BACKGROUND-COLOR: #7be1e1">PL</FONT></TD>
<TD><FONT style="BACKGROUND-COLOR: #7be1e1">Base</FONT></TD>
<TD><FONT style="BACKGROUND-COLOR: #7be1e1">Limit</FONT></TD></TR>
<TR class=row-even>
<TD><FONT style="BACKGROUND-COLOR: #7be1e1">0</FONT></TD>
<TD colSpan=4><FONT style="BACKGROUND-COLOR: #7be1e1">Empty</FONT></TD></TR>
<TR class=row-odd>
<TD><FONT style="BACKGROUND-COLOR: #7be1e1">1</FONT></TD>
<TD><FONT style="BACKGROUND-COLOR: #7be1e1">Kernel Code</FONT></TD>
<TD><FONT style="BACKGROUND-COLOR: #7be1e1">0</FONT></TD>
<TD><FONT style="BACKGROUND-COLOR: #7be1e1">0x00000000</FONT></TD>
<TD><FONT style="BACKGROUND-COLOR: #7be1e1">0xFFFFFFFF</FONT></TD></TR>
<TR class=row-even>
<TD><FONT style="BACKGROUND-COLOR: #7be1e1">2</FONT></TD>
<TD><FONT style="BACKGROUND-COLOR: #7be1e1">Kernel Data</FONT></TD>
<TD><FONT style="BACKGROUND-COLOR: #7be1e1">0</FONT></TD>
<TD><FONT style="BACKGROUND-COLOR: #7be1e1">0x00000000</FONT></TD>
<TD><FONT style="BACKGROUND-COLOR: #7be1e1">0xFFFFFFFF</FONT></TD></TR>
<TR class=row-odd>
<TD><FONT style="BACKGROUND-COLOR: #7be1e1">3</FONT></TD>
<TD><FONT style="BACKGROUND-COLOR: #7be1e1">User Code</FONT></TD>
<TD><FONT style="BACKGROUND-COLOR: #7be1e1">3</FONT></TD>
<TD><FONT style="BACKGROUND-COLOR: #7be1e1">0x00000000</FONT></TD>
<TD><FONT style="BACKGROUND-COLOR: #7be1e1">0xFFFFFFFF</FONT></TD></TR>
<TR class=row-even>
<TD><FONT style="BACKGROUND-COLOR: #7be1e1">4</FONT></TD>
<TD><FONT style="BACKGROUND-COLOR: #7be1e1">User Data</FONT></TD>
<TD><FONT style="BACKGROUND-COLOR: #7be1e1">3</FONT></TD>
<TD><FONT style="BACKGROUND-COLOR: #7be1e1">0x00000000</FONT></TD>
<TD><FONT style="BACKGROUND-COLOR: #7be1e1">0xFFFFFFFF</FONT></TD></TR>
<TR class=row-odd>
<TD><FONT style="BACKGROUND-COLOR: #7be1e1">5</FONT></TD>
<TD><FONT style="BACKGROUND-COLOR: #7be1e1">TSS</FONT></TD>
<TD colSpan=3><FONT style="BACKGROUND-COLOR: #7be1e1">Pointer to Task State Segment</FONT></TD></TR></TBODY></TABLE>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">Note: selectors are actually addresses in memory, not 0, 1, 2, 3, etc. but we will use indexes for simplicity. You can ignore the TSS entry for now.</FONT></P>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">When the computer boots, Pintos sets up the GDT just with entries 0, 1, 2 and runs in PL=0. Later on, we set up the complete GDT (</FONT><A class="reference external" href="https://github.com/uchicago-cs/pintos/blob/master/src/userprog/gdt.c#L33-L54"><FONT style="BACKGROUND-COLOR: #7be1e1" color=#0066cc>source code</FONT></A><FONT style="BACKGROUND-COLOR: #7be1e1">).</FONT></P>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">So, earlier we said that we could think of the &#8220;current PL&#8221; as being stored in a CPU register, and that was partially true. In fact,<SPAN>&nbsp;</SPAN><STRONG>our Privilege Level is determined by the current segment selectors</STRONG>. For example, if<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">cs</FONT></SPAN></CODE><SPAN>&nbsp;</SPAN>is set to 1, it means I can run privileged instructions. Similarly, if<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">ds</FONT></SPAN></CODE><SPAN>&nbsp;</SPAN>is set to 4, I wouldn&#8217;t be able to access pages that require PL=0.</FONT></P>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">So, back to the program loader (which is part of the kernel and, thus, would be running with code segment 1 and data segment 2). We&#8217;ve set everything up, and now we need to jump to the program&#8217;s entry point, while also switching<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">cs</FONT></SPAN></CODE><SPAN>&nbsp;</SPAN>to segment 3 and all other selectors to segment 4. This is done by<SPAN>&nbsp;</SPAN><EM>simulating</EM><SPAN>&nbsp;</SPAN>a return from interrupt (</FONT><A class="reference external" href="https://github.com/uchicago-cs/pintos/blob/master/src/userprog/process.c#L69-L75"><FONT style="BACKGROUND-COLOR: #7be1e1" color=#0066cc>source code</FONT></A><FONT style="BACKGROUND-COLOR: #7be1e1">). Remember that, as we saw earlier, an interrupt causes the CPU to automatically push the following registers into the stack:</FONT></P>
<UL class=simple>
<LI><FONT style="BACKGROUND-COLOR: #7be1e1"><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">ss</FONT></SPAN></CODE>: Stack Segment Selector </FONT>
<LI><FONT style="BACKGROUND-COLOR: #7be1e1"><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">esp</FONT></SPAN></CODE>: Stack pointer </FONT>
<LI><FONT style="BACKGROUND-COLOR: #7be1e1"><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">eflags</FONT></SPAN></CODE>: CPU flags </FONT>
<LI><FONT style="BACKGROUND-COLOR: #7be1e1"><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">cs</FONT></SPAN></CODE>: Code Segment Selector </FONT>
<LI><FONT style="BACKGROUND-COLOR: #7be1e1"><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">eip</FONT></SPAN></CODE>: Instruction Pointer</FONT></LI></UL>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">Which are then restored when we run the x86 instruction<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">IRET</FONT></SPAN></CODE>. So, to perform the operation &#8220;jump and change the Privilege Level&#8221;, all we need to do is create an interrupt stack frame with the entry point of the program in<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><FONT face="Courier New"><SPAN class=pre>eip```and</SPAN><SPAN>&nbsp;</SPAN><SPAN class=pre>the</SPAN><SPAN>&nbsp;</SPAN><SPAN class=pre>PL=3</SPAN><SPAN>&nbsp;</SPAN><SPAN class=pre>segments</SPAN><SPAN>&nbsp;</SPAN><SPAN class=pre>in</SPAN><SPAN>&nbsp;</SPAN><SPAN class=pre>``ss</SPAN></FONT></CODE><SPAN>&nbsp;</SPAN>and<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">cs</FONT></SPAN></CODE>. In Pintos, the interrupt frame we create (before calling<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">IRET</FONT></SPAN></CODE>) contains the above registers, as well the OS-added ones that we referred to earlier when explaining interrupts. This includes the value of<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">ds</FONT></SPAN></CODE>, which will be<SPAN>&nbsp;</SPAN></FONT><A class="reference external" href="https://github.com/uchicago-cs/pintos/blob/master/src/threads/intr-stubs.S#L57"><FONT style="BACKGROUND-COLOR: #7be1e1" color=#0066cc>restored</FONT></A><FONT style="BACKGROUND-COLOR: #7be1e1"><SPAN>&nbsp;</SPAN>in<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">intr_exit</FONT></SPAN></CODE>.</FONT></P>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">However, this mechanism won&#8217;t work if we want to switch from PL=3 to PL=0 (e.g., when an interrupt or a system call happens). This is because<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">IRET</FONT></SPAN></CODE><SPAN>&nbsp;</SPAN>will not allow returning from one privilege level to a more privileged level (it must always involve returning to a privilege level equal or less privileged than the current one). This makes sense: otherwise, a user process could grant itself PL=0 privileges by running IRET in the manner described above.</FONT></P>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">Instead, when an interrupt or system call happens, the interrupt descriptor table specifies the code segment to use when processing the interrupt (and it is usually set to be the kernel segment). The interrupt entry point then<SPAN>&nbsp;</SPAN></FONT><A class="reference external" href="https://github.com/uchicago-cs/pintos/blob/master/src/threads/intr-stubs.S#L29-L31"><FONT style="BACKGROUND-COLOR: #7be1e1" color=#0066cc>sets the data segment selectors</FONT></A><FONT style="BACKGROUND-COLOR: #7be1e1"><SPAN>&nbsp;</SPAN>to the kernel ones.</FONT></P>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">However, we also need to switch to the stack for the kernel thread associated with this process. In x86, we use a<SPAN>&nbsp;</SPAN></FONT><A class="reference external" href="http://wiki.osdev.org/Task_State_Segment"><FONT style="BACKGROUND-COLOR: #7be1e1" color=#0066cc>Task State Segment</FONT></A><FONT style="BACKGROUND-COLOR: #7be1e1">. This was a data structure that was originally designed to keep track of each task in the operating system, meaning there would be one TSS per task. The TSS stores many values, including the new value of<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">esp</FONT></SPAN></CODE><SPAN>&nbsp;</SPAN>when a user process yields control to the kernel. This is something we need to keep track of because, when running in the kernel, we want to use the kernel thread&#8217;s stack, not the user process&#8217;s stack.</FONT></P>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">However, modern x86 operating systems do not use one TSS per process and, instead create only one TSS (since we only need to store the stack pointer of the kernel thread corresponding to the current user process). When an interrupt happens, the CPU checks the TSS and sets<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">esp</FONT></SPAN></CODE><SPAN>&nbsp;</SPAN>to the stack pointer stored in the TSS.</FONT></P></DIV>
<DIV id=switching-between-processes class=section>
<H2><FONT style="BACKGROUND-COLOR: #7be1e1">Switching between processes</FONT><A title="Permalink to this headline" class=headerlink href="https://uchicago-cs.github.io/mpcs52030/switch.html#switching-between-processes"></A></H2>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">Now that we&#8217;ve seen all of the above, it turns out that process switching is simply a combination of thread switching and and switching between kernelspace and userspace. Basically, when a process is running, a timer interrupt will yield control of the CPU back to the kernel, which will result in the interrupt handling procedure we described earlier (eventually resulting in a call to<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">thread_tick</FONT></SPAN></CODE>). At that point, if we preempt the current thread (and its associated process), we switch to a different kernel thread as described earlier and, if this kernel thread is associated with a process, we switch back to userspace.</FONT></P>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">The main difference is that switching to a new process will also involve calling<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">process_activate</FONT></SPAN></CODE><SPAN>&nbsp;</SPAN>from<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">thread_schedule_tail</FONT></SPAN></CODE><SPAN>&nbsp;</SPAN>(a function that is run<SPAN>&nbsp;</SPAN><EM>after</EM><SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">switch_threads</FONT></SPAN></CODE>, but before returning from the interrupt handler).<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">process_activate</FONT></SPAN></CODE><SPAN>&nbsp;</SPAN>(</FONT><A class="reference external" href="https://github.com/uchicago-cs/pintos/blob/master/src/userprog/process.c#L119-L133"><FONT style="BACKGROUND-COLOR: #7be1e1" color=#0066cc>source code</FONT></A><FONT style="BACKGROUND-COLOR: #7be1e1">) updates the CPU&#8217;s<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">cr3</FONT></SPAN></CODE><SPAN>&nbsp;</SPAN>register to<SPAN>&nbsp;</SPAN></FONT><A class="reference external" href="http://wiki.osdev.org/Setting_Up_Paging"><FONT style="BACKGROUND-COLOR: #7be1e1" color=#0066cc>point to the page directory</FONT></A><FONT style="BACKGROUND-COLOR: #7be1e1"><SPAN>&nbsp;</SPAN>for the process that is now running, and also saves the value of<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">esp</FONT></SPAN></CODE><SPAN>&nbsp;</SPAN>to the TSS (</FONT><A class="reference external" href="https://github.com/uchicago-cs/pintos/blob/master/src/userprog/tss.c#L101-L106"><FONT style="BACKGROUND-COLOR: #7be1e1" color=#0066cc>source code</FONT></A><FONT style="BACKGROUND-COLOR: #7be1e1">).</FONT></P></DIV><BR><BR><FONT style="BACKGROUND-COLOR: #7be1e1">