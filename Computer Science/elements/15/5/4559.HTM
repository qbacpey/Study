<STRONG><FONT color=blue>How does thread/process switching work in Pintos? : </FONT></STRONG>
<H2><SPAN class=headers>Title:</SPAN></B><SPAN class=RefText> How does thread/process switching work in Pintos? : What happens during an interrupt</SPAN></FONT></H2>
<P><CODE class="docutils literal"><SPAN class=pre><FONT size=2 face="Courier New">When an interrupt happens, the CPU automatically pushes the value of the following CPU registers onto the stack:</FONT></SPAN></CODE></P>
<UL class=simple>
<LI><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">ss</FONT></SPAN></CODE>: Stack Segment Selector 
<LI><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">esp</FONT></SPAN></CODE>: Stack pointer 
<LI><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">eflags</FONT></SPAN></CODE>: CPU flags 
<LI><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">cs</FONT></SPAN></CODE>: Code Segment Selector 
<LI><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">eip</FONT></SPAN></CODE>: Instruction Pointer (i.e., the Program Counter)</LI></UL>
<P>For now, we can ignore the segment selectors. However, notice how the CPU saves enough information to be able to resume the execution of the thread: it saved the address of the next instruction to run (in<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">eip</FONT></SPAN></CODE>) and a pointer to the top of the thread&#8217;s stack (so we can return to the exact chain of function calls when the interrupt happened).</P>
<P>Next, the CPU will inspect the<SPAN>&nbsp;</SPAN><A class="reference external" href="http://wiki.osdev.org/Interrupt_Descriptor_Table"><FONT color=#0066cc>Interrupt Descriptor Table</FONT></A><SPAN>&nbsp;</SPAN>(IDT) and look for the entry corresponding to the interrupt that just happened. This entry will contain a memory location containing the<SPAN>&nbsp;</SPAN><EM>interrupt handler</EM><SPAN>&nbsp;</SPAN>for that interrupt, and the CPU will jump to that location.</P>
<P>In Pintos, the IDT is actually set up to always jump to a function called<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">intr_entry</FONT></SPAN></CODE><SPAN>&nbsp;</SPAN>(<A class="reference external" href="https://github.com/uchicago-cs/pintos/blob/master/src/threads/intr-stubs.S#L5-L39"><FONT color=#0066cc>source code</FONT></A>) that is implemented in x86 assembly. This function pushes additional data into the stack (mostly CPU registers). The combination of the values pushed by the CPU and by<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">intr_entry</FONT></SPAN></CODE><SPAN>&nbsp;</SPAN>is called the<SPAN>&nbsp;</SPAN><EM>interrupt stack frame</EM>, which is used to save information about the interrupted thread (or process) and to provide the interrupt handler with the information it needs to handle the interrupt.</P>
<P><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">intr_entry</FONT></SPAN></CODE><SPAN>&nbsp;</SPAN>also sets up a call to a function called<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">intr_handler</FONT></SPAN></CODE><SPAN>&nbsp;</SPAN>that is implemented in C (<A class="reference external" href="https://github.com/uchicago-cs/pintos/blob/master/src/threads/interrupt.c#L345"><FONT color=#0066cc>source code</FONT></A>). This function has a single parameter: a pointer to a<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">intr_frame</FONT></SPAN></CODE><SPAN>&nbsp;</SPAN>struct (<A class="reference external" href="https://github.com/uchicago-cs/pintos/blob/master/src/threads/interrupt.h#L19-L56"><FONT color=#0066cc>source code</FONT></A>) that encapsulates all the values in the interrupt stack frame.</P>
<P><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">intr_handler</FONT></SPAN></CODE><SPAN>&nbsp;</SPAN>is the function that will determine what function to call based on the interrupt type. During Pintos&#8217;s initialization (in the<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">main</FONT></SPAN></CODE><SPAN>&nbsp;</SPAN>function) certain functions are associated with certain interrupts. For example, the<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">timer_init</FONT></SPAN></CODE><SPAN>&nbsp;</SPAN>function (<SPAN>&nbsp;</SPAN><A class="reference external" href="https://github.com/uchicago-cs/pintos/blob/master/src/devices/timer.c#L33-L40"><FONT color=#0066cc>source code</FONT></A>, called from<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">main</FONT></SPAN></CODE>) assigns the<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">timer_interrupt</FONT></SPAN></CODE><SPAN>&nbsp;</SPAN>function to handle interrupts from the timer.</P>
<P>If the interrupt we&#8217;re handling is a timer interrupt, then<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">intr_handler</FONT></SPAN></CODE><SPAN>&nbsp;</SPAN>would call<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">timer_interrupt</FONT></SPAN></CODE><SPAN>&nbsp;</SPAN>which, in turn, would call<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">thread_tick</FONT></SPAN></CODE>. At that point, the stack would look like this:</P><img alt=_images/stack2.png src="https://uchicago-cs.github.io/mpcs52030/_images/stack2.png"> 
<P>In the case where<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">thread_tick</FONT></SPAN></CODE><SPAN>&nbsp;</SPAN>does not preempt the running thread, it would return to<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">timer_interrupt</FONT></SPAN></CODE>, which will return to<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">intr_handler</FONT></SPAN></CODE>, which will return to the<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">intr_entry</FONT></SPAN></CODE><SPAN>&nbsp;</SPAN>function. The assembly code for this function &#8220;falls through&#8221; to<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">intr_exit</FONT></SPAN></CODE>, which restores the saved values in the stack (using the<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">popal</FONT></SPAN></CODE>,<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">popl</FONT></SPAN></CODE><SPAN>&nbsp;</SPAN>instructions) and discards the Pintos-saved information from the interrupt stack frame, leaving only the values that were automatically saved by the CPU. At this point, we run the assembly instruction<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">iret</FONT></SPAN></CODE>. This instruction will restore the values stored in the interrupt stack frame created by the CPU (<CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">ss</FONT></SPAN></CODE>,<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">esp</FONT></SPAN></CODE>,<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">eflags</FONT></SPAN></CODE>,<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">cs</FONT></SPAN></CODE>, and<SPAN>&nbsp;</SPAN><CODE class="docutils literal"><SPAN class=pre><FONT face="Courier New">eip</FONT></SPAN></CODE>), restoring the state of the CPU to the point where the interrupt happened (thus doing an &#8220;Interrupt RETurn&#8221;).</P>
<DIV></DIV>
<DIV id=what-happens-during-a-thread-switch class=section>