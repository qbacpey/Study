<H2 id=Processes,_kernel_threads,_user_threads,_and_fibers data-mw-section-id="2"><FONT style="BACKGROUND-COLOR: #7be1e1"><SPAN class=headers>Title:</SPAN></B><SPAN class=RefText> Processes, kernel threads, user threads, and fibers</SPAN></FONT></FONT></H2>
<P id=mwMQ><FONT style="BACKGROUND-COLOR: #7be1e1">Scheduling can be done at the kernel level or user level, and multitasking can be done preemptively or cooperatively. This yields a variety of related concepts.</FONT></P>
<H3 id=Processes data-mw-section-id="3"><FONT style="BACKGROUND-COLOR: #7be1e1">Processes</FONT></H3><FONT style="BACKGROUND-COLOR: #7be1e1"><SPAN id=mwMw class=ve-pasteProtect data-ve-attributes='{"typeof":"mw:Transclusion"}' data-ve-no-generated-contents="true" data-mw='{"parts":[{"template":{"target":{"wt":"Main","href":"./Template:Main"},"params":{"1":{"wt":"Process (computing)"}},"i":0}}]}' typeof="mw:Transclusion">&nbsp;</SPAN> </FONT>
<DIV role=note id=mwNA class="hatnote navigation-not-searchable" data-ve-attributes='{"about":"#mwt26"}' data-ve-ignore="true" about="#mwt26"><FONT style="BACKGROUND-COLOR: #7be1e1">Main article: </FONT><A title="Process (computing)" href="https://en.wikipedia.org/wiki/Process_(computing)" rel=mw:WikiLink data-ve-attributes='{"rel":"mw:WikiLink"}'><FONT style="BACKGROUND-COLOR: #7be1e1">Process (computing)</FONT></A></DIV>
<P id=mwNQ><FONT style="BACKGROUND-COLOR: #7be1e1">At the kernel level, a <I id=mwNg>process</I> contains one or more <I id=mwNw>kernel threads</I>, which share the process's resources, such as memory and file handles &#8211; a process is a unit of resources, while a thread is a unit of scheduling and execution. Kernel scheduling is typically uniformly done preemptively or, less commonly, cooperatively. At the user level a process such as a </FONT><A id=mwOA title="Runtime system" href="https://en.wikipedia.org/wiki/Runtime_system" rel=mw:WikiLink data-ve-attributes='{"rel":"mw:WikiLink"}'><FONT style="BACKGROUND-COLOR: #7be1e1">runtime system</FONT></A><FONT style="BACKGROUND-COLOR: #7be1e1"> can itself schedule multiple threads of execution. If these do not share data, as in Erlang, they are usually analogously called processes,<SUP class="mw-ref reference" data-ve-attributes='{"typeof":"mw:Extension/ref"}' data-mw='{"name":"ref","body":{"html":"<span typeof=\"mw:Transclusion\" data-mw=\"{&amp;quot;parts&amp;quot;:[{&amp;quot;template&amp;quot;:{&amp;quot;target&amp;quot;:{&amp;quot;wt&amp;quot;:&amp;quot;cite web\\n&amp;quot;,&amp;quot;href&amp;quot;:&amp;quot;./Template:Cite_web&amp;quot;},&amp;quot;params&amp;quot;:{&amp;quot;title&amp;quot;:{&amp;quot;wt&amp;quot;:&amp;quot;Erlang: 3.1 Processes&amp;quot;},&amp;quot;url&amp;quot;:{&amp;quot;wt&amp;quot;:&amp;quot;http://www.erlang.org/doc/getting_started/conc_prog.html&amp;quot;}},&amp;quot;i&amp;quot;:0}}]}\" data-ve-no-generated-contents=\"true\" id=\"mwAZI\">&amp;nbsp;</span><cite class=\"citation web cs1\" about=\"#mwt31\" id=\"mwAZM\" data-ve-ignore=\"true\"><a rel=\"mw:ExtLink\" href=\"http://www.erlang.org/doc/getting_started/conc_prog.html\" class=\"external text\" id=\"mwAZQ\">\"Erlang: 3.1 Processes\"</a>.</cite><span title=\"ctx_ver=Z39.88-2004&amp;amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;amp;rft.genre=unknown&amp;amp;rft.btitle=Erlang%3A+3.1+Processes&amp;amp;rft_id=http%3A%2F%2Fwww.erlang.org%2Fdoc%2Fgetting_started%2Fconc_prog.html&amp;amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AThread+%28computing%29\" class=\"Z3988\" about=\"#mwt31\" id=\"mwAZU\" data-ve-ignore=\"true\"></span>"}}' typeof="mw:Extension/ref"><A data-ve-attributes='{"style":"counter-reset: mw-Ref 1;"}'><SPAN class="mw-reflink-text ve-pasteProtect">[1]</SPAN></A></SUP> while if they share data they are usually called <I id=mwOw>(user) threads</I>, particularly if preemptively scheduled. Cooperatively scheduled user threads are known as <I id=mwPA><A id=mwPQ title="Fiber (computer science)" href="https://en.wikipedia.org/wiki/Fiber_(computer_science)" rel=mw:WikiLink data-ve-attributes='{"rel":"mw:WikiLink"}'>fibers</A></I>; different processes may schedule user threads differently. User threads may be executed by kernel threads in various ways (one-to-one, many-to-one, many-to-many). The term "</FONT><A id=mwPg title="Light-weight process" href="https://en.wikipedia.org/wiki/Light-weight_process" rel=mw:WikiLink data-ve-attributes='{"rel":"mw:WikiLink"}'><FONT style="BACKGROUND-COLOR: #7be1e1">light-weight process</FONT></A><FONT style="BACKGROUND-COLOR: #7be1e1">" variously refers to user threads or to kernel mechanisms for scheduling user threads onto kernel threads.</FONT></P>
<P id=mwPw><FONT style="BACKGROUND-COLOR: #7be1e1">A <I id=mwQA>process</I> is a "heavyweight" unit of kernel scheduling, as creating, destroying, and switching processes is relatively expensive. Processes own </FONT><A id=mwQQ title="Resource (computer science)" class=mw-redirect href="https://en.wikipedia.org/wiki/Resource_(computer_science)" rel=mw:WikiLink data-ve-attributes='{"rel":"mw:WikiLink"}'><FONT style="BACKGROUND-COLOR: #7be1e1">resources</FONT></A><FONT style="BACKGROUND-COLOR: #7be1e1"> allocated by the operating system. Resources include memory (for both code and data), </FONT><A id=mwQg title="Handle (computing)" href="https://en.wikipedia.org/wiki/Handle_(computing)" rel=mw:WikiLink data-ve-attributes='{"rel":"mw:WikiLink"}'><FONT style="BACKGROUND-COLOR: #7be1e1">file handles</FONT></A><FONT style="BACKGROUND-COLOR: #7be1e1">, sockets, device handles, windows, and a </FONT><A id=mwQw title="Process control block" href="https://en.wikipedia.org/wiki/Process_control_block" rel=mw:WikiLink data-ve-attributes='{"rel":"mw:WikiLink"}'><FONT style="BACKGROUND-COLOR: #7be1e1">process control block</FONT></A><FONT style="BACKGROUND-COLOR: #7be1e1">. Processes are <I id=mwRA>isolated</I> by </FONT><A id=mwRQ title="Process isolation" href="https://en.wikipedia.org/wiki/Process_isolation" rel=mw:WikiLink data-ve-attributes='{"rel":"mw:WikiLink"}'><FONT style="BACKGROUND-COLOR: #7be1e1">process isolation</FONT></A><FONT style="BACKGROUND-COLOR: #7be1e1">, and do not share address spaces or file resources except through explicit methods such as inheriting file handles or shared memory segments, or mapping the same file in a shared way &#8211; see </FONT><A id=mwRg title="Interprocess communication" class=mw-redirect href="https://en.wikipedia.org/wiki/Interprocess_communication" rel=mw:WikiLink data-ve-attributes='{"rel":"mw:WikiLink"}'><FONT style="BACKGROUND-COLOR: #7be1e1">interprocess communication</FONT></A><FONT style="BACKGROUND-COLOR: #7be1e1">. Creating or destroying a process is relatively expensive, as resources must be acquired or released. Processes are typically preemptively multitasked, and process switching is relatively expensive, beyond basic cost of </FONT><A id=mwRw title="Context switching" class=mw-redirect href="https://en.wikipedia.org/wiki/Context_switching" rel=mw:WikiLink data-ve-attributes='{"rel":"mw:WikiLink"}'><FONT style="BACKGROUND-COLOR: #7be1e1">context switching</FONT></A><FONT style="BACKGROUND-COLOR: #7be1e1">, due to issues such as cache flushing (in particular, process switching changes virtual memory addressing, causing invalidation and thus flushing of an untagged </FONT><A id=mwSA title="Translation lookaside buffer" href="https://en.wikipedia.org/wiki/Translation_lookaside_buffer" rel=mw:WikiLink data-ve-attributes='{"rel":"mw:WikiLink"}'><FONT style="BACKGROUND-COLOR: #7be1e1">translation lookaside buffer</FONT></A><FONT style="BACKGROUND-COLOR: #7be1e1">, notably on x86).</FONT></P>
<H3 id=Kernel_threads data-mw-section-id="4"><FONT style="BACKGROUND-COLOR: #7be1e1">Kernel threads</FONT></H3>
<P id=mwSg><FONT style="BACKGROUND-COLOR: #7be1e1"><SPAN id=kernel_thread class="anchor ve-pasteProtect" data-ve-attributes='{"typeof":"mw:Transclusion","about":"#mwt36"}' data-ve-no-generated-contents="true" data-mw='{"parts":[{"template":{"target":{"wt":"anchor","href":"./Template:Anchor"},"params":{"1":{"wt":"kernel thread"}},"i":0}}]}' typeof="mw:Transclusion" about="#mwt36">&nbsp;</SPAN> A <I id=mwSw>kernel thread</I> is a "lightweight" unit of kernel scheduling. At least one kernel thread exists within each process. If multiple kernel threads exist within a process, then they share the same memory and file resources. Kernel threads are preemptively multitasked if the operating system's process </FONT><A id=mwTA title="Scheduling (computing)" href="https://en.wikipedia.org/wiki/Scheduling_(computing)" rel=mw:WikiLink data-ve-attributes='{"rel":"mw:WikiLink"}'><FONT style="BACKGROUND-COLOR: #7be1e1">scheduler</FONT></A><FONT style="BACKGROUND-COLOR: #7be1e1"> is preemptive. Kernel threads do not own resources except for a </FONT><A id=mwTQ title="Call stack" href="https://en.wikipedia.org/wiki/Call_stack" rel=mw:WikiLink data-ve-attributes='{"rel":"mw:WikiLink"}'><FONT style="BACKGROUND-COLOR: #7be1e1">stack</FONT></A><FONT style="BACKGROUND-COLOR: #7be1e1">, a copy of the </FONT><A id=mwTg title="Processor register" href="https://en.wikipedia.org/wiki/Processor_register" rel=mw:WikiLink data-ve-attributes='{"rel":"mw:WikiLink"}'><FONT style="BACKGROUND-COLOR: #7be1e1">registers</FONT></A><FONT style="BACKGROUND-COLOR: #7be1e1"> including the </FONT><A id=mwTw title="Program counter" href="https://en.wikipedia.org/wiki/Program_counter" rel=mw:WikiLink data-ve-attributes='{"rel":"mw:WikiLink"}'><FONT style="BACKGROUND-COLOR: #7be1e1">program counter</FONT></A><FONT style="BACKGROUND-COLOR: #7be1e1">, and </FONT><A id=mwUA title="Thread-local storage" href="https://en.wikipedia.org/wiki/Thread-local_storage" rel=mw:WikiLink data-ve-attributes='{"rel":"mw:WikiLink"}'><FONT style="BACKGROUND-COLOR: #7be1e1">thread-local storage</FONT></A><FONT style="BACKGROUND-COLOR: #7be1e1"> (if any), and are thus relatively cheap to create and destroy. Thread switching is also relatively cheap: it requires a context switch (saving and restoring registers and stack pointer), but does not change virtual memory and is thus cache-friendly (leaving TLB valid). The kernel can assign one thread to each logical core in a system (because each processor splits itself up into multiple logical cores if it supports multithreading, or only supports one logical core per physical core if it does not), and can swap out threads that get blocked. However, kernel threads take much longer than user threads to be swapped.</FONT></P>
<H3 id=User_threads data-mw-section-id="5"><FONT style="BACKGROUND-COLOR: #7be1e1">User threads</FONT></H3>
<P id=mwUg><FONT style="BACKGROUND-COLOR: #7be1e1"><SPAN id=user_thread class="anchor ve-pasteProtect" data-ve-attributes='{"typeof":"mw:Transclusion","about":"#mwt37"}' data-ve-no-generated-contents="true" data-mw='{"parts":[{"template":{"target":{"wt":"anchor","href":"./Template:Anchor"},"params":{"1":{"wt":"user thread"}},"i":0}}]}' typeof="mw:Transclusion" about="#mwt37">&nbsp;</SPAN> Threads are sometimes implemented in </FONT><A id=mwUw title="User space" class=mw-redirect href="https://en.wikipedia.org/wiki/User_space" rel=mw:WikiLink data-ve-attributes='{"rel":"mw:WikiLink"}'><FONT style="BACKGROUND-COLOR: #7be1e1">userspace</FONT></A><FONT style="BACKGROUND-COLOR: #7be1e1"> libraries, thus called <I id=mwVA>user threads</I>. The kernel is unaware of them, so they are managed and scheduled in </FONT><A id=mwVQ title="User space" class=mw-redirect href="https://en.wikipedia.org/wiki/User_space" rel=mw:WikiLink data-ve-attributes='{"rel":"mw:WikiLink"}'><FONT style="BACKGROUND-COLOR: #7be1e1">userspace</FONT></A><FONT style="BACKGROUND-COLOR: #7be1e1">. Some implementations base their user threads on top of several kernel threads, to benefit from </FONT><A id=mwVg title=Multiprocessing href="https://en.wikipedia.org/wiki/Multiprocessing" rel=mw:WikiLink data-ve-attributes='{"rel":"mw:WikiLink"}'><FONT style="BACKGROUND-COLOR: #7be1e1">multi-processor</FONT></A><FONT style="BACKGROUND-COLOR: #7be1e1"> machines (</FONT><A id=mwVw title="Thread (computing)" href="https://en.wikipedia.org/wiki/Thread_(computing)#Threading_models" rel=mw:WikiLink data-ve-attributes='{"rel":"mw:WikiLink"}'><FONT style="BACKGROUND-COLOR: #7be1e1">M:N model</FONT></A><FONT style="BACKGROUND-COLOR: #7be1e1">). User threads as implemented by </FONT><A id=mwWA title="Virtual machine" href="https://en.wikipedia.org/wiki/Virtual_machine" rel=mw:WikiLink data-ve-attributes='{"rel":"mw:WikiLink"}'><FONT style="BACKGROUND-COLOR: #7be1e1">virtual machines</FONT></A><FONT style="BACKGROUND-COLOR: #7be1e1"> are also called </FONT><A id=mwWQ title="Green threads" href="https://en.wikipedia.org/wiki/Green_threads" rel=mw:WikiLink data-ve-attributes='{"rel":"mw:WikiLink"}'><FONT style="BACKGROUND-COLOR: #7be1e1">green threads</FONT></A><FONT style="BACKGROUND-COLOR: #7be1e1">.</FONT></P>
<P id=mwWg><FONT style="BACKGROUND-COLOR: #7be1e1">As user thread implementations are typically entirely in </FONT><A id=mwWw title=Userspace class=mw-redirect href="https://en.wikipedia.org/wiki/Userspace" rel=mw:WikiLink data-ve-attributes='{"rel":"mw:WikiLink"}'><FONT style="BACKGROUND-COLOR: #7be1e1">userspace</FONT></A><FONT style="BACKGROUND-COLOR: #7be1e1">, context switching between user threads within the same process is extremely efficient because it does not require any interaction with the kernel at all: a context switch can be performed by locally saving the CPU registers used by the currently executing user thread or fiber and then loading the registers required by the user thread or fiber to be executed. Since scheduling occurs in userspace, the scheduling policy can be more easily tailored to the requirements of the program's workload.</FONT></P>
<P id=mwXA><FONT style="BACKGROUND-COLOR: #7be1e1">However, the use of blocking system calls in user threads (as opposed to kernel threads) can be problematic. If a user thread or a fiber performs a system call that blocks, the other user threads and fibers in the process are unable to run until the system call returns. A typical example of this problem is when performing I/O: most programs are written to perform I/O synchronously. When an I/O operation is initiated, a system call is made, and does not return until the I/O operation has been completed. In the intervening period, the entire process is "blocked" by the kernel and cannot run, which starves other user threads and fibers in the same process from executing.</FONT></P>
<P id=mwXQ><FONT style="BACKGROUND-COLOR: #7be1e1">A common solution to this problem (used, in particular, by many of green threads implementations) is providing an I/O API that implements an interface that blocks the calling thread, rather than the entire process, by using non-blocking I/O internally, and scheduling another user thread or fiber while the I/O operation is in progress. Similar solutions can be provided for other blocking system calls. Alternatively, the program can be written to avoid the use of synchronous I/O or other blocking system calls (in particular, using non-blocking I/O, including lambda continuations and/or async/</FONT><A id=mwXg title=Await class=mw-redirect href="https://en.wikipedia.org/wiki/Await" rel=mw:WikiLink data-ve-attributes='{"rel":"mw:WikiLink"}'><FONT style="BACKGROUND-COLOR: #7be1e1">await</FONT></A><FONT style="BACKGROUND-COLOR: #7be1e1"> primitives<SUP class="mw-ref reference" data-ve-attributes='{"typeof":"mw:Extension/ref"}' data-mw='{"name":"ref","body":{"html":"<span typeof=\"mw:Transclusion\" data-mw=\"{&amp;quot;parts&amp;quot;:[{&amp;quot;template&amp;quot;:{&amp;quot;target&amp;quot;:{&amp;quot;wt&amp;quot;:&amp;quot;cite web&amp;quot;,&amp;quot;href&amp;quot;:&amp;quot;./Template:Cite_web&amp;quot;},&amp;quot;params&amp;quot;:{&amp;quot;url&amp;quot;:{&amp;quot;wt&amp;quot;:&amp;quot;https://www.youtube.com/watch?v=6lXUrvlMXNU&amp;quot;},&amp;quot;archive-url&amp;quot;:{&amp;quot;wt&amp;quot;:&amp;quot;https://ghostarchive.org/varchive/youtube/20211104/6lXUrvlMXNU&amp;quot;},&amp;quot;archive-date&amp;quot;:{&amp;quot;wt&amp;quot;:&amp;quot;2021-11-04&amp;quot;},&amp;quot;url-status&amp;quot;:{&amp;quot;wt&amp;quot;:&amp;quot;live&amp;quot;},&amp;quot;title&amp;quot;:{&amp;quot;wt&amp;quot;:&amp;quot;Eight Ways to Handle Non-blocking Returns in Message-passing Programs: from C++98 via C++11 to C++20&amp;quot;},&amp;quot;author&amp;quot;:{&amp;quot;wt&amp;quot;:&amp;quot;Sergey Ignatchenko&amp;quot;},&amp;quot;publisher&amp;quot;:{&amp;quot;wt&amp;quot;:&amp;quot;CPPCON&amp;quot;}},&amp;quot;i&amp;quot;:0}}]}\" data-ve-no-generated-contents=\"true\" id=\"mwAZg\">&amp;nbsp;</span><cite id=\"CITEREFSergey_Ignatchenko\" class=\"citation web cs1\" about=\"#mwt39\" data-ve-ignore=\"true\">Sergey Ignatchenko. <a rel=\"mw:ExtLink\" href=\"https://www.youtube.com/watch?v=6lXUrvlMXNU\" class=\"external text\" id=\"mwAZk\">\"Eight Ways to Handle Non-blocking Returns in Message-passing Programs: from C++98 via C++11 to C++20\"</a>. CPPCON. <a rel=\"mw:ExtLink\" href=\"https://ghostarchive.org/varchive/youtube/20211104/6lXUrvlMXNU\" class=\"external text\" id=\"mwAZo\">Archived</a> from the original on 2021-11-04.</cite><span title=\"ctx_ver=Z39.88-2004&amp;amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;amp;rft.genre=unknown&amp;amp;rft.btitle=Eight+Ways+to+Handle+Non-blocking+Returns+in+Message-passing+Programs%3A+from+C%2B%2B98+via+C%2B%2B11+to+C%2B%2B20&amp;amp;rft.pub=CPPCON&amp;amp;rft.au=Sergey+Ignatchenko&amp;amp;rft_id=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3D6lXUrvlMXNU&amp;amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AThread+%28computing%29\" class=\"Z3988\" about=\"#mwt39\" id=\"mwAZs\" data-ve-ignore=\"true\"></span><span about=\"#mwt43\" typeof=\"mw:Transclusion\" data-mw=\"{&amp;quot;parts&amp;quot;:[{&amp;quot;template&amp;quot;:{&amp;quot;target&amp;quot;:{&amp;quot;wt&amp;quot;:&amp;quot;cbignore&amp;quot;,&amp;quot;href&amp;quot;:&amp;quot;./Template:Cbignore&amp;quot;},&amp;quot;params&amp;quot;:{},&amp;quot;i&amp;quot;:0}}]}\" id=\"mwAZw\" data-ve-no-generated-contents=\"true\">&amp;nbsp;</span>"}}' typeof="mw:Extension/ref"><A data-ve-attributes='{"style":"counter-reset: mw-Ref 2;"}'><SPAN class="mw-reflink-text ve-pasteProtect">[2]</SPAN></A></SUP>).</FONT></P>
<H3 id=Fibers data-mw-section-id="6"><FONT style="BACKGROUND-COLOR: #7be1e1">Fibers</FONT></H3><FONT style="BACKGROUND-COLOR: #7be1e1"><SPAN id=mwYg class=ve-pasteProtect data-ve-attributes='{"typeof":"mw:Transclusion"}' data-ve-no-generated-contents="true" data-mw='{"parts":[{"template":{"target":{"wt":"Main","href":"./Template:Main"},"params":{"1":{"wt":"Fiber (computer science)"}},"i":0}}]}' typeof="mw:Transclusion">&nbsp;</SPAN> </FONT>
<DIV role=note id=mwYw class="hatnote navigation-not-searchable" data-ve-attributes='{"about":"#mwt45"}' data-ve-ignore="true" about="#mwt45"><FONT style="BACKGROUND-COLOR: #7be1e1">Main article: </FONT><A title="Fiber (computer science)" href="https://en.wikipedia.org/wiki/Fiber_(computer_science)" rel=mw:WikiLink data-ve-attributes='{"rel":"mw:WikiLink"}'><FONT style="BACKGROUND-COLOR: #7be1e1">Fiber (computer science)</FONT></A></DIV>
<P id=mwZA><A id=mwZQ title="Fiber (computer science)" href="https://en.wikipedia.org/wiki/Fiber_(computer_science)" rel=mw:WikiLink data-ve-attributes='{"rel":"mw:WikiLink"}'><FONT style="BACKGROUND-COLOR: #7be1e1">Fibers</FONT></A><FONT style="BACKGROUND-COLOR: #7be1e1"> are an even lighter unit of scheduling which are </FONT><A id=mwZg title="Cooperative multitasking" href="https://en.wikipedia.org/wiki/Cooperative_multitasking" rel=mw:WikiLink data-ve-attributes='{"rel":"mw:WikiLink"}'><FONT style="BACKGROUND-COLOR: #7be1e1">cooperatively scheduled</FONT></A><FONT style="BACKGROUND-COLOR: #7be1e1">: a running fiber must explicitly "</FONT><A id=mwZw title="Yield (multithreading)" href="https://en.wikipedia.org/wiki/Yield_(multithreading)" rel=mw:WikiLink data-ve-attributes='{"rel":"mw:WikiLink"}'><FONT style="BACKGROUND-COLOR: #7be1e1">yield</FONT></A><FONT style="BACKGROUND-COLOR: #7be1e1">" to allow another fiber to run, which makes their implementation much easier than kernel or </FONT><A id=mwaA title="User threads" class=new href="https://en.wikipedia.org/wiki/User_threads" rel=mw:WikiLink data-ve-attributes='{"rel":"mw:WikiLink"}'><FONT style="BACKGROUND-COLOR: #7be1e1">user threads</FONT></A><FONT style="BACKGROUND-COLOR: #7be1e1">. A fiber can be scheduled to run in any thread in the same process. This permits applications to gain performance improvements by managing scheduling themselves, instead of relying on the kernel scheduler (which may not be tuned for the application). Parallel programming environments such as </FONT><A id=mwaQ title=OpenMP href="https://en.wikipedia.org/wiki/OpenMP" rel=mw:WikiLink data-ve-attributes='{"rel":"mw:WikiLink"}'><FONT style="BACKGROUND-COLOR: #7be1e1">OpenMP</FONT></A><FONT style="BACKGROUND-COLOR: #7be1e1"> typically implement their tasks through fibers. Closely related to fibers are </FONT><A id=mwag title=Coroutine href="https://en.wikipedia.org/wiki/Coroutine" rel=mw:WikiLink data-ve-attributes='{"rel":"mw:WikiLink"}'><FONT style="BACKGROUND-COLOR: #7be1e1">coroutines</FONT></A><FONT style="BACKGROUND-COLOR: #7be1e1">, with the distinction being that coroutines are a language-level construct, while fibers are a system-level construct.</FONT></P>
<H3 id=Threads_vs_processes data-mw-section-id="7"><FONT style="BACKGROUND-COLOR: #7be1e1">Threads vs processes</FONT></H3>
<P id=mwbA><FONT style="BACKGROUND-COLOR: #7be1e1">Threads differ from traditional </FONT><A id=mwbQ title="Computer multitasking" href="https://en.wikipedia.org/wiki/Computer_multitasking" rel=mw:WikiLink data-ve-attributes='{"rel":"mw:WikiLink"}'><FONT style="BACKGROUND-COLOR: #7be1e1">multitasking</FONT></A><FONT style="BACKGROUND-COLOR: #7be1e1"> operating-system </FONT><A id=mwbg title="Process (computing)" href="https://en.wikipedia.org/wiki/Process_(computing)" rel=mw:WikiLink data-ve-attributes='{"rel":"mw:WikiLink"}'><FONT style="BACKGROUND-COLOR: #7be1e1">processes</FONT></A><FONT style="BACKGROUND-COLOR: #7be1e1"> in several ways:</FONT></P>
<UL id=mwbw>
<LI id=mwcA><FONT style="BACKGROUND-COLOR: #7be1e1">processes are typically independent, while threads exist as subsets of a process </FONT>
<LI id=mwcQ><FONT style="BACKGROUND-COLOR: #7be1e1">processes carry considerably more </FONT><A id=mwcg title="State (computer science)" href="https://en.wikipedia.org/wiki/State_(computer_science)" rel=mw:WikiLink data-ve-attributes='{"rel":"mw:WikiLink"}'><FONT style="BACKGROUND-COLOR: #7be1e1">state</FONT></A><FONT style="BACKGROUND-COLOR: #7be1e1"> information than threads, whereas multiple threads within a process share process state as well as </FONT><A id=mwcw title="Computer storage" class=mw-redirect href="https://en.wikipedia.org/wiki/Computer_storage" rel=mw:WikiLink data-ve-attributes='{"rel":"mw:WikiLink"}'><FONT style="BACKGROUND-COLOR: #7be1e1">memory</FONT></A><FONT style="BACKGROUND-COLOR: #7be1e1"> and other </FONT><A id=mwdA title="Resource (computer science)" class=mw-redirect href="https://en.wikipedia.org/wiki/Resource_(computer_science)" rel=mw:WikiLink data-ve-attributes='{"rel":"mw:WikiLink"}'><FONT style="BACKGROUND-COLOR: #7be1e1">resources</FONT></A><FONT style="BACKGROUND-COLOR: #7be1e1"> </FONT>
<LI id=mwdQ><FONT style="BACKGROUND-COLOR: #7be1e1">processes have separate </FONT><A id=mwdg title="Address space" href="https://en.wikipedia.org/wiki/Address_space" rel=mw:WikiLink data-ve-attributes='{"rel":"mw:WikiLink"}'><FONT style="BACKGROUND-COLOR: #7be1e1">address spaces</FONT></A><FONT style="BACKGROUND-COLOR: #7be1e1">, whereas threads share their address space </FONT>
<LI id=mwdw><FONT style="BACKGROUND-COLOR: #7be1e1">processes interact only through system-provided </FONT><A id=mweA title="Inter-process communication" href="https://en.wikipedia.org/wiki/Inter-process_communication" rel=mw:WikiLink data-ve-attributes='{"rel":"mw:WikiLink"}'><FONT style="BACKGROUND-COLOR: #7be1e1">inter-process communication</FONT></A><FONT style="BACKGROUND-COLOR: #7be1e1"> mechanisms </FONT>
<LI id=mweQ><A id=mweg title="Context switch" href="https://en.wikipedia.org/wiki/Context_switch" rel=mw:WikiLink data-ve-attributes='{"rel":"mw:WikiLink"}'><FONT style="BACKGROUND-COLOR: #7be1e1">context switching</FONT></A><FONT style="BACKGROUND-COLOR: #7be1e1"> between threads in the same process typically occurs faster than context switching between processes</FONT></LI></UL>
<P id=mwew><FONT style="BACKGROUND-COLOR: #7be1e1">Systems such as </FONT><A id=mwfA title="Windows NT" href="https://en.wikipedia.org/wiki/Windows_NT" rel=mw:WikiLink data-ve-attributes='{"rel":"mw:WikiLink"}'><FONT style="BACKGROUND-COLOR: #7be1e1">Windows NT</FONT></A><FONT style="BACKGROUND-COLOR: #7be1e1"> and </FONT><A id=mwfQ title=OS/2 href="https://en.wikipedia.org/wiki/OS/2" rel=mw:WikiLink data-ve-attributes='{"rel":"mw:WikiLink"}'><FONT style="BACKGROUND-COLOR: #7be1e1">OS/2</FONT></A><FONT style="BACKGROUND-COLOR: #7be1e1"> are said to have <I id=mwfg>cheap</I> threads and <I id=mwfw>expensive</I> processes; in other operating systems there is not so great a difference except in the cost of an </FONT><A id=mwgA title="Address space" href="https://en.wikipedia.org/wiki/Address_space" rel=mw:WikiLink data-ve-attributes='{"rel":"mw:WikiLink"}'><FONT style="BACKGROUND-COLOR: #7be1e1">address-space</FONT></A><FONT style="BACKGROUND-COLOR: #7be1e1"> switch, which on some architectures (notably </FONT><A id=mwgQ title=X86 href="https://en.wikipedia.org/wiki/X86" rel=mw:WikiLink data-ve-attributes='{"rel":"mw:WikiLink"}'><FONT style="BACKGROUND-COLOR: #7be1e1">x86</FONT></A><FONT style="BACKGROUND-COLOR: #7be1e1">) results in a </FONT><A id=mwgg title="Translation lookaside buffer" href="https://en.wikipedia.org/wiki/Translation_lookaside_buffer" rel=mw:WikiLink data-ve-attributes='{"rel":"mw:WikiLink"}'><FONT style="BACKGROUND-COLOR: #7be1e1">translation lookaside buffer</FONT></A><FONT style="BACKGROUND-COLOR: #7be1e1"> (TLB) flush.</FONT></P>
<P id=mwgw><FONT style="BACKGROUND-COLOR: #7be1e1">Advantages and disadvantages of threads vs processes include:</FONT></P>
<UL id=mwhA>
<LI id=mwhQ><FONT style="BACKGROUND-COLOR: #7be1e1"><I id=mwhg>Lower resource consumption</I> of threads: using threads, an application can operate using fewer resources than it would need when using multiple processes. </FONT>
<LI id=mwhw><FONT style="BACKGROUND-COLOR: #7be1e1"><I id=mwiA>Simplified sharing and communication</I> of threads: unlike processes, which require a </FONT><A id=mwiQ title="Message passing" href="https://en.wikipedia.org/wiki/Message_passing" rel=mw:WikiLink data-ve-attributes='{"rel":"mw:WikiLink"}'><FONT style="BACKGROUND-COLOR: #7be1e1">message passing</FONT></A><FONT style="BACKGROUND-COLOR: #7be1e1"> or shared memory mechanism to perform </FONT><A id=mwig title="Inter-process communication" href="https://en.wikipedia.org/wiki/Inter-process_communication" rel=mw:WikiLink data-ve-attributes='{"rel":"mw:WikiLink"}'><FONT style="BACKGROUND-COLOR: #7be1e1">inter-process communication</FONT></A><FONT style="BACKGROUND-COLOR: #7be1e1"> (IPC), threads can communicate through data, code and files they already share. </FONT>
<LI id=mwiw><FONT style="BACKGROUND-COLOR: #7be1e1"><I id=mwjA>Thread crashes a process</I>: due to threads sharing the same address space, an illegal operation performed by a thread can crash the entire process; therefore, one misbehaving thread can disrupt the processing of all the other threads in the application.</FONT></LI></UL><BR><BR><FONT style="BACKGROUND-COLOR: #7be1e1">