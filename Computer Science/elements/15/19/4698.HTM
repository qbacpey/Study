<STRONG><FONT color=blue>Processes, kernel threads, user threads, and fibers : </FONT></STRONG>
<H3 id=Kernel_threads data-mw-section-id="4"><SPAN class=headers>Title:</SPAN></B><SPAN class=RefText> Processes, kernel threads, user threads, and fibers : Kernel threads</SPAN></FONT></H3>
<P id=mwSg><SPAN id=kernel_thread class="anchor ve-pasteProtect" about="#mwt36" typeof="mw:Transclusion" data-mw='{"parts":[{"template":{"target":{"wt":"anchor","href":"./Template:Anchor"},"params":{"1":{"wt":"kernel thread"}},"i":0}}]}' data-ve-no-generated-contents="true" data-ve-attributes='{"typeof":"mw:Transclusion","about":"#mwt36"}'>&nbsp;</SPAN> A <I id=mwSw>kernel thread</I> is a "lightweight" unit of kernel scheduling. At least one kernel thread exists within each process. If multiple kernel threads exist within a process, then they share the same memory and file resources. Kernel threads are preemptively multitasked if the operating system's process <A id=mwTA title="Scheduling (computing)" href="https://en.wikipedia.org/wiki/Scheduling_(computing)" rel=mw:WikiLink data-ve-attributes='{"rel":"mw:WikiLink"}'>scheduler</A> is preemptive. Kernel threads do not own resources except for a <A id=mwTQ title="Call stack" href="https://en.wikipedia.org/wiki/Call_stack" rel=mw:WikiLink data-ve-attributes='{"rel":"mw:WikiLink"}'>stack</A>, a copy of the <A id=mwTg title="Processor register" href="https://en.wikipedia.org/wiki/Processor_register" rel=mw:WikiLink data-ve-attributes='{"rel":"mw:WikiLink"}'>registers</A> including the <A id=mwTw title="Program counter" href="https://en.wikipedia.org/wiki/Program_counter" rel=mw:WikiLink data-ve-attributes='{"rel":"mw:WikiLink"}'>program counter</A>, and <A id=mwUA title="Thread-local storage" href="https://en.wikipedia.org/wiki/Thread-local_storage" rel=mw:WikiLink data-ve-attributes='{"rel":"mw:WikiLink"}'>thread-local storage</A> (if any), and are thus relatively cheap to create and destroy. Thread switching is also relatively cheap: it requires a context switch (saving and restoring registers and stack pointer), but does not change virtual memory and is thus cache-friendly (leaving TLB valid). <SPAN class=extract>The kernel can assign one thread to each logical core in a system (because each processor splits itself up into multiple logical cores if it supports multithreading, or only supports one logical core per physical core if it does not), and can swap out threads that get blocked. However, kernel threads take much longer than user threads to be swapped.<BR></SPAN>