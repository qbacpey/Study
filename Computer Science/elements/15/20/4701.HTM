<STRONG><FONT color=blue>Processes, kernel threads, user threads, and fibers : </FONT></STRONG>
<H3 id=User_threads data-mw-section-id="5"><SPAN class=headers>Title:</SPAN></B><SPAN class=RefText> Processes, kernel threads, user threads, and fibers : User threads</SPAN></FONT></H3>
<P id=mwUg><SPAN id=user_thread class="anchor ve-pasteProtect" about="#mwt37" typeof="mw:Transclusion" data-mw='{"parts":[{"template":{"target":{"wt":"anchor","href":"./Template:Anchor"},"params":{"1":{"wt":"user thread"}},"i":0}}]}' data-ve-no-generated-contents="true" data-ve-attributes='{"typeof":"mw:Transclusion","about":"#mwt37"}'>&nbsp;</SPAN> Threads are sometimes implemented in <A id=mwUw title="User space" class=mw-redirect href="https://en.wikipedia.org/wiki/User_space" rel=mw:WikiLink data-ve-attributes='{"rel":"mw:WikiLink"}'>userspace</A> libraries, thus called <I id=mwVA>user threads</I>. The kernel is unaware of them, so they are managed and scheduled in <A id=mwVQ title="User space" class=mw-redirect href="https://en.wikipedia.org/wiki/User_space" rel=mw:WikiLink data-ve-attributes='{"rel":"mw:WikiLink"}'>userspace</A>. Some implementations base their user threads on top of several kernel threads, to benefit from <A id=mwVg title=Multiprocessing href="https://en.wikipedia.org/wiki/Multiprocessing" rel=mw:WikiLink data-ve-attributes='{"rel":"mw:WikiLink"}'>multi-processor</A> machines (<A id=mwVw title="Thread (computing)" href="https://en.wikipedia.org/wiki/Thread_(computing)#Threading_models" rel=mw:WikiLink data-ve-attributes='{"rel":"mw:WikiLink"}'>M:N model</A>). User threads as implemented by <A id=mwWA title="Virtual machine" href="https://en.wikipedia.org/wiki/Virtual_machine" rel=mw:WikiLink data-ve-attributes='{"rel":"mw:WikiLink"}'>virtual machines</A> are also called <A id=mwWQ title="Green threads" href="https://en.wikipedia.org/wiki/Green_threads" rel=mw:WikiLink data-ve-attributes='{"rel":"mw:WikiLink"}'>green threads</A>.</P>
<P id=mwWg>As user thread implementations are typically entirely in <A id=mwWw title=Userspace class=mw-redirect href="https://en.wikipedia.org/wiki/Userspace" rel=mw:WikiLink data-ve-attributes='{"rel":"mw:WikiLink"}'>userspace</A>, context switching between user threads within the same process is extremely efficient because it does not require any interaction with the kernel at all: a context switch can be performed by locally saving the CPU registers used by the currently executing user thread or fiber and then loading the registers required by the user thread or fiber to be executed. Since scheduling occurs in userspace, the scheduling policy can be more easily tailored to the requirements of the program's workload.</P>
<P id=mwXA>However, the use of blocking system calls in user threads (as opposed to kernel threads) can be problematic. If a user thread or a fiber performs a system call that blocks, the other user threads and fibers in the process are unable to run until the system call returns. A typical example of this problem is when performing I/O: most programs are written to perform I/O synchronously. When an I/O operation is initiated, a system call is made, and does not return until the I/O operation has been completed. In the intervening period, the entire process is "blocked" by the kernel and cannot run, which starves other user threads and fibers in the same process from executing.</P>
<P id=mwXQ>A common solution to this problem (used, in particular, by many of green threads implementations) is providing an I/O API that implements an interface that blocks the calling thread, rather than the entire process, by using non-blocking I/O internally, and scheduling another user thread or fiber while the I/O operation is in progress. Similar solutions can be provided for other blocking system calls. Alternatively, the program can be written to avoid the use of synchronous I/O or other blocking system calls (in particular, using non-blocking I/O, including lambda continuations and/or async/<A id=mwXg title=Await class=mw-redirect href="https://en.wikipedia.org/wiki/Await" rel=mw:WikiLink data-ve-attributes='{"rel":"mw:WikiLink"}'>await</A> primitives<SUP class="mw-ref reference" typeof="mw:Extension/ref" data-mw='{"name":"ref","body":{"html":"<span typeof=\"mw:Transclusion\" data-mw=\"{&amp;quot;parts&amp;quot;:[{&amp;quot;template&amp;quot;:{&amp;quot;target&amp;quot;:{&amp;quot;wt&amp;quot;:&amp;quot;cite web&amp;quot;,&amp;quot;href&amp;quot;:&amp;quot;./Template:Cite_web&amp;quot;},&amp;quot;params&amp;quot;:{&amp;quot;url&amp;quot;:{&amp;quot;wt&amp;quot;:&amp;quot;https://www.youtube.com/watch?v=6lXUrvlMXNU&amp;quot;},&amp;quot;archive-url&amp;quot;:{&amp;quot;wt&amp;quot;:&amp;quot;https://ghostarchive.org/varchive/youtube/20211104/6lXUrvlMXNU&amp;quot;},&amp;quot;archive-date&amp;quot;:{&amp;quot;wt&amp;quot;:&amp;quot;2021-11-04&amp;quot;},&amp;quot;url-status&amp;quot;:{&amp;quot;wt&amp;quot;:&amp;quot;live&amp;quot;},&amp;quot;title&amp;quot;:{&amp;quot;wt&amp;quot;:&amp;quot;Eight Ways to Handle Non-blocking Returns in Message-passing Programs: from C++98 via C++11 to C++20&amp;quot;},&amp;quot;author&amp;quot;:{&amp;quot;wt&amp;quot;:&amp;quot;Sergey Ignatchenko&amp;quot;},&amp;quot;publisher&amp;quot;:{&amp;quot;wt&amp;quot;:&amp;quot;CPPCON&amp;quot;}},&amp;quot;i&amp;quot;:0}}]}\" data-ve-no-generated-contents=\"true\" id=\"mwAZg\">&amp;nbsp;</span><cite id=\"CITEREFSergey_Ignatchenko\" class=\"citation web cs1\" about=\"#mwt39\" data-ve-ignore=\"true\">Sergey Ignatchenko. <a rel=\"mw:ExtLink\" href=\"https://www.youtube.com/watch?v=6lXUrvlMXNU\" class=\"external text\" id=\"mwAZk\">\"Eight Ways to Handle Non-blocking Returns in Message-passing Programs: from C++98 via C++11 to C++20\"</a>. CPPCON. <a rel=\"mw:ExtLink\" href=\"https://ghostarchive.org/varchive/youtube/20211104/6lXUrvlMXNU\" class=\"external text\" id=\"mwAZo\">Archived</a> from the original on 2021-11-04.</cite><span title=\"ctx_ver=Z39.88-2004&amp;amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;amp;rft.genre=unknown&amp;amp;rft.btitle=Eight+Ways+to+Handle+Non-blocking+Returns+in+Message-passing+Programs%3A+from+C%2B%2B98+via+C%2B%2B11+to+C%2B%2B20&amp;amp;rft.pub=CPPCON&amp;amp;rft.au=Sergey+Ignatchenko&amp;amp;rft_id=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3D6lXUrvlMXNU&amp;amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AThread+%28computing%29\" class=\"Z3988\" about=\"#mwt39\" id=\"mwAZs\" data-ve-ignore=\"true\"></span><span about=\"#mwt43\" typeof=\"mw:Transclusion\" data-mw=\"{&amp;quot;parts&amp;quot;:[{&amp;quot;template&amp;quot;:{&amp;quot;target&amp;quot;:{&amp;quot;wt&amp;quot;:&amp;quot;cbignore&amp;quot;,&amp;quot;href&amp;quot;:&amp;quot;./Template:Cbignore&amp;quot;},&amp;quot;params&amp;quot;:{},&amp;quot;i&amp;quot;:0}}]}\" id=\"mwAZw\" data-ve-no-generated-contents=\"true\">&amp;nbsp;</span>"}}' data-ve-attributes='{"typeof":"mw:Extension/ref"}'><A data-ve-attributes='{"style":"counter-reset: mw-Ref 2;"}'><SPAN class="mw-reflink-text ve-pasteProtect">[2]</SPAN></A></SUP>).