There are three steps to creating a thread: 
<P></P><SPAN class=extract>
<P>&#21019;&#24314;&#32447;&#31243;&#30340;&#36807;&#31243;&#21487;&#34987;&#20998;&#20026;&#19977;&#27493;&#65306;</P>
<P>1.&nbsp;&#20026;&#32447;&#31243;&#29366;&#24577;&#20998;&#37197;&#20869;&#23384;&#65307;</P>
<P>2. &#21021;&#22987;&#21270;&#32447;&#31243;&#29366;&#24577;&#65307;</P>
<P>3. &#23558; TCB &#25918;&#20837;&#20934;&#22791;&#38431;&#21015;&#65307;&nbsp;</P></SPAN>
<P></P>
<OL class=enumerate1>
<LI class=enumerate><A id=x1-24003x1 name=x1-24003x1></A>
<P><B>Allocate per-thread state.</B> The first step in the thread constructor is to allocate space for the thread&#8217;s per-thread state: the TCB and stack. <BR><SPAN class=extract>&#32447;&#31243;&#29366;&#24577;&#65288;per-thread state&#65289;&#30001;&#21738;&#20004;&#37096;&#20998;&#32452;&#25104;&#65311;TCB &#21644;&#26632;<BR></SPAN>As we have mentioned, the TCB is the data structure the thread system uses to manage the thread. The stack is an area of memory for storing data about in-progress procedures; it is allocated in memory like any other data structure. <BR><BR>&#21019;&#24314;&#36827;&#31243;&#30340;&#31532;&#19968;&#27493;&#26159;&#20026;&#36827;&#31243;&#29366;&#24577;&#65288;TCP &#21644;&#26632;&#65289;&#65292;&#21019;&#24314; TCB &#27809;&#20160;&#20040;&#20540;&#24471;&#27880;&#24847;&#30340;&#65292;&#26080;&#38750;&#23601;&#26159;&#23558; TCP &#25351;&#38024;&#20256;&#32473;&#32447;&#31243;&#25152;&#22312;&#30340;&#20869;&#23384;&#31354;&#38388;&#65288;thread-&gt;tcb&nbsp;=&nbsp;tcb;&#65289;&#20540;&#24471;&#27880;&#24847;&#30340;&#26159;&#23545;&#20110;&#26632;&#30340;&#21019;&#24314;&#65292;&#36825;&#37324;&#26368;&#20540;&#24471;&#27880;&#24847;&#30340;&#26159;&#23545;&#20110;&#21021;&#22987;&#26632;&#25351;&#38024;&#30340;&#32500;&#25252;&#12290;&#31243;&#24207;&#39318;&#20808;&#22312;&#22320;&#22336;&#31354;&#38388;&#20013;&#21019;&#24314;&#20102;&#19968;&#22359;&#22823;&#23567;&#20026; INITIAL_STACK_SIZE &#30340;&#26632;&#65288;&nbsp;tcb-&gt;stack&nbsp;=&nbsp;new&nbsp;Stack(INITIAL_STACK_SIZE);&#65289;&#38543;&#21518;&#23558;&#26632;&#25351;&#38024;&#25152;&#25351;&#21521;&#30340;&#20301;&#32622;&#35774;&#32622;&#20026; tcb-&gt;stack&nbsp;+&nbsp;INITIAL_STACK_SIZE&#65288;tcb-&gt;sp&nbsp;=&nbsp;tcb-&gt;stack&nbsp;+&nbsp;INITIAL_STACK_SIZE;&#65289;&#20043;&#25152;&#20197;&#35201;&#20570;&#22810;&#36825;&#20040;&#19968;&#27493;&#65292;&#26681;&#26412;&#21407;&#22240;&#26159;&#36825;&#37324;&#30340;&#26632;&#26159;&#21521;&#19979;&#29983;&#38271;&#30340;&#65292;&#22240;&#27492;&#23613;&#31649;&#24320;&#36767;&#26632;&#31354;&#38388;&#30340;&#26102;&#20505;&#26159;&#20174;&#26576;&#20010;&#22320;&#22336;&#24320;&#22987;&#21521;&#19978;&#24320;&#36767;&#31354;&#38388;&#65292;&#20294;&#26159;&#20026;&#20102;&#33021;&#35753;&#26632;&#30340;&#25968;&#25454;&#33021;&#33258;&#19978;&#32780;&#19979;&#22686;&#21152;&#65292;&#22240;&#27492;&#24517;&#39035;&#23558;&#26632;&#25351;&#38024;&#31227;&#21160;&#21040;&#36825;&#22359;&#31354;&#38388;&#30340;&#26368;&#19978;&#26041;<BR><BR><SPAN class=extract>&#20026;&#32447;&#31243;&#26632;&#20998;&#37197;&#20869;&#23384;&#20043;&#21518;&#65292;&#36824;&#38656;&#35201;&#22914;&#20309;&#32500;&#25252;&#26632;&#25351;&#38024;&#65311;&#20196;&#20854;&#31227;&#21160;&#21040;&#26632;&#31354;&#38388;&#30340;&#26368;&#19978;&#26041;<BR></SPAN><BR><SPAN class=extract>&#20026;&#20160;&#20040;&#22312;&#21021;&#22987;&#21270;&#32447;&#31243;&#30340;&#26102;&#20505;&#35201;&#35753;&#26632;&#25351;&#38024;&#31227;&#21160;&#21040;&#26368;&#19978;&#26041;&#65311;&#32447;&#31243;&#26632;&#26159;&#21521;&#19979;&#22686;&#38271;&#30340;</SPAN><A id=x1-24005x2 name=x1-24005x2></A><B>Initialize per-thread state.</B> To initialize the TCB, the thread constructor sets the new thread&#8217;s registers to what they need to be when the thread starts RUNNING. When the thread is assigned a processor, we want it to start running func(arg). <SPAN class=extract>However, instead of having the thread start in func, the constructor starts the thread in a dummy function, stub, which in turn calls func. <BR></SPAN><BR>&#33267;&#20110;&#35848;&#21040;&#21021;&#22987;&#21270; TCB&#65292;&#24456;&#26126;&#26174; TCB &#20013;&#33267;&#23569;&#21547;&#26377;&#26632;&#30340;&#22823;&#23567;&#65288;tcb-&gt;stack_size&nbsp;=&nbsp;INITIAL_STACK_SIZE;&#65289;&#12289;&#26632;&#30340;&#25152;&#22312;&#20301;&#32622;&#65288;&#27880;&#24847;&#65292;&#36825;&#37324;&#26632;&#30340;&#25152;&#22312;&#20301;&#32622;&#26159;&#26632;&#30340;&#8220;&#39030;&#37096;&#8221;&#20063;&#23601;&#26159;&#21021;&#22987;&#21270;&#26632;&#31354;&#38388;&#26102;&#36820;&#22238;&#30340;&#22320;&#22336; tcb-&gt;stack&nbsp;=&nbsp;new&nbsp;Stack(INITIAL_STACK_SIZE)&#65289;&#20197;&#21450;&#26632;&#25351;&#38024;&#65288;tcb-&gt;sp&nbsp;=&nbsp;tcb-&gt;stack&nbsp;+&nbsp;INITIAL_STACK_SIZE;&#65289;&#21644; PC&#65288;tcb-&gt;pc&nbsp;=&nbsp;stub;&#65289;</P>
<LI class=enumerate>
<P>We need this extra step in case the func procedure returns instead of calling thread_exit. Without the stub, func would return to whatever random location is stored at the top of the stack! Instead, func returns to stub and stub calls thread_exit&nbsp;to finish the thread. <BR><BR><SPAN class=extract>&#20540;&#24471;&#27880;&#24847;&#30340;&#26159;&#65292;&#20026;&#20102;&#33021;&#30830;&#20445;&#36827;&#31243;&#30340;&#20837;&#21475;&#26159;&#26729;&#31243;&#24207;&#65288;&#32780;&#19981;&#26159;main&#20989;&#25968;&#65292;&#30830;&#20445;&#26174;&#24335;&#35843;&#29992; thread_exit&#65289;&#22240;&#27492; thread_create &#20570;&#20102;&#20004;&#20214;&#20107;&#24773;&#65306;<BR>1. &#23558;&#21021;&#22987; PC &#35774;&#32622;&#20026;&#26729;&#31243;&#24207;&#65288;tcb-&gt;pc&nbsp;=&nbsp;stub;&#65289;&#65307;<BR>2. &#25353;&#29031;&#35843;&#29992;&#32422;&#23450;&#65292;&#20498;&#24207;&#22320;&#23558;&#26729;&#31243;&#24207;&#30340;&#21442;&#25968;&#21015;&#34920;&#21387;&#20837;&#26632;&#20013;&#65288;*(tcb-&gt;sp)&nbsp;=&nbsp;arg; tcb-&gt;sp--; *(tcb-&gt;sp)&nbsp;=&nbsp;func; tcb-&gt;sp--;&#65289;&#20197;&#20415;&#26729;&#31243;&#24207;&#33021;&#22815;&#20687;&#20854;&#20182;&#20989;&#25968;&#19968;&#26679;&#27491;&#24120;&#25191;&#34892;&#65307;</SPAN></P>
<P>To start at the beginning of stub, the thread constructor sets up the stack as if stub was just called by normal code; the specifics will depend on the calling convention of the machine. In the pseudo-code, we push stub&#8217;s two arguments onto the stack: func and arg. When the thread starts running, the code in stub will access its arguments just like a normal procedure. </P>
<P>In addition, we also push a dummy stack frame for thread_switch&nbsp;onto the stack; we defer an explanation of this detail until we discuss the implementation of thread switching. <BR><BR>&#26368;&#21518;&#36824;&#26377;&#19968;&#20010;&#20540;&#24471;&#27880;&#24847;&#30340;&#22320;&#26041;&#65292;<SPAN class=extract>&#20989;&#25968;&#23558;&#19968;&#20123;&#29992;&#20110; thread_switch &#30340;&#26679;&#20363;&#26632;&#24103;&#21387;&#21040;&#20102;&#26632;&#37324;&#36793;&#65288;thread_dummySwitchFrame(tcb);&#65289;</SPAN></P>
<LI class=enumerate><A id=x1-24007x3 name=x1-24007x3></A>
<P><B>Put TCB on ready list.</B> The last step in creating a thread is to set its state to READY&nbsp;and put the new TCB on the ready list, enabling the thread to be scheduled.<BR><BR><SPAN class=extract>&#21019;&#24314;&#32447;&#31243;&#30340;&#26368;&#21518;&#19968;&#27493;&#26159;&#23558;&#32447;&#31243;&#29366;&#24577;&#35774;&#32622;&#20026; READY&#65288;tcb-&gt;state&nbsp;=&nbsp;READY; &#24456;&#26174;&#28982;&#65292;&#32447;&#31243;&#29366;&#24577;&#20063;&#26159;&#20445;&#23384;&#22312; TCB &#20013;&#30340;&#65289;&#24182;&#23558;&#32447;&#31243;&#30340; TCB &#28155;&#21152;&#21040;&#20934;&#22791;&#21015;&#34920;</SPAN></P></LI></OL>