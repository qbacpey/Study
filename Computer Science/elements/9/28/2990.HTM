<H1 style='BOX-SIZING: border-box; FONT-SIZE: 36px; FONT-FAMILY: "Helvetica Neue", Helvetica, Arial, sans-serif; WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FONT-WEIGHT: 500; COLOR: rgb(51,51,51); FONT-STYLE: normal; ORPHANS: 2; WIDOWS: 2; MARGIN: 20px 0px 10px; LETTER-SPACING: normal; LINE-HEIGHT: 1.1; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; font-variant-ligatures: normal; font-variant-caps: normal; -webkit-text-stroke-width: 0px; text-decoration-style: initial; text-decoration-color: initial'><A title="Permalink to Are pointers and arrays equivalent in C?" style="BOX-SIZING: border-box; TEXT-DECORATION: none; BACKGROUND: none transparent scroll repeat 0% 0%; COLOR: " href="https://eli.thegreenplace.net/2009/10/21/are-pointers-and-arrays-equivalent-in-c" rel=bookmark><SPAN class=headers>Title:</SPAN></B><SPAN class=RefText> Are pointers and arrays equivalent in C?</SPAN></FONT></A></H1>
<P>Short answer:<SPAN>&nbsp;</SPAN><STRONG>no</STRONG></P>
<P><SPAN class=extract>Longer answer: it depends on what you mean by "equivalent". Pointer arithmetic and array indexing are equivalent. In other aspects, pointers and arrays are different</SPAN>.</P>
<P>Here's an example displaying the equivalence:</P><PRE style="BOX-SIZING: border-box; FONT-SIZE: 13px; OVERFLOW: auto; BORDER-TOP: rgb(204,204,204) 1px solid; FONT-FAMILY: Consolas, monaco, monospace; BORDER-RIGHT: rgb(204,204,204) 1px solid; BACKGROUND: rgb(247,247,247); WHITE-SPACE: pre; WORD-SPACING: 0px; BORDER-BOTTOM: rgb(204,204,204) 1px solid; TEXT-TRANSFORM: none; WORD-BREAK: break-all; FONT-WEIGHT: 400; COLOR: rgb(51,51,51); PADDING-BOTTOM: 9px; FONT-STYLE: normal; PADDING-TOP: 9px; PADDING-LEFT: 9px; BORDER-LEFT: rgb(204,204,204) 1px solid; ORPHANS: 2; WIDOWS: 2; MARGIN: 0px 0px 10px; DISPLAY: block; LETTER-SPACING: normal; LINE-HEIGHT: 1.4285; PADDING-RIGHT: 9px; TEXT-INDENT: 0px; font-variant-ligatures: normal; font-variant-caps: normal; -webkit-text-stroke-width: 0px; text-decoration-style: initial; text-decoration-color: initial; overflow-wrap: normal; border-radius: 4px"><SPAN style="BOX-SIZING: border-box; COLOR: rgb(0,127,0)">#include &lt;stdio.h&gt;</SPAN>

<SPAN style="BOX-SIZING: border-box; FONT-WEIGHT: bold; COLOR: rgb(0,0,127)">int</SPAN> <SPAN style="BOX-SIZING: border-box; COLOR: rgb(0,0,127)">main</SPAN>()
{
    <SPAN style="BOX-SIZING: border-box; FONT-WEIGHT: bold; COLOR: rgb(0,0,127)">char</SPAN> arr[] = <SPAN style="BOX-SIZING: border-box; COLOR: rgb(127,0,127)">"don't panic\n"</SPAN>;
    <SPAN style="BOX-SIZING: border-box; FONT-WEIGHT: bold; COLOR: rgb(0,0,127)">char</SPAN>* ptr = arr;

    printf(<SPAN style="BOX-SIZING: border-box; COLOR: rgb(127,0,127)">"%c %c\n"</SPAN>, arr[<SPAN style="BOX-SIZING: border-box; COLOR: rgb(0,127,127)">4</SPAN>], ptr[<SPAN style="BOX-SIZING: border-box; COLOR: rgb(0,127,127)">4</SPAN>]);
    printf(<SPAN style="BOX-SIZING: border-box; COLOR: rgb(127,0,127)">"%c %c\n"</SPAN>, *(arr+<SPAN style="BOX-SIZING: border-box; COLOR: rgb(0,127,127)">2</SPAN>), *(ptr+<SPAN style="BOX-SIZING: border-box; COLOR: rgb(0,127,127)">2</SPAN>));

    <SPAN style="BOX-SIZING: border-box; FONT-WEIGHT: bold; COLOR: rgb(0,0,127)">return</SPAN> <SPAN style="BOX-SIZING: border-box; COLOR: rgb(0,127,127)">0</SPAN>;
}</PRE>
<P>The output is, of course:</P><PRE style="BOX-SIZING: border-box; FONT-SIZE: 13px; OVERFLOW: auto; BORDER-TOP: rgb(204,204,204) 1px solid; FONT-FAMILY: Consolas, monaco, monospace; BORDER-RIGHT: rgb(204,204,204) 1px solid; BACKGROUND: rgb(247,247,247); WHITE-SPACE: pre; WORD-SPACING: 0px; BORDER-BOTTOM: rgb(204,204,204) 1px solid; TEXT-TRANSFORM: none; WORD-BREAK: break-all; FONT-WEIGHT: 400; COLOR: rgb(51,51,51); PADDING-BOTTOM: 9px; FONT-STYLE: normal; PADDING-TOP: 9px; PADDING-LEFT: 9px; BORDER-LEFT: rgb(204,204,204) 1px solid; ORPHANS: 2; WIDOWS: 2; MARGIN: 0px 0px 10px; DISPLAY: block; LETTER-SPACING: normal; LINE-HEIGHT: 1.4285; PADDING-RIGHT: 9px; TEXT-INDENT: 0px; font-variant-ligatures: normal; font-variant-caps: normal; -webkit-text-stroke-width: 0px; text-decoration-style: initial; text-decoration-color: initial; overflow-wrap: normal; border-radius: 4px">t t
n n</PRE>
<P>Note that indexing works on both arrays and pointers. Similarly, pointer arithmetic works on both arrays and pointers.</P>
<DIV id=so-how-are-they-different class=section>
<H3>So how are they different?</H3>
<P>In a very important and fundamental way. Consider this code snippet:</P><PRE style="BOX-SIZING: border-box; FONT-SIZE: 13px; OVERFLOW: auto; BORDER-TOP: rgb(204,204,204) 1px solid; FONT-FAMILY: Consolas, monaco, monospace; BORDER-RIGHT: rgb(204,204,204) 1px solid; BACKGROUND: rgb(247,247,247); WHITE-SPACE: pre; WORD-SPACING: 0px; BORDER-BOTTOM: rgb(204,204,204) 1px solid; TEXT-TRANSFORM: none; WORD-BREAK: break-all; FONT-WEIGHT: 400; COLOR: rgb(51,51,51); PADDING-BOTTOM: 9px; FONT-STYLE: normal; PADDING-TOP: 9px; PADDING-LEFT: 9px; BORDER-LEFT: rgb(204,204,204) 1px solid; ORPHANS: 2; WIDOWS: 2; MARGIN: 0px 0px 10px; DISPLAY: block; LETTER-SPACING: normal; LINE-HEIGHT: 1.4285; PADDING-RIGHT: 9px; TEXT-INDENT: 0px; font-variant-ligatures: normal; font-variant-caps: normal; -webkit-text-stroke-width: 0px; text-decoration-style: initial; text-decoration-color: initial; overflow-wrap: normal; border-radius: 4px"><SPAN style="BOX-SIZING: border-box; FONT-WEIGHT: bold; COLOR: rgb(0,0,127)">char</SPAN> array_place[<SPAN style="BOX-SIZING: border-box; COLOR: rgb(0,127,127)">100</SPAN>] = <SPAN style="BOX-SIZING: border-box; COLOR: rgb(127,0,127)">"don't panic"</SPAN>;
<SPAN style="BOX-SIZING: border-box; FONT-WEIGHT: bold; COLOR: rgb(0,0,127)">char</SPAN>* ptr_place = <SPAN style="BOX-SIZING: border-box; COLOR: rgb(127,0,127)">"don't panic"</SPAN>;

<SPAN style="BOX-SIZING: border-box; FONT-WEIGHT: bold; COLOR: rgb(0,0,127)">int</SPAN> <SPAN style="BOX-SIZING: border-box; COLOR: rgb(0,0,127)">main</SPAN>()
{
    <SPAN style="BOX-SIZING: border-box; FONT-WEIGHT: bold; COLOR: rgb(0,0,127)">char</SPAN> a = array_place[<SPAN style="BOX-SIZING: border-box; COLOR: rgb(0,127,127)">7</SPAN>];
    <SPAN style="BOX-SIZING: border-box; FONT-WEIGHT: bold; COLOR: rgb(0,0,127)">char</SPAN> b = ptr_place[<SPAN style="BOX-SIZING: border-box; COLOR: rgb(0,127,127)">7</SPAN>];

    <SPAN style="BOX-SIZING: border-box; FONT-WEIGHT: bold; COLOR: rgb(0,0,127)">return</SPAN> <SPAN style="BOX-SIZING: border-box; COLOR: rgb(0,127,127)">0</SPAN>;
}</PRE>
<P>What exactly happens in the assignment to<SPAN>&nbsp;</SPAN><TT class="docutils literal"><SPAN class=pre>a</SPAN></TT>, and how is it different from the assignment to<SPAN>&nbsp;</SPAN><TT class="docutils literal"><SPAN class=pre>b</SPAN></TT>? It's informative to take a look at the disassembly (taken from Visual C++ 2005 on an x86 machine running Windows XP):</P><PRE style="BOX-SIZING: border-box; FONT-SIZE: 13px; OVERFLOW: auto; BORDER-TOP: rgb(204,204,204) 1px solid; FONT-FAMILY: Consolas, monaco, monospace; BORDER-RIGHT: rgb(204,204,204) 1px solid; BACKGROUND: rgb(247,247,247); WHITE-SPACE: pre; WORD-SPACING: 0px; BORDER-BOTTOM: rgb(204,204,204) 1px solid; TEXT-TRANSFORM: none; WORD-BREAK: break-all; FONT-WEIGHT: 400; COLOR: rgb(51,51,51); PADDING-BOTTOM: 9px; FONT-STYLE: normal; PADDING-TOP: 9px; PADDING-LEFT: 9px; BORDER-LEFT: rgb(204,204,204) 1px solid; ORPHANS: 2; WIDOWS: 2; MARGIN: 0px 0px 10px; DISPLAY: block; LETTER-SPACING: normal; LINE-HEIGHT: 1.4285; PADDING-RIGHT: 9px; TEXT-INDENT: 0px; font-variant-ligatures: normal; font-variant-caps: normal; -webkit-text-stroke-width: 0px; text-decoration-style: initial; text-decoration-color: initial; overflow-wrap: normal; border-radius: 4px">    char a = array_place[7];

0041137E  mov  al,byte ptr [_array_place+7 (417007h)]
00411383  mov  byte ptr [a],al

    char b = ptr_place[7];

00411386  mov  eax,dword ptr [_ptr_place (417064h)]
0041138B  mov  cl,byte ptr [eax+7]
0041138E  mov  byte ptr [b],cl</PRE>
<P>The semantics of arrays in C dictate that the array name is the address of the first element of the array. Hence in the assignment to<SPAN>&nbsp;</SPAN><TT class="docutils literal"><SPAN class=pre>a</SPAN></TT>, the 8th character of the array is taken by offsetting the value of<SPAN>&nbsp;</SPAN><TT class="docutils literal"><SPAN class=pre>array_place</SPAN></TT><SPAN>&nbsp;</SPAN>by 7, and moving the contents pointed to by the resulting address into the<SPAN>&nbsp;</SPAN><TT class="docutils literal"><SPAN class=pre>al</SPAN></TT><SPAN>&nbsp;</SPAN>register, and later into<SPAN>&nbsp;</SPAN><TT class="docutils literal"><SPAN class=pre>a</SPAN></TT>.</P>
<P>On the other hand, the semantics of pointers are quite different. A pointer is just a regular variable that happens to hold the address of another variable inside. Therefore, to actually compute the offset of the 8th character of the string, the CPU will first copy the value of the pointer into a register and only then increment it. This takes another instruction<SPAN>&nbsp;</SPAN><A id=id1 class=footnote-reference href="https://eli.thegreenplace.net/2009/10/21/are-pointers-and-arrays-equivalent-in-c/#id5">[1]</A>.</P></DIV>
<DIV id=a-graphical-explanation class=section>
<H3>A graphical explanation</H3><SPAN class=extract>
<P>This is a graphical explanation:</P>
<P><img src="https://eli.thegreenplace.net/images/2009/10/array_place.png"> </P>
<P>The rightmost column is the memory addresses, and the boxes are the contents of memory cells. The first few letters of the string in<SPAN>&nbsp;</SPAN><TT class="docutils literal"><SPAN class=pre>array_place</SPAN></TT><SPAN>&nbsp;</SPAN>are displayed.</P>
<P>Note that<SPAN>&nbsp;</SPAN><TT class="docutils literal"><SPAN class=pre>array_place</SPAN></TT><SPAN>&nbsp;</SPAN>is simply a label (or an alias) to the memory address 0x417000. Therefore accessing<SPAN>&nbsp;</SPAN><TT class="docutils literal"><SPAN class=pre>array_place[7]</SPAN></TT><SPAN>&nbsp;</SPAN>is simply accessing memory address 0x417007. Therefore, as we can see in the disassembly, the compiler just replaces<SPAN>&nbsp;</SPAN><TT class="docutils literal"><SPAN class=pre>array_place[7]</SPAN></TT><SPAN>&nbsp;</SPAN>by 0x417007 - no address computation has to be done by the assembly it generates.</P></SPAN><SPAN class=extract>
<P>With a pointer, this works differently:</P>
<P><img src="https://eli.thegreenplace.net/images/2009/10/ptr_place.png"> </P>
<P><TT class="docutils literal"><SPAN class=pre>ptr_place</SPAN></TT><SPAN>&nbsp;</SPAN>is just a variable that contains an address inside<SPAN>&nbsp;</SPAN><A id=id2 class=footnote-reference href="https://eli.thegreenplace.net/2009/10/21/are-pointers-and-arrays-equivalent-in-c/#id6">[2]</A>. This is the address to the first byte of the string that sits in another memory location. Compare this to the disassembly listing of the access to<SPAN>&nbsp;</SPAN><TT class="docutils literal"><SPAN class=pre>pointer_place[7]</SPAN></TT><SPAN>&nbsp;</SPAN>- it becomes clear why the compiler generates that code</SPAN></P></DIV>
<DIV id=variable-names-in-c-are-just-labels class=section>
<H3><SPAN class=extract>
<H3>Variable names in C are just labels</H3>
<P>This point is frequently ignored by programmers who don't actually hack on compilers. A variable in C is just a convenient, alphanumeric pseudonym of a memory location. Were we writing assembly code, we would just create a label in some memory location and then access this label instead of always hard-coding the memory value - and this is what the compiler does.</P>
<P>Well, actually the address is not hard-coded in an absolute way because of loading and relocation issues, but for the sake of this discussion we don't have to get into these details.</P>
<P>A label is something the compiler assigns<SPAN>&nbsp;</SPAN><EM>at compile time</EM>. From here the great difference between arrays and pointers in C stems. And this is also why...</P></SPAN></H3></DIV>
<DIV id=arrays-passed-to-functions-are-converted-to-pointers class=section>
<H3>Arrays passed to functions are converted to pointers</H3>
<P>Here's a snippet:</P><PRE style="BOX-SIZING: border-box; FONT-SIZE: 13px; OVERFLOW: auto; BORDER-TOP: rgb(204,204,204) 1px solid; FONT-FAMILY: Consolas, monaco, monospace; BORDER-RIGHT: rgb(204,204,204) 1px solid; BACKGROUND: rgb(247,247,247); WHITE-SPACE: pre; WORD-SPACING: 0px; BORDER-BOTTOM: rgb(204,204,204) 1px solid; TEXT-TRANSFORM: none; WORD-BREAK: break-all; FONT-WEIGHT: 400; COLOR: rgb(51,51,51); PADDING-BOTTOM: 9px; FONT-STYLE: normal; PADDING-TOP: 9px; PADDING-LEFT: 9px; BORDER-LEFT: rgb(204,204,204) 1px solid; ORPHANS: 2; WIDOWS: 2; MARGIN: 0px 0px 10px; DISPLAY: block; LETTER-SPACING: normal; LINE-HEIGHT: 1.4285; PADDING-RIGHT: 9px; TEXT-INDENT: 0px; font-variant-ligatures: normal; font-variant-caps: normal; -webkit-text-stroke-width: 0px; text-decoration-style: initial; text-decoration-color: initial; overflow-wrap: normal; border-radius: 4px"><SPAN style="BOX-SIZING: border-box; FONT-WEIGHT: bold; COLOR: rgb(0,0,127)">void</SPAN> <SPAN style="BOX-SIZING: border-box; COLOR: rgb(0,0,127)">foo</SPAN>(<SPAN style="BOX-SIZING: border-box; FONT-WEIGHT: bold; COLOR: rgb(0,0,127)">char</SPAN> arr_arg[], <SPAN style="BOX-SIZING: border-box; FONT-WEIGHT: bold; COLOR: rgb(0,0,127)">char</SPAN>* ptr_arg)
{
    <SPAN style="BOX-SIZING: border-box; FONT-WEIGHT: bold; COLOR: rgb(0,0,127)">char</SPAN> a = arr_arg[<SPAN style="BOX-SIZING: border-box; COLOR: rgb(0,127,127)">7</SPAN>];
    <SPAN style="BOX-SIZING: border-box; FONT-WEIGHT: bold; COLOR: rgb(0,0,127)">char</SPAN> b = ptr_arg[<SPAN style="BOX-SIZING: border-box; COLOR: rgb(0,127,127)">7</SPAN>];
}</PRE>
<P>Quiz: how are the accesses to<SPAN>&nbsp;</SPAN><TT class="docutils literal"><SPAN class=pre>a</SPAN></TT><SPAN>&nbsp;</SPAN>and<SPAN>&nbsp;</SPAN><TT class="docutils literal"><SPAN class=pre>b</SPAN></TT><SPAN>&nbsp;</SPAN>different here?</P>
<P>Answer: they're not!</P><PRE style="BOX-SIZING: border-box; FONT-SIZE: 13px; OVERFLOW: auto; BORDER-TOP: rgb(204,204,204) 1px solid; FONT-FAMILY: Consolas, monaco, monospace; BORDER-RIGHT: rgb(204,204,204) 1px solid; BACKGROUND: rgb(247,247,247); WHITE-SPACE: pre; WORD-SPACING: 0px; BORDER-BOTTOM: rgb(204,204,204) 1px solid; TEXT-TRANSFORM: none; WORD-BREAK: break-all; FONT-WEIGHT: 400; COLOR: rgb(51,51,51); PADDING-BOTTOM: 9px; FONT-STYLE: normal; PADDING-TOP: 9px; PADDING-LEFT: 9px; BORDER-LEFT: rgb(204,204,204) 1px solid; ORPHANS: 2; WIDOWS: 2; MARGIN: 0px 0px 10px; DISPLAY: block; LETTER-SPACING: normal; LINE-HEIGHT: 1.4285; PADDING-RIGHT: 9px; TEXT-INDENT: 0px; font-variant-ligatures: normal; font-variant-caps: normal; -webkit-text-stroke-width: 0px; text-decoration-style: initial; text-decoration-color: initial; overflow-wrap: normal; border-radius: 4px">    char a = arr_arg[7];

00412DCE  mov  eax,dword ptr [arr_arg]
00412DD1  mov  cl,byte ptr [eax+7]
00412DD4  mov  byte ptr [a],cl

    char b = ptr_arg[7];

00412DD7  mov  eax,dword ptr [ptr_arg]
00412DDA  mov  cl,byte ptr [eax+7]
00412DDD  mov  byte ptr [b],cl</PRE>
<P><SPAN class=extract>This happens because arrays passed into functions are always converted into pointers. The argument declaration<SPAN>&nbsp;</SPAN><TT class="docutils literal"><SPAN class=pre>char</SPAN><SPAN>&nbsp;</SPAN><SPAN class=pre>arr_place[]</SPAN></TT><SPAN>&nbsp;</SPAN>is just syntactic sugar for<SPAN>&nbsp;</SPAN><TT class="docutils literal"><SPAN class=pre>char*</SPAN><SPAN>&nbsp;</SPAN><SPAN class=pre>arr_place</SPAN></TT><SPAN>&nbsp;</SPAN></SPAN><A id=id3 class=footnote-reference href="https://eli.thegreenplace.net/2009/10/21/are-pointers-and-arrays-equivalent-in-c/#id7">[3]</A>.</P>
<P>Here's a quote from K&amp;R2:</P>
<BLOCKQUOTE><SPAN class=extract>When an array name is passed to a function, what is passed is the location of the initial element. Within the called function, this argument is a local variable, and so an array name parameter is a pointer, that is, a variable containing an address</SPAN>.</BLOCKQUOTE>
<P><SPAN class=extract>If this seems strange, think again. Recall the diagrams of the previous section. The C compiler has no choice here, since an array name is a label it replaces<SPAN>&nbsp;</SPAN><EM>at compile time</EM><SPAN>&nbsp;</SPAN>with the address it represents. But a function isn't called at compile time, it's called<SPAN>&nbsp;</SPAN><EM>at run time</EM>, where something should be placed on the stack to be considered as an argument. The compiler can't just treat array references inside a function as labels and replace them with addresses, because it has no idea what actual array will be passed in at run time</SPAN>.</P>
<P>This last point may be a bit convoluted, but it's not critical to the understanding of the article. You can just take it as a fact: arrays passed to functions are converted to pointers, end of story!</P></DIV>
<DIV id=does-the-difference-affect-me class=section>
<H3>Does the difference affect me?</H3>
<P>Yes.</P>
<P>One way is that arrays just can't be manipulated the way pointers can. Here's a quote from<SPAN>&nbsp;</SPAN><EM>Expert C Programming</EM>:</P>
<BLOCKQUOTE><SPAN class=extract>There is one difference between an array name and a pointer that must be kept in mind. A pointer is a variable, so pa=a and pa++ are legal. But an array name is not a variable; constructions like a=pa and a++ are illegal</SPAN>.</BLOCKQUOTE>
<P>Here's an example:</P><PRE style="BOX-SIZING: border-box; FONT-SIZE: 13px; OVERFLOW: auto; BORDER-TOP: rgb(204,204,204) 1px solid; FONT-FAMILY: Consolas, monaco, monospace; BORDER-RIGHT: rgb(204,204,204) 1px solid; BACKGROUND: rgb(247,247,247); WHITE-SPACE: pre; WORD-SPACING: 0px; BORDER-BOTTOM: rgb(204,204,204) 1px solid; TEXT-TRANSFORM: none; WORD-BREAK: break-all; FONT-WEIGHT: 400; COLOR: rgb(51,51,51); PADDING-BOTTOM: 9px; FONT-STYLE: normal; PADDING-TOP: 9px; PADDING-LEFT: 9px; BORDER-LEFT: rgb(204,204,204) 1px solid; ORPHANS: 2; WIDOWS: 2; MARGIN: 0px 0px 10px; DISPLAY: block; LETTER-SPACING: normal; LINE-HEIGHT: 1.4285; PADDING-RIGHT: 9px; TEXT-INDENT: 0px; font-variant-ligatures: normal; font-variant-caps: normal; -webkit-text-stroke-width: 0px; text-decoration-style: initial; text-decoration-color: initial; overflow-wrap: normal; border-radius: 4px"><SPAN style="BOX-SIZING: border-box; COLOR: rgb(0,127,0)">#include &lt;stdio.h&gt;</SPAN>


<SPAN style="BOX-SIZING: border-box; FONT-WEIGHT: bold; COLOR: rgb(0,0,127)">int</SPAN> <SPAN style="BOX-SIZING: border-box; COLOR: rgb(0,0,127)">main</SPAN>()
{
    <SPAN style="BOX-SIZING: border-box; FONT-WEIGHT: bold; COLOR: rgb(0,0,127)">int</SPAN> i;
    <SPAN style="BOX-SIZING: border-box; FONT-WEIGHT: bold; COLOR: rgb(0,0,127)">char</SPAN> array[] = <SPAN style="BOX-SIZING: border-box; COLOR: rgb(127,0,127)">"don't panic"</SPAN>;
    <SPAN style="BOX-SIZING: border-box; FONT-WEIGHT: bold; COLOR: rgb(0,0,127)">char</SPAN>* ptr = array;

    <SPAN style="BOX-SIZING: border-box; COLOR: rgb(0,127,0)">/* array traversal */</SPAN>
    <SPAN style="BOX-SIZING: border-box; FONT-WEIGHT: bold; COLOR: rgb(0,0,127)">for</SPAN> (i = <SPAN style="BOX-SIZING: border-box; COLOR: rgb(0,127,127)">0</SPAN>; i &lt; <SPAN style="BOX-SIZING: border-box; FONT-WEIGHT: bold; COLOR: rgb(0,0,127)">sizeof</SPAN>(array); ++i)
        printf(<SPAN style="BOX-SIZING: border-box; COLOR: rgb(127,0,127)">"%c "</SPAN>, array[i]);

    printf(<SPAN style="BOX-SIZING: border-box; COLOR: rgb(127,0,127)">"\n"</SPAN>);

    <SPAN style="BOX-SIZING: border-box; COLOR: rgb(0,127,0)">/* pointer traversal */</SPAN>
    <SPAN style="BOX-SIZING: border-box; FONT-WEIGHT: bold; COLOR: rgb(0,0,127)">for</SPAN> (; *ptr; ++ptr)
        printf(<SPAN style="BOX-SIZING: border-box; COLOR: rgb(127,0,127)">"%c "</SPAN>, *ptr);

    <SPAN style="BOX-SIZING: border-box; FONT-WEIGHT: bold; COLOR: rgb(0,0,127)">return</SPAN> <SPAN style="BOX-SIZING: border-box; COLOR: rgb(0,127,127)">0</SPAN>;
}</PRE>
<P>Note how an array has to be indexed with another variable. A pointer, on the contrary, is just a variable that can be manipulated freely.</P>
<P>Another, more important, difference is actually a common C gotcha:</P><SPAN class=extract>
<P>Suppose one file contains a global array:</P><PRE style="BOX-SIZING: border-box; FONT-SIZE: 13px; OVERFLOW: auto; BORDER-TOP: rgb(204,204,204) 1px solid; FONT-FAMILY: Consolas, monaco, monospace; BORDER-RIGHT: rgb(204,204,204) 1px solid; BACKGROUND: rgb(247,247,247); WHITE-SPACE: pre; WORD-SPACING: 0px; BORDER-BOTTOM: rgb(204,204,204) 1px solid; TEXT-TRANSFORM: none; WORD-BREAK: break-all; FONT-WEIGHT: 400; COLOR: rgb(51,51,51); PADDING-BOTTOM: 9px; FONT-STYLE: normal; PADDING-TOP: 9px; PADDING-LEFT: 9px; BORDER-LEFT: rgb(204,204,204) 1px solid; ORPHANS: 2; WIDOWS: 2; MARGIN: 0px 0px 10px; DISPLAY: block; LETTER-SPACING: normal; LINE-HEIGHT: 1.4285; PADDING-RIGHT: 9px; TEXT-INDENT: 0px; font-variant-ligatures: normal; font-variant-caps: normal; -webkit-text-stroke-width: 0px; text-decoration-style: initial; text-decoration-color: initial; overflow-wrap: normal; border-radius: 4px"><SPAN style="BOX-SIZING: border-box; FONT-WEIGHT: bold; COLOR: rgb(0,0,127)">char</SPAN> my_arr[<SPAN style="BOX-SIZING: border-box; COLOR: rgb(0,127,127)">256</SPAN>];</PRE>
<P>And soothed by the seeming equivalence between arrays and pointers, the programmer that wants to use it in another file mistakingly declares as:</P><PRE style="BOX-SIZING: border-box; FONT-SIZE: 13px; OVERFLOW: auto; BORDER-TOP: rgb(204,204,204) 1px solid; FONT-FAMILY: Consolas, monaco, monospace; BORDER-RIGHT: rgb(204,204,204) 1px solid; BACKGROUND: rgb(247,247,247); WHITE-SPACE: pre; WORD-SPACING: 0px; BORDER-BOTTOM: rgb(204,204,204) 1px solid; TEXT-TRANSFORM: none; WORD-BREAK: break-all; FONT-WEIGHT: 400; COLOR: rgb(51,51,51); PADDING-BOTTOM: 9px; FONT-STYLE: normal; PADDING-TOP: 9px; PADDING-LEFT: 9px; BORDER-LEFT: rgb(204,204,204) 1px solid; ORPHANS: 2; WIDOWS: 2; MARGIN: 0px 0px 10px; DISPLAY: block; LETTER-SPACING: normal; LINE-HEIGHT: 1.4285; PADDING-RIGHT: 9px; TEXT-INDENT: 0px; font-variant-ligatures: normal; font-variant-caps: normal; -webkit-text-stroke-width: 0px; text-decoration-style: initial; text-decoration-color: initial; overflow-wrap: normal; border-radius: 4px"><SPAN style="BOX-SIZING: border-box; FONT-WEIGHT: bold; COLOR: rgb(0,0,127)">extern</SPAN> <SPAN style="BOX-SIZING: border-box; FONT-WEIGHT: bold; COLOR: rgb(0,0,127)">char</SPAN>* my_arr;</PRE>
<P>When he tries to access some element of the array using this pointer, he will most likely get a segmentation fault or a fatal exception (the nomenclature depends on the OS). Understanding why this happens is left as an exercise to the reader<SPAN>&nbsp;</SPAN></P>
<P></SPAN><A id=id4 class=footnote-reference href="https://eli.thegreenplace.net/2009/10/21/are-pointers-and-arrays-equivalent-in-c/#id8">[4]</A>.