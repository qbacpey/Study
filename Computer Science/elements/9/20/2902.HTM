<SPAN class=extract>Generalizing, both Windows and UNIX have various system calls that return a handle to some kernel object; these handles are used in later calls as an ID. 
<P></P>
<P>&#24456;&#22810;&#26102;&#20505;&#65292;&#26080;&#35770;&#26159; Windows &#36824;&#26159; UNIX &#37117;&#20250;&#36873;&#25321;&#36820;&#22238;&#19968;&#20010;&#25351;&#21521;&#20869;&#26680;&#23545;&#35937;&#30340;&#21477;&#26564;&#65292;&#36825;&#20123;&#21477;&#26564;&#24448;&#24448;&#20250;&#34987;&#20351;&#29992;&#22312;&#24448;&#21518;&#30340;&#31995;&#32479;&#35843;&#29992;&#20013;&#20316;&#20026; ID&#65288;&#19981;&#26159;&#25351;&#38024;&#65289;</P></SPAN><SPAN class=extract>
<P>The process ID returned by UNIX fork is used in later calls to UNIX wait; we will see below that UNIX open returns a file descriptor that is used in other system calls.</P>
<P>fork &#25152;&#36820;&#22238;&#30340;&#36827;&#31243; ID &#21487;&#20197;&#34987; wait &#20351;&#29992;&#65292;open &#25152;&#36820;&#22238;&#30340;&#25991;&#20214;&#25551;&#36848;&#31526;&#20063;&#33021;&#34987;&#20854;&#20182;&#31995;&#32479;&#35843;&#29992;&#25152;&#20351;&#29992;</P></SPAN><SPAN class=extract>
<P>It is important to realize that these handles are <EM>not</EM> pointers to kernel data structures; otherwise, an erroneous user program could cause havoc in the kernel by making system calls with fake handles. Rather, they are specific to the process and checked for validity on each use.</P>
<P>&#27880;&#24847;&#65292;&#21477;&#26564;&#24182;&#19981;&#26159;&#25351;&#21521;&#20869;&#26680;&#25968;&#25454;&#32467;&#26500;&#30340;&#25351;&#38024;&#65292;&#32780;&#26159;&#19968;&#31181;&#31867;&#20284;&#20110;&#36827;&#31243;&#29305;&#24615;&#30340;&#19996;&#35199;&#65292;&#20869;&#26680;&#22312;&#27599;&#27425;&#20351;&#29992;&#36825;&#20010;&#21477;&#26564;&#30340;&#26102;&#20505;&#37117;&#20250;&#26816;&#26597;&#20854;&#21512;&#27861;&#24615;</P></SPAN>
<P></P><SPAN class=extract>
<P>Further, in both Windows and UNIX, handles are reference counted. Whenever the kernel returns a handle, it bumps a reference counter, and whenever the process releases a handle (or exits), the reference counter is decremented. </P>
<P>&#26080;&#35770;&#26159;&#22312; Windows &#36824;&#26159; UNIX &#20013;&#65292;&#21477;&#26564;&#37117;&#21487;&#20197;&#20805;&#24403;&#24341;&#29992;&#35745;&#25968;&#12290;&#27599;&#24403;&#20869;&#26680;&#65288;&#21521;&#36827;&#31243;&#65289;&#36820;&#22238;&#19968;&#20010;&#21477;&#26564;&#30340;&#26102;&#20505;&#65292;&#23427;&#37117;&#20250;&#36882;&#22686;&#24341;&#29992;&#35745;&#25968;&#65307;&#27599;&#24403;&#36827;&#31243;&#37322;&#25918;&#21477;&#26564;&#25110;&#25191;&#34892; exit &#36864;&#20986;&#26102;&#65292;&#23427;&#37117;&#20250;&#36882;&#20943;&#24341;&#29992;&#35745;&#25968;</P></SPAN><SPAN class=extract>
<P>UNIX fork sets the process ID reference count to two, one for the parent and one for the child.</P>
<P>UNIX fork &#20250;&#23558;&#36827;&#31243; ID &#24341;&#29992;&#35745;&#25968;&#35774;&#32622;&#20026;&#20108;&#65292;&#20854;&#19968;&#20316;&#20026;&#29238;&#36827;&#31243;&#65292;&#20854;&#20108;&#20316;&#20026;&#23376;&#36827;&#31243;</P></SPAN><SPAN class=extract>
<P>&nbsp;The underlying data structure, the PCB, is reclaimed only when the reference count goes to zero, that is, when both the parent and child terminate.</P>
<P>&#20869;&#26680;&#30340;&#24213;&#23618;&#25968;&#25454;&#32467;&#26500;&#65288;PCB&#65289;&#21482;&#26377;&#22312;&#24341;&#29992;&#35745;&#25968;&#24402;&#38646;&#30340;&#26102;&#20505;&#25165;&#20250;&#34987;&#22238;&#25910;&#65292;&#21363;&#29238;&#36827;&#31243;&#21644;&#23376;&#36827;&#31243;&#37117;&#24635;&#32467;&#20102;</P>
<P>&#24341;&#29992;&#35745;&#25968;&#19981;&#24402;&#38646;&#24213;&#23618;&#25968;&#25454;&#32467;&#26500;&#26159;&#21542;&#20250;&#34987;&#22238;&#25910;&#65311;</P>
<P>&#24213;&#23618;&#25968;&#25454;&#32467;&#26500;&#26159;&#21542;&#19968;&#23450;&#35201;&#22312;&#35745;&#25968;&#22120;&#24402;&#38646;&#30340;&#26102;&#20505;&#25165;&#20250;&#34987;&#22238;&#25910;&#65311;</P>
<P></SPAN>