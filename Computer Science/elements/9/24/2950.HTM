<SPAN class=extract>The name of an array usually evaluates to the address of the first element of the array, so<SPAN>&nbsp;</SPAN><CODE><FONT face="Courier New">array</FONT></CODE><SPAN>&nbsp;</SPAN>and<SPAN>&nbsp;</SPAN><CODE><FONT face="Courier New">&amp;array</FONT></CODE><SPAN>&nbsp;</SPAN>have the same value (but different types, so<SPAN>&nbsp;</SPAN><CODE><FONT face="Courier New">array+1</FONT></CODE><SPAN>&nbsp;</SPAN>and<SPAN>&nbsp;</SPAN><CODE><FONT face="Courier New">&amp;array+1</FONT></CODE><SPAN>&nbsp;</SPAN>will<SPAN>&nbsp;</SPAN><EM>not</EM><SPAN>&nbsp;</SPAN>be equal if the array is more than 1 element long)</SPAN>. 
<P></P>
<P>There are two exceptions to this: when the array name is an operand of<SPAN>&nbsp;</SPAN><CODE><FONT face="Courier New">sizeof</FONT></CODE><SPAN>&nbsp;</SPAN>or unary<SPAN>&nbsp;</SPAN><CODE><FONT face="Courier New">&amp;</FONT></CODE><SPAN>&nbsp;</SPAN>(address-of), the name refers to the array object itself. Thus<SPAN>&nbsp;</SPAN><CODE><FONT face="Courier New">sizeof array</FONT></CODE><SPAN>&nbsp;</SPAN>gives you the size in bytes of the entire array, not the size of a pointer.</P><SPAN class=extract>
<P>For an array defined as<SPAN>&nbsp;</SPAN><CODE><FONT face="Courier New">T array[size]</FONT></CODE>, it will have type<SPAN>&nbsp;</SPAN><CODE><FONT face="Courier New">T *</FONT></CODE>. When/if you increment it, you get to the next element in the array.</P>
<P><CODE><FONT face="Courier New">&amp;array</FONT></CODE><SPAN>&nbsp;</SPAN>evaluates to the same address, but given the same definition, it creates a pointer of the type<SPAN>&nbsp;</SPAN><CODE><FONT face="Courier New">T(*)[size]</FONT></CODE><SPAN>&nbsp;</SPAN>-- i.e., it's a pointer to an array, not to a single element. If you increment this pointer, it'll add the size of the entire array, not the size of a single element.</P>
<P></SPAN>&nbsp;For example, with code like this:</P><PRE class="lang-c s-code-block"><CODE class="hljs language-c"><FONT face="Courier New"><FONT size=2><SPAN class=hljs-type>char</SPAN> <SPAN class=hljs-built_in>array</SPAN>[<SPAN class=hljs-number>16</SPAN>];
<SPAN class=hljs-built_in>printf</SPAN>(<SPAN class=hljs-string>"%p\t%p"</SPAN>, (<SPAN class=hljs-type>void</SPAN>*)&amp;<SPAN class=hljs-built_in>array</SPAN>, (<SPAN class=hljs-type>void</SPAN>*)(&amp;<SPAN class=hljs-built_in>array</SPAN>+<SPAN class=hljs-number>1</SPAN>));</FONT>
</FONT></CODE></PRE>
<P>We can expect the second pointer to be 16 greater than the first (because it's an array of 16 char's). Since %p typically converts pointers in hexadecimal, it might look something like:</P><PRE class="lang-c s-code-block"><CODE class="hljs language-c"><FONT face="Courier New"><FONT size=2><SPAN class=hljs-number>0x12341000</SPAN>    <SPAN class=hljs-number>0x12341010</SPAN></FONT></FONT></CODE></PRE>
<P>&#24635;&#32780;&#35328;&#20043;&#65292;&#26368;&#20851;&#38190;&#30340;&#38382;&#39064;&#22312;&#20110;<SPAN class=extract>&#25968;&#32452;&#21482;&#26377;&#22312;&#34987; &amp; &#21644; sizeof &#25805;&#20316;&#31526;&#20316;&#20026;&#21442;&#25968;&#30340;&#26102;&#20505;&#65292;&#31867;&#22411;&#25165;&#26159;&#25968;&#32452;&#65292;&#20854;&#20182;&#20219;&#20309;&#26102;&#20505;&#23427;&#30340;&#31867;&#22411;&#37117;&#26159;&#25351;&#21521;&#31532;&#19968;&#20010;&#20803;&#32032;&#30340;&#25351;&#38024;</SPAN><FONT style="BACKGROUND-COLOR: #f9f5e9"><SPAN class=extract><FONT style="BACKGROUND-COLOR: #f9f5e9">&#25152;&#20197; &amp;num + 1 &#25165;&#20250;&#36882;&#22686;&#19968;&#20010;&#25968;&#32452;&#30340;&#37327;&#65292;&#32780; num + 1&#21482;&#20250;&#36882;&#22686;&#19968;&#20010;&#20803;&#32032;&#30340;&#37327;&#65288;&#27605;&#31455;&#21069;&#32773;&#20540;&#30340;&#31867;&#22411;&#26159;&#25968;&#32452;&#65292;&#21518;&#32773;&#20540;&#30340;&#31867;&#22411;&#26159;&#25351;&#38024;&#65289;<BR></FONT></SPAN>