With a pointer, this works differently: 
<P></P>
<P><TT class="docutils literal"><SPAN class=pre><SPAN class=extract><TT class="docutils literal"><SPAN class=pre>ptr_place</SPAN></TT><SPAN>&nbsp;</SPAN>is just a variable that contains an address inside<SPAN>&nbsp;</SPAN></SPAN></SPAN></TT><A id=id2 class=footnote-reference href="https://eli.thegreenplace.net/2009/10/21/are-pointers-and-arrays-equivalent-in-c/#id6">[2]</A>. This is the address to the first byte of the string that sits in another memory location. Compare this to the disassembly listing of the access to<SPAN>&nbsp;</SPAN><TT class="docutils literal"><SPAN class=pre>pointer_place[7]</SPAN></TT><SPAN>&nbsp;</SPAN>- it becomes clear why the compiler generates that code