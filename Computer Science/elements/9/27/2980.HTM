With a pointer, this works differently:</P><img src="https://eli.thegreenplace.net/images/2009/10/ptr_place.png"> 
<P><TT class="docutils literal"><SPAN class=pre>ptr_place</SPAN></TT><SPAN>&nbsp;</SPAN>is just a variable that contains an address inside<SPAN>&nbsp;</SPAN><A id=id2 class=footnote-reference href="https://eli.thegreenplace.net/2009/10/21/are-pointers-and-arrays-equivalent-in-c/#id6">[2]</A>. This is the address to the first byte of the string that sits in another memory location. Compare this to the disassembly listing of the access to<SPAN>&nbsp;</SPAN><TT class="docutils literal"><SPAN class=pre>pointer_place[7]</SPAN></TT><SPAN>&nbsp;</SPAN>- it becomes clear why the compiler generates that code