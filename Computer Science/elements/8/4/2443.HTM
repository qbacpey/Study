<SPAN class=RefText><SPAN class=RefText><SPAN class=headers>Title:</SPAN></B><SPAN class=RefText> traps</SPAN></FONT></SPAN></SPAN> 
<P></P>
<P>A<SPAN>&nbsp;</SPAN><STRONG><A href="http://en.wikipedia.org/wiki/Kernel_trap" rel=noreferrer>trap</A></STRONG><SPAN>&nbsp;</SPAN>is an exception in a user process. It's caused by division by zero or invalid memory access. It's also the usual way to invoke a kernel routine (a<SPAN>&nbsp;</SPAN><A href="http://en.wikipedia.org/wiki/System_call" rel=noreferrer>system call</A>) because those run with a higher priority than user code. Handling is synchronous (so the user code is suspended and continues afterwards). In a sense they are "active" - most of the time, the code expects the trap to happen and relies on this fact.</P>
<P></P>
<P>An<SPAN>&nbsp;</SPAN><STRONG><A href="http://en.wikipedia.org/wiki/Interrupt" rel=noreferrer>interrupt</A></STRONG><SPAN>&nbsp;</SPAN>is something generated by the hardware (devices like the hard disk, graphics card, I/O ports, etc). These are asynchronous (i.e. they don't happen at predictable places in the user code) or "passive" since the interrupt handler has to wait for them to happen eventually.</P>
<P><SPAN class=extract>&#19968;&#33324;&#25105;&#20204;&#20351;&#29992;&#20160;&#20040;&#31867;&#22411;&#30340;&#20013;&#26029;&#26469;&#35825;&#21457;&#31995;&#32479;&#35843;&#29992;&#65311;&#25429;&#33719;</SPAN></P>
<P>You can also see a trap as a kind of CPU-internal interrupt since the handler for trap handler looks like an interrupt handler (registers and stack pointers are saved, there is a context switch, execution can resume in some cases where it left off).