<H4 class=subsectionHead><SPAN class=headers>Title:</SPAN></B><SPAN class=RefText> 2.4.2 Interrupt Stack</SPAN></FONT></H4><SPAN class=extract>
<P>Where should the interrupted process&#8217;s state be saved, and what stack should the kernel&#8217;s code use?</P>
<P>&#20013;&#26029;&#36827;&#31243;&#30340;&#29366;&#24577;&#24212;&#35813;&#34987;&#20445;&#23384;&#22312;&#20309;&#22788;&#65311;</P>
<P>&#20869;&#26680;&#20195;&#30721;&#24212;&#24403;&#20351;&#29992;&#20160;&#20040;&#26632;&#65311;&nbsp;</P></SPAN>
<P><SPAN class=extract>On most processors, a special, privileged hardware register points to a region of kernel memory called the <EM><A data-ixbpernmnjoud4qz9ktzkg='{"name": "OEBPS/Text/part0000.xhtml", "frag": "glo:interrupt stack"}'>interrupt stack</A></EM>. <SPAN class=extract>When an interrupt, processor exception, or system call trap causes a context switch into the kernel</SPAN>, the hardware changes the stack pointer to point to the base of the kernel&#8217;s interrupt stack. The hardware automatically saves some of the interrupted process&#8217;s registers by pushing them onto the interrupt stack before calling the kernel&#8217;s handler. </SPAN></P><SPAN class=extract>
<P>When the kernel handler runs, it pushes any remaining registers onto the stack before performing its work. When returning from the interrupt, processor exception or system call trap, the reverse occurs: first, the handler pops the saved registers, and then, the hardware restores the registers it saved, returning to the point where the process was interrupted. When returning from a system call, the value of the saved program counter must be incremented so that the hardware returns to the instruction immediately <EM>after</EM> the one that caused the trap. </P>
<P></SPAN><SPAN class=extract>&nbsp;</P>
<P>You might think you could use the process&#8217;s user-level stack to store its state. However, a separate, kernel-level interrupt stack is needed for two reasons. </P>
<UL class=itemize1>
<LI class=itemize>
<P><B>Reliability.</B> The process&#8217;s user-level stack pointer might not be a valid memory address (e.g., if the program has a bug), but the kernel handler must continue to work properly. </P>
<LI class=itemize>
<P><B>Security.</B> On a multiprocessor, other threads running in the same process can modify user memory during the system call. If the kernel handler stores its local variables on the user-level stack, the user program might be able to modify the kernel&#8217;s return address, potentially causing the kernel to jump to arbitrary code. </P></LI></UL>
<P>On a multiprocessor, each processor needs to have its own interrupt stack so that, for example, the kernel can handle simultaneous system calls and exceptions across multiple processors. For each processor, the kernel allocates a separate region of memory as that processor&#8217;s interrupt stack.</P></SPAN>