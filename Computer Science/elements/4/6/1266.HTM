<SPAN class=headers>Title:</SPAN></B><SPAN class=RefText> 2.6 Implementing Secure System Calls : kernel stub</SPAN></FONT> 
<P></P>
<P><SPAN class=extract>The kernel stub has four tasks</SPAN>: </P>
<P></P>
<UL class=itemize1>
<LI class=itemize>
<P><B>Locate system call arguments.</B> <SPAN class=extract>Unlike a regular kernel procedure, the arguments to a system call are stored in user memory, typically on the user stack</SPAN>. <SPAN class=extract>Of course, the user stack pointer may be corrupted! Even if it is valid, it is a virtual, not a physical, address.</SPAN> <SPAN class=extract>If the system call has a pointer argument (e.g., a file name or buffer), the stub must check the address to verify it is a legal address within the user domain. If so, the stub converts it to a physical address so that the kernel can safely use it</SPAN>. In Figure&nbsp;<A data-ixbpernmnjoud4qz9ktzkg='{"name": "OEBPS/Text/part0000.xhtml", "frag": "x1-4701414"}'>2.14</A>, the pointer to the string representing the file name is stored on the stack; therefore, the stub must check and translate both the stack address and the string pointer. </P>
<LI class=itemize>
<P><STRONG>Validate parameters. </STRONG><SPAN class=extract>The kernel must also protect itself against malicious or accidental errors in the format or content of its arguments</SPAN>.<STRONG> </STRONG>A file name is typically a zero-terminated string, but the kernel cannot trust the user code to always work correctly. The file name may be corrupted; it may point to memory outside the application&#8217;s region; it may start inside the application&#8217;s memory region but extend beyond it; the application may not have permission to access the file; the file may not exist; and so forth. <SPAN class=extract>If an error is detected, the kernel returns it to the user program; otherwise, the kernel performs the operation on the application&#8217;s behalf. </SPAN></P>
<LI class=itemize>
<P><SPAN class=extract></SPAN><B>Copy before check.</B> <SPAN class=extract>In most cases, the kernel copies system call parameters into kernel memory before performing the necessary checks</SPAN>. <SPAN class=extract>The reason for this is to prevent the application from modifying the parameter <EM>after</EM> the stub checks the value, but <EM>before</EM> the parameter is used in the actual implementation of the routine. This is called a <EM><A data-ixbpernmnjoud4qz9ktzkg='{"name": "OEBPS/Text/part0000.xhtml", "frag": "glo:time of check vs. time of use attack"}'>time of check vs. time of use</A></EM> (TOCTOU) attack</SPAN>. For example, the application could call open with a valid file name but, after the check, change the contents of the string to be a different name, such as a file containing another user&#8217;s private data. </P>
<LI class=itemize>
<P>TOCTOU is not a new attack &#8212; the first occurrence dates from the mid-1960&#8217;s. While it might seem that a process necessarily stops whenever it does a system call, this is not always the case. For example, if one process shares a memory region with another process, then the two processes working together can launch a TOCTOU attack. Similarly, a parallel program running on two processors can launch a TOCTOU attack, where one processor traps into the kernel while the other modifies the string at precisely the right (or wrong) time. Note that the kernel needs to be correct in every case, while the attacker can try any number of times before succeeding. </P>
<LI class=itemize><SPAN class=extract>
<P><STRONG>Copy back any results. </STRONG>For the user program to access the results of the system call, the stub must copy the result from the kernel into user memory. Again, the kernel must first check the user address and convert it to a kernel address before performing the copy</P></SPAN></LI></UL>