<DT><CODE><FONT face="Courier New"><SPAN class=headers>Title:</SPAN></B><SPAN class=RefText> 16 Examining the Symbol Table : whatis[/flags] [arg]</SPAN></FONT></FONT></CODE> 
<DD>
<P>Print the data type of<SPAN>&nbsp;</SPAN><VAR>arg</VAR>, which can be either an expression or a name of a data type. With no argument, print the data type of<SPAN>&nbsp;</SPAN><CODE><FONT face="Courier New">$</FONT></CODE>, the last value in the value history.</P><SPAN class=extract>
<P>If<SPAN>&nbsp;</SPAN><VAR>arg</VAR><SPAN>&nbsp;</SPAN>is an expression (see<SPAN>&nbsp;</SPAN><A href="https://sourceware.org/gdb/current/onlinedocs/gdb/Expressions.html#Expressions">Expressions</A>), it is not actually evaluated, and any side-effecting operations (such as assignments or function calls) inside it do not take place.</P>
<P></SPAN><SPAN class=extract>If<SPAN>&nbsp;</SPAN><VAR>arg</VAR><SPAN>&nbsp;</SPAN>is a variable or an expression,<SPAN>&nbsp;</SPAN><CODE><FONT face="Courier New">whatis</FONT></CODE><SPAN>&nbsp;</SPAN>prints its literal type as it is used in the source code.</SPAN> If the type was defined using a<SPAN>&nbsp;</SPAN><CODE><FONT face="Courier New">typedef</FONT></CODE>,<SPAN>&nbsp;</SPAN><CODE><FONT face="Courier New">whatis</FONT></CODE><SPAN>&nbsp;</SPAN>will<SPAN>&nbsp;</SPAN><EM>not</EM><SPAN>&nbsp;</SPAN>print the data type underlying the<SPAN>&nbsp;</SPAN><CODE><FONT face="Courier New">typedef</FONT></CODE>. If the type of the variable or the expression is a compound data type, such as<SPAN>&nbsp;</SPAN><CODE><FONT face="Courier New">struct</FONT></CODE><SPAN>&nbsp;</SPAN>or<SPAN>&nbsp;</SPAN><CODE><FONT face="Courier New">class</FONT></CODE>,<SPAN>&nbsp;</SPAN><CODE><FONT face="Courier New">whatis</FONT></CODE><SPAN>&nbsp;</SPAN>never prints their fields or methods. It just prints the<SPAN>&nbsp;</SPAN><CODE><FONT face="Courier New">struct</FONT></CODE>/<CODE><FONT face="Courier New">class</FONT></CODE><SPAN>&nbsp;</SPAN>name (a.k.a. its<SPAN>&nbsp;</SPAN><EM>tag</EM>). If you want to see the members of such a compound data type, use<SPAN>&nbsp;</SPAN><CODE><FONT face="Courier New">ptype</FONT></CODE>.</P>
<P><SPAN class=extract>If<SPAN>&nbsp;</SPAN><VAR>arg</VAR><SPAN>&nbsp;</SPAN>is a type name that was defined using<SPAN>&nbsp;</SPAN><CODE><FONT face="Courier New">typedef</FONT></CODE>,<SPAN>&nbsp;</SPAN><CODE><FONT face="Courier New">whatis</FONT></CODE><SPAN>&nbsp;</SPAN><EM>unrolls</EM><SPAN>&nbsp;</SPAN>only one level of that<SPAN>&nbsp;</SPAN><CODE><FONT face="Courier New">typedef</FONT></CODE>. Unrolling means that<SPAN>&nbsp;</SPAN><CODE><FONT face="Courier New">whatis</FONT></CODE><SPAN>&nbsp;</SPAN>will show the underlying type used in the<SPAN>&nbsp;</SPAN><CODE><FONT face="Courier New">typedef</FONT></CODE><SPAN>&nbsp;</SPAN>declaration of<SPAN>&nbsp;</SPAN><VAR>arg</VAR>. However, if that underlying type is also a<SPAN>&nbsp;</SPAN><CODE><FONT face="Courier New">typedef</FONT></CODE>,<SPAN>&nbsp;</SPAN><CODE><FONT face="Courier New">whatis</FONT></CODE><SPAN>&nbsp;</SPAN>will not unroll it.</SPAN></P>
<P>For C code, the type names may also have the form &#8216;<SAMP>class<SPAN>&nbsp;</SPAN><VAR>class-name</VAR></SAMP>&#8217;, &#8216;<SAMP>struct<SPAN>&nbsp;</SPAN><VAR>struct-tag</VAR></SAMP>&#8217;, &#8216;<SAMP>union<SPAN>&nbsp;</SPAN><VAR>union-tag</VAR></SAMP>&#8217; or &#8216;<SAMP>enum<SPAN>&nbsp;</SPAN><VAR>enum-tag</VAR></SAMP>&#8217;.</P>
<P><VAR>flags</VAR><SPAN>&nbsp;</SPAN>can be used to modify how the type is displayed. Available flags are:</P>
<DL compact>
<DT><CODE><FONT face="Courier New">r</FONT></CODE> 
<DD>
<P>Display in &#8220;raw&#8221; form. Normally,<SPAN>&nbsp;</SPAN><SMALL><FONT size=2>GDB</FONT></SMALL><SPAN>&nbsp;</SPAN>substitutes template parameters and typedefs defined in a class when printing the class&#8217; members. The<SPAN>&nbsp;</SPAN><CODE><FONT face="Courier New">/r</FONT></CODE><SPAN>&nbsp;</SPAN>flag disables this.</P>
<DT><CODE><FONT face="Courier New">m</FONT></CODE> 
<DD>
<P>Do not print methods defined in the class.</P>
<DT><CODE><FONT face="Courier New">M</FONT></CODE> 
<DD>
<P>Print methods defined in the class. This is the default, but the flag exists in case you change the default with<SPAN>&nbsp;</SPAN><CODE><FONT face="Courier New">set print type methods</FONT></CODE>.</P>
<DT><CODE><FONT face="Courier New">t</FONT></CODE> 
<DD>
<P>Do not print typedefs defined in the class. Note that this controls whether the typedef definition itself is printed, not whether typedef names are substituted when printing other types.</P>
<DT><CODE><FONT face="Courier New">T</FONT></CODE> 
<DD>
<P>Print typedefs defined in the class. This is the default, but the flag exists in case you change the default with<SPAN>&nbsp;</SPAN><CODE><FONT face="Courier New">set print type typedefs</FONT></CODE>.</P>
<DT><CODE><FONT face="Courier New">o</FONT></CODE> 
<DD>
<P>Print the offsets and sizes of fields in a struct, similar to what the<SPAN>&nbsp;</SPAN><CODE><FONT face="Courier New">pahole</FONT></CODE><SPAN>&nbsp;</SPAN>tool does. This option implies the<SPAN>&nbsp;</SPAN><CODE><FONT face="Courier New">/tm</FONT></CODE><SPAN>&nbsp;</SPAN>flags.</P>
<DT><CODE><FONT face="Courier New">x</FONT></CODE> 
<DD>
<P>Use hexadecimal notation when printing offsets and sizes of fields in a struct.</P>
<DT><CODE><FONT face="Courier New">d</FONT></CODE> 
<DD>
<P>Use decimal notation when printing offsets and sizes of fields in a struct.</P>
<P>For example, given the following declarations:</P>
<DIV class=smallexample><PRE class=smallexample>struct tuv
{
  int a1;
  char *a2;
  int a3;
};

struct xyz
{
  int f1;
  char f2;
  void *f3;
  struct tuv f4;
};

union qwe
{
  struct tuv fff1;
  struct xyz fff2;
};

struct tyu
{
  int a1 : 1;
  int a2 : 3;
  int a3 : 23;
  char a4 : 2;
  int64_t a5;
  int a6 : 5;
  int64_t a7 : 3;
};
</PRE></DIV><SPAN class=extract>
<P>Issuing a<SPAN>&nbsp;</SPAN><KBD>ptype /o struct tuv</KBD><SPAN>&nbsp;</SPAN>command would print:</P>
<DIV class=smallexample><PRE class=smallexample>(gdb) ptype /o struct tuv
/* offset      |    size */  type = struct tuv {
/*      0      |       4 */    int a1;
/* XXX  4-byte hole      */
/*      8      |       8 */    char *a2;
/*     16      |       4 */    int a3;

                               /* total size (bytes):   24 */
                             }
</PRE></DIV>
<P>Notice the format of the first column of comments. There, you can find two parts separated by the &#8216;<SAMP>|</SAMP>&#8217; character: the<SPAN>&nbsp;</SPAN><EM>offset</EM>, which indicates where the field is located inside the struct, in bytes, and the<SPAN>&nbsp;</SPAN><EM>size</EM><SPAN>&nbsp;</SPAN>of the field. Another interesting line is the marker of a<SPAN>&nbsp;</SPAN><EM>hole</EM><SPAN>&nbsp;</SPAN>in the struct, indicating that it may be possible to pack the struct and make it use less space by reorganizing its fields.</P></SPAN>
<P>It is also possible to print offsets inside an union:</P>
<DIV class=smallexample><PRE class=smallexample>(gdb) ptype /o union qwe
/* offset      |    size */  type = union qwe {
/*                    24 */    struct tuv {
/*      0      |       4 */        int a1;
/* XXX  4-byte hole      */
/*      8      |       8 */        char *a2;
/*     16      |       4 */        int a3;

                                   /* total size (bytes):   24 */
                               } fff1;
/*                    40 */    struct xyz {
/*      0      |       4 */        int f1;
/*      4      |       1 */        char f2;
/* XXX  3-byte hole      */
/*      8      |       8 */        void *f3;
/*     16      |      24 */        struct tuv {
/*     16      |       4 */            int a1;
/* XXX  4-byte hole      */
/*     24      |       8 */            char *a2;
/*     32      |       4 */            int a3;

                                       /* total size (bytes):   24 */
                                   } f4;

                                   /* total size (bytes):   40 */
                               } fff2;

                               /* total size (bytes):   40 */
                             }
</PRE></DIV>
<P>In this case, since<SPAN>&nbsp;</SPAN><CODE><FONT face="Courier New">struct tuv</FONT></CODE><SPAN>&nbsp;</SPAN>and<SPAN>&nbsp;</SPAN><CODE><FONT face="Courier New">struct xyz</FONT></CODE><SPAN>&nbsp;</SPAN>occupy the same space (because we are dealing with an union), the offset is not printed for them. However, you can still examine the offset of each of these structures&#8217; fields.</P>
<P>Another useful scenario is printing the offsets of a struct containing bitfields:</P>
<DIV class=smallexample><PRE class=smallexample>(gdb) ptype /o struct tyu
/* offset      |    size */  type = struct tyu {
/*      0:31   |       4 */    int a1 : 1;
/*      0:28   |       4 */    int a2 : 3;
/*      0: 5   |       4 */    int a3 : 23;
/*      3: 3   |       1 */    signed char a4 : 2;
/* XXX  3-bit hole       */
/* XXX  4-byte hole      */
/*      8      |       8 */    int64_t a5;
/*     16: 0   |       4 */    int a6 : 5;
/*     16: 5   |       8 */    int64_t a7 : 3;
/* XXX  7-byte padding   */

                               /* total size (bytes):   24 */
                             }
</PRE></DIV>
<P>Note how the offset information is now extended to also include the first bit of the bitfield.</P></DD></DL>