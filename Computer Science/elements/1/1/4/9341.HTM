Because the &#64257;rst user program is created by the OS&#8217;s main thread, the OS&#8217;s main thread must have a PCB, even though it is not a process and will never run user-level code. 
<P></P>
<P>OS &#30340;&#20027;&#32447;&#31243;&#24517;&#39035;&#35201;&#26377;&#19968;&#20010; PCB&#65288;&#23613;&#31649;&#23427;&#19981;&#26159;&#36827;&#31243;&#20063;&#27704;&#36828;&#19981;&#20250;&#36816;&#34892;&#29992;&#25143;&#32423;&#20195;&#30721;&#65289;</P>
<P><SPAN class=extract>OS &#20027;&#32447;&#31243;&#26377;&#27809;&#26377; PCB&#65311;&#26377;</SPAN></P>
<P>This is because our implementation of process_wait and process_execute require the parent &#8220;process&#8221; to have access to a list of all child process&#8217; completion statuses. So, in the userprog_init function, we give the OS&#8217;s main thread a (minimal) PCB so that it can successfully execute those functions. Right now, it&#8217;s only possible that the main thread tries to access the children list in those functions. However, if you modify those functions so that the main thread must access another member of <STRONG>struct process</STRONG>, you must initialize that member in <STRONG>userprog_init</STRONG> in <STRONG>userprog/process.c</STRONG>.