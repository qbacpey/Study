<STRONG><FONT style="BACKGROUND-COLOR: #7be1e1" color=blue>Operating Systems: Principles and Practice (Second Edition) Volume II : </FONT></STRONG>
<H3 class=sectionHead><FONT style="BACKGROUND-COLOR: #7be1e1"><SPAN class=headers>Title:</SPAN></B><SPAN class=RefText> Operating Systems: Principles and Practice (Second Edition) Volume II : 4. Concurrency and Threads : 4.4 Thread Data Structures and Life Cycle</SPAN></FONT></FONT></H3></A><FONT style="BACKGROUND-COLOR: #7be1e1">As we have seen, each thread represents a sequential stream of execution. <SPAN class=extract>The operating system provides the illusion that each thread runs on its own virtual processor by transparently suspending and resuming threads. For the illusion to work, the operating system must precisely save and restore the state of a thread.</SPAN> <SPAN class=extract>However, because threads run either in a process or in the kernel, there is also <EM>shared</EM> state that is not saved or restored when switching the processor between threads</SPAN>. </FONT>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">Thus, to understand how the operating system implements the thread abstraction, we must define both the per-thread state and the state that is shared among threads. Then we can describe a thread&#8217;s life cycle &#8212; how the operating system can create, start, stop, and delete threads to provide the abstraction. </FONT><A id=x1-190018 name=x1-190018></A></P><FONT style="BACKGROUND-COLOR: #7be1e1">
<HR>
</FONT>
<CENTER><FONT style="BACKGROUND-COLOR: #7be1e1"><img alt="" src="file:///[PrimaryStorage]Images/image00392.gif" data-calibre-src="OEBPS/Images/image00392.gif"> </FONT></CENTER>
<TABLE cellPadding=10>
<TBODY>
<TR>
<TD align=left>
<P class=caption width=0><FONT style="BACKGROUND-COLOR: #7be1e1"><B>Figure&nbsp;4.8: </B>A multi-threaded process or operating system kernel has both <EM>per-thread state</EM> and <EM>shared state</EM>. The thread control block stores the per-thread state: the current state of the thread&#8217;s computation (e.g., saved processor registers and a pointer to the stack) and metadata needed to manage the thread (e.g., the thread&#8217;s ID, scheduling priority, owner, and resource consumption). Shared state includes the program&#8217;s code, global static variables, and the heap.</FONT></P></TD></TR></TBODY></TABLE><FONT style="BACKGROUND-COLOR: #7be1e1">
<HR>
</FONT><A id=x1-19002r34 name=x1-19002r34></A>
<H4 class=subsectionHead><FONT style="BACKGROUND-COLOR: #7be1e1">4.4.1 </FONT><A id=x1-200001 name=x1-200001></A><FONT style="BACKGROUND-COLOR: #7be1e1">Per-Thread State and Thread Control Block (TCB)</FONT></H4><FONT style="BACKGROUND-COLOR: #7be1e1">The operating system needs a data structure to represent a thread&#8217;s state; a thread is like any other object in this regard. This data structure is called the <EM><A data-9uzdtcnnj6xqoalwmdp3qa='{"name": "OEBPS/Text/part0000.xhtml", "frag": "glo:thread control block"}'>thread control block</A></EM> (TCB). For every thread the operating system creates, it creates one TCB. </FONT>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">The thread control block holds two types of per-thread information: </FONT></P>
<OL class=enumerate1>
<LI class=enumerate><A id=x1-20002x1 name=x1-20002x1></A>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">The state of the computation being performed by the thread. </FONT></P>
<LI class=enumerate><A id=x1-20004x2 name=x1-20004x2></A>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">Metadata about the thread that is used to manage the thread.</FONT></P></LI></OL>
<P><FONT style="BACKGROUND-COLOR: #7be1e1"><B>Per-thread Computation State.</B> To create multiple threads and to be able to start and stop each thread as needed, the operating system must allocate space in the TCB for the current state of each thread&#8217;s computation: a pointer to the thread&#8217;s stack and a copy of its processor registers. </FONT></P>
<UL class=itemize1>
<LI class=itemize>
<P><FONT style="BACKGROUND-COLOR: #7be1e1"><B>Stack.</B> A thread&#8217;s stack is the same as the stack for a single-threaded computation &#8212; it stores information needed by the nested procedures the thread is currently running. For example, if a thread calls foo(), foo() calls bar(), and bar() calls bas(), then the stack would contain a <EM><A data-9uzdtcnnj6xqoalwmdp3qa='{"name": "OEBPS/Text/part0000.xhtml", "frag": "glo:stack frame"}'>stack frame</A></EM> for each of these three procedures; each stack frame contains the local variables used by the procedure, the parameters the procedure was called with, and the return address to jump to when the procedure completes. </FONT></P>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">Because at any given time different threads can be in different states in their sequential computations &#8212; each can be in a different place in a different procedure called with different arguments from a different nesting of enclosing procedures &#8212; each thread needs its own stack. When a new thread is created, the operating system allocates it a new stack and stores a pointer to that stack in the thread&#8217;s TCB. </FONT></P>
<LI class=itemize>
<P><FONT style="BACKGROUND-COLOR: #7be1e1"><B>Copy of processor registers.</B> A processor&#8217;s registers include not only its general-purpose registers for storing intermediate values for ongoing computations, but they also include special-purpose registers, such as the instruction pointer and stack pointer. </FONT></P>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">To be able to suspend a thread, run another thread, and later resume the original thread, the operating system needs a place to store a thread&#8217;s registers when that thread is not actively running. In some systems, the general-purpose registers for a stopped thread are stored on the top of the stack, and the TCB contains only a pointer to the stack. In other systems, the TCB contains space for a copy of all processor registers.</FONT></P></LI></UL>
<P><FONT style="BACKGROUND-COLOR: #7be1e1"></FONT></P>
<DIV class=sidebar align=center><FONT style="BACKGROUND-COLOR: #7be1e1">
<HR>
</FONT>
<TABLE cellPadding=10>
<TBODY>
<TR>
<TD style="BACKGROUND-COLOR: #f0f0f0" align=left>
<P width=0><FONT style="BACKGROUND-COLOR: #7be1e1"><SPAN class=sidebar_name><B><I>How big a stack?</I></B></SPAN> </FONT></P>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">An implementation question for thread systems is: how large a stack should be allocated for each thread? A stack grows and shrinks as procedure calls are made and those calls return. The size of the stack must be large enough to accommodate the deepest nesting level needed during in the thread&#8217;s lifetime. With hundreds or thousands of threads, it can be wasteful to allocate more than the minimum needed. </FONT></P>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">Most modern operating systems allocate kernel stacks in physical memory, putting space at a premium. However, the maximum procedure nesting depth in the kernel is usually small. Thus, kernels typically allocate a very small fixed sized region for each thread stack, e.g., 8 KB by default in Linux on an Intel x86. The kernel stays within this bound due to an important kernel coding convention: buffers and data structures are always allocated on the heap and never as procedure local variables. Although most programming languages allow arbitrary data structures to be defined as procedure local or &#8220;automatic&#8221; &#8212; allocated when a procedure starts and de-allocated when the procedure exits &#8212; that can cause problems when the stack is of limited size. </FONT></P>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">User-level stacks are allocated in virtual memory and so there is less need for a tight space constraint. In a single threaded process, the stack is located at the top end of the address space, where it can grow nearly without bound. To catch program errors, most operating systems will trigger an error if the user program stack grows too large too quickly, as that is usually an indication of unbounded recursion, rather than something that was the programmer&#8217;s intent. </FONT></P>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">In a multi-threaded user application, it is not possible to have each stack grow without constraint. Although some programming languages, such as Google&#8217;s Go, will automatically grow the stack as needed, this is still uncommon. POSIX allows the default stack size to be library dependent (e.g., larger on a desktop machine, smaller on a smartphone). As one POSIX thread tutorial put it dryly, &#8220;Exceeding the default stack limit is often very easy to do, with the usual results: program termination and/or corrupted data.&#8221;&nbsp;[</FONT><A data-9uzdtcnnj6xqoalwmdp3qa='{"name": "OEBPS/Text/part0000.xhtml", "frag": "Xbarney"}'><FONT style="BACKGROUND-COLOR: #7be1e1">10</FONT></A><FONT style="BACKGROUND-COLOR: #7be1e1">]. Most implementations try to detect when programs exceed the default stack limit by placing a known value at the very top and bottom of the stack to serve as a guard. The guard values can be checked on every context switch; if the value changes, it is likely the thread exceeded its stack. </FONT></P>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">To support application portability, the POSIX thread standard allows the user to redefine the default stack size to whatever is needed for the correct execution of a particular program. The thread library provided with the textbook sets the default stack size to 1 MB. This is almost certainly large enough provided you adopt the kernel approach of never putting large data objects on the stack. </FONT></P>
<P><FONT style="BACKGROUND-COLOR: #7be1e1"></FONT></P></TD></TR></TBODY></TABLE><FONT style="BACKGROUND-COLOR: #7be1e1">
<HR>
</FONT></DIV>
<P><FONT style="BACKGROUND-COLOR: #7be1e1"><B>Per-thread Metadata.</B> The TCB also includes <EM>per-thread metadata</EM> &#8212; information for managing the thread. For example, each thread might have a thread ID, scheduling priority, and status (e.g., whether the thread is waiting for an event or is ready to be placed onto a processor). </FONT><A id=x1-20005r38 name=x1-20005r38></A></P>
<H4 class=subsectionHead><FONT style="BACKGROUND-COLOR: #7be1e1">4.4.2 </FONT><A id=x1-210002 name=x1-210002></A><FONT style="BACKGROUND-COLOR: #7be1e1">Shared State</FONT></H4><FONT style="BACKGROUND-COLOR: #7be1e1">As opposed to per-thread state that is allocated for each thread, some state is <EM>shared</EM> between threads running in the same process or within the operating system kernel (Figure&nbsp;</FONT><A data-9uzdtcnnj6xqoalwmdp3qa='{"name": "OEBPS/Text/part0000.xhtml", "frag": "x1-190018"}'><FONT style="BACKGROUND-COLOR: #7be1e1">4.8</FONT></A><FONT style="BACKGROUND-COLOR: #7be1e1">). In particular, program <EM>code</EM> is shared by all threads in a process, although each thread may be executing at a different place within that code. Additionally, statically allocated <EM>global variables</EM> and dynamically allocated <EM>heap variables</EM> can store information that is accessible to all threads. </FONT>
<P></P>
<DIV class=sidebar align=center><FONT style="BACKGROUND-COLOR: #7be1e1">
<HR>
</FONT>
<TABLE cellPadding=10>
<TBODY>
<TR>
<TD style="BACKGROUND-COLOR: #f0f0f0" align=left>
<P width=0><FONT style="BACKGROUND-COLOR: #7be1e1"><SPAN class=sidebar_name><B><I>Other per-thread state: Thread-local variables</I></B></SPAN> </FONT></P>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">In addition to the per-thread state that corresponds to execution state in the single-threaded case, some systems include additional <EM>thread-local variables</EM>. These variables are similar to global variables in that their scope spans different procedures, but they differ in that each thread has its own copy of these variables. </FONT></P>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">Consider these examples: </FONT></P>
<UL class=itemize1>
<LI class=itemize>
<P><FONT style="BACKGROUND-COLOR: #7be1e1"><B>Errno.</B> In UNIX, the return value of system calls is intentionally kept simple. For example, the UNIX read system call returns either the number of bytes read (if successful) or -1 (if there was a problem). Often, an application needs additional information about the cause of the error (e.g., permission error, disk offline, etc.). To provide this, the kernel sets a variable in the application memory, the errno, with a diagnostic code for the most recent system call. As UNIX originally had only one thread per process, there was no confusion: the errno referred to the most recent system call of that process. </FONT></P>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">In a multi-threaded program, however, multiple threads can perform system calls concurrently. Rather than redefine the entire UNIX system call interface for a multi-threaded environment, errno is now a macro that maps to a thread-local variable containing the error code for that thread&#8217;s most recent system call. </FONT></P>
<LI class=itemize>
<P><FONT style="BACKGROUND-COLOR: #7be1e1"><B>Heap internals.</B> Although a program&#8217;s heap is logically shared &#8212; it is acceptable for one thread to allocate an object on the heap and then pass a pointer to that object to another thread &#8212; for performance reasons heaps may internally subdivide their space into per-thread regions. The advantage of subdividing the heap is that multiple threads can each allocate objects at the same time without interfering with one another. Further, by allocating objects used by the same thread from the same memory region, cache hit rates may improve. To implement these optimizations, each subdivision of the heap has thread-local variables that track what parts of the thread-local heap are in use, what parts are free, and so on. Then, the code that allocates new memory (e.g., malloc and new) is written to use these thread-local data structures and only take memory from the shared heap if the local heap is empty.</FONT></P></LI></UL>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">Thread-local variables are often useful, but, for simplicity, the rest of our discussion focuses only on the TCB, registers, and stack as the core pieces of per-thread state. </FONT></P>
<P><FONT style="BACKGROUND-COLOR: #7be1e1"></FONT></P></TD></TR></TBODY></TABLE><FONT style="BACKGROUND-COLOR: #7be1e1">
<HR>
</FONT></DIV>
<P><FONT style="BACKGROUND-COLOR: #7be1e1"><B>WARNING</B>: Although there is an important logical division between per-thread state and shared state, the operating system typically does not enforce this division. Nothing prevents one buggy thread from accessing another thread&#8217;s (conceptually private) per-thread state. Writing to a bad pointer in one thread can corrupt the stack of another. Or a careless programmer might pass a pointer to a local variable on one thread&#8217;s stack to another thread, giving the second thread a pointer to a stack location whose contents may change as the first thread calls and returns from various procedures. Or the first thread can exit after handing out a pointer to a variable on its stack; the heap will reassign that memory to an unrelated purpose. Because these bugs can depend on the specific interleavings of the threads&#8217; executions, they can be extremely hard to locate and correct. </FONT></P>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">To avoid unexpected behaviors, it is therefore important when writing multi-threaded programs to know which variables are designed to be shared across threads (global variables, objects on the heap) and which are designed to be private (local/automatic variables). </FONT><A id=x1-21001r36 name=x1-21001r36></A></P><A id=x1-220005 name=x1-220005><BR><BR><FONT style="BACKGROUND-COLOR: #7be1e1">