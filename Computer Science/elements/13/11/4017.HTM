In general, the compiler can't assume that particular offsets from<SPAN>&nbsp;</SPAN><CODE><FONT face="Courier New">%esp</FONT></CODE><SPAN>&nbsp;</SPAN>will result in a suitable address (because the state of<SPAN>&nbsp;</SPAN><CODE><FONT face="Courier New">%esp</FONT></CODE><SPAN>&nbsp;</SPAN>on entry to the function depends on the calling code). But, by deliberately aligning the stack pointer in this way, the compiler knows that adding any multiple of 16 bytes to the stack pointer will result in a 16-byte aligned address, which is safe for use with these SIMD instructions.
<P></P>
<P><SPAN class=extract>&#25191;&#34892;&#20160;&#20040;&#25351;&#20196;&#26174;&#24335;&#20462;&#25913;&#26632;&#25351;&#38024;&#20197;&#30830;&#20445;&#23545;&#40784; 16 &#20301;&#65311;andl FFFFFFF0, $ESP&nbsp;</SPAN></P>
<P></P>
<P><STRONG><SPAN class=extract><STRONG>&#26632;&#30340;&#22320;&#22336;&#23545;&#40784;&#38382;&#39064;&#30001;&#35841;&#26469;&#30830;&#20445;&#65311;&#32534;&#35793;&#22120;</STRONG></SPAN></STRONG></P>
<P><STRONG><SPAN class=extract><STRONG>&#32534;&#35793;&#22120;&#22914;&#20309;&#30830;&#20445;&#26632;&#22320;&#22336;&#23545;&#40784;&#65311;&#26174;&#24335;&#22320;&#20462;&#25913;&#26632;&#25351;&#38024;</STRONG></SPAN></STRONG></P>
<P><STRONG>The compiler is maintaining a 16-byte alignment of the stack pointer when a function is called, adding padding to the stack as necessary</STRONG><SPAN>. The compiler knows that the stack will always be aligned correctly, so it can emit instructions with alignment requirements without risk of triggering their fault conditions</SPAN>