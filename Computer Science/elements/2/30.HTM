<STRONG><FONT color=blue>: </FONT></STRONG>
<H3 class=sectionHead><SPAN class=headers>Title:</SPAN></B><SPAN class=RefText> 2.9 Case Study: Booting an Operating System Kernel</SPAN></FONT></A></H3>
<P>When a computer boots, it sets the machine&#8217;s program counter to start executing at a pre-determined position in memory. Since the computer is not yet running, the initial machine instructions must be fetched and executed immediately after the power is turned on before the system has had a chance to initialize its DRAM. <SPAN class=extract>Instead, systems typically use a special read-only hardware memory (Boot ROM) to store their boot instructions</SPAN>. <SPAN class=extract>On most x86 personal computers, the boot program is called the BIOS, for&#8220;Basic Input/Output System&#8221;</SPAN>. </P>
<P>There are several drawbacks to trying to store the entire kernel in ROM. The most significant problem is that the operating system would be hard to update. ROM instructions are fixed when the computer is manufactured and (except in rare cases) are never changed. If an error occurs while the BIOS is being updated, the machine can be left in a permanently unusable state &#8212; unable to boot and unable to complete the update of the BIOS. </P>
<P>By contrast, operating systems need frequent updates, as bugs and security vulnerabilities are discovered and fixed. <SPAN class=extract>This, and the fact that ROM storage is relatively slow and expensive, argues for putting only a small amount of code in the BIOS</SPAN>. <A id=x1-5000118 name=x1-5000118></A></P>
<HR>

<CENTER><img alt="" src="file:///[PrimaryStorage]Images/image00204.gif" data-calibre-src="OEBPS/Images/image00204.gif"> </CENTER>
<TABLE cellPadding=10>
<TBODY>
<TR>
<TD align=left>
<P class=caption width=0><B><SPAN class=extract><B>Figure&nbsp;2.18: </B>The boot ROM copies the bootloader image from disk into memory, and the bootloader copies the operating system kernel image from disk into memory</SPAN></B>.</P></TD></TR></TBODY></TABLE>
<HR>

<P><SPAN class=extract>Instead, the BIOS provides a level of indirection, as illustrated in Figure&nbsp;<A data-ixbpernmnjoud4qz9ktzkg='{"name": "OEBPS/Text/part0000.xhtml", "frag": "x1-5000118"}'>2.18</A>. <SPAN class=extract>The BIOS reads a fixed-size block of bytes from a fixed position on disk (or flash RAM) into memory. This block of bytes is called the <EM><A data-ixbpernmnjoud4qz9ktzkg='{"name": "OEBPS/Text/part0000.xhtml", "frag": "glo:bootloader"}'>bootloader</A></EM></SPAN>. <SPAN class=extract>Once the BIOS has copied the bootloader into memory, it jumps to the first instruction in the block. On some newer machines, the BIOS also checks that the bootloader has not been corrupted by a computer virus</SPAN>. (If a virus could change the bootloader and get the BIOS to jump to it, the virus would then be in control of the machine.) <SPAN class=extract>As a check, the bootloader is stored with a <EM><A data-ixbpernmnjoud4qz9ktzkg='{"name": "OEBPS/Text/part0000.xhtml", "frag": "glo:cryptographic signature"}'>cryptographic signature</A></EM>, a specially designed function of the bytes in a file and a private cryptographic key that allows someone with the corresponding public key to verify that an authorized entity produced the file</SPAN>. It is computationally intractable for an attacker without the private key to create a different file with a valid signature. <SPAN class=extract>The BIOS checks that the bootloader code matches the signature, verifying its authenticity</SPAN></SPAN>. </P>
<P><SPAN class=extract><SPAN class=extract><SPAN class=extract>The bootloader in turn loads the kernel into memory and jumps to it</SPAN>. <SPAN class=extract>Again, the bootloader can check the cryptographic signature of the operating system to verify that it has not been corrupted by a virus</SPAN>. <SPAN class=extract>The kernel&#8217;s executable image is usually stored in the file system</SPAN>. <SPAN class=extract>Thus, to find the bootloader, the BIOS needs to read a block of raw bytes from disk</SPAN>; <SPAN class=extract>the bootloader, in turn, needs to know how to read from the file system to find and read the operating system image</SPAN></SPAN></SPAN>. </P>
<P><SPAN class=extract>When the kernel starts running, it can initialize its data structures, including setting up the interrupt vector table to point to the various interrupt, processor exception, and system call handlers. The kernel then starts the first process, typically the user login page. To run this process, the operating system reads the code for the login program from its disk location, and jumps to the first instruction in the program, using the start process procedure described above. The login process in turn can trap into the kernel using a system call whenever it needs the kernel&#8217;s services, e.g., to render the login prompt on the screen. We discuss the system calls needed for processes to do useful work in Chapter&nbsp;<A data-ixbpernmnjoud4qz9ktzkg='{"name": "OEBPS/Text/part0000.xhtml", "frag": "x1-540003"}'>3</A></SPAN>. <A id=x1-50002r84 name=x1-50002r84></A></P><A id=x1-5100010 name=x1-5100010></A>