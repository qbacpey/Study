<H3><SPAN class=headers>Title:</SPAN></B><SPAN class=RefText> x86 Assembly Guide : Data Movement Instructions</SPAN></FONT></H3>
<P><B><SPAN class=Keyword>mov</SPAN></B><SPAN><SPAN>&nbsp;</SPAN>&#8212; Move (Opcodes: 88, 89, 8A, 8B, 8C, 8E, ...)</SPAN> </P>
<BLOCKQUOTE><SPAN class=extract>The<SPAN>&nbsp;</SPAN><SPAN class=Keyword>mov</SPAN><SPAN>&nbsp;</SPAN>instruction copies the data item referred to by its second operand (i.e. register contents, memory contents, or a constant value) into the location referred to by its first operand (i.e. a register or memory). While register-to-register moves are possible, direct memory-to-memory moves are not. In cases where memory transfers are desired, the source memory contents must first be loaded into a register, then can be stored to the destination memory address</SPAN>. <BR><FONT size=2><EM>Syntax</EM> <BR></FONT><FONT size=2><SPAN class=Keyword>mov &lt;reg&gt;,&lt;reg&gt;</SPAN> <BR></FONT><FONT size=2><SPAN class=Keyword>mov &lt;reg&gt;,&lt;mem&gt;</SPAN> <BR></FONT><FONT size=2><SPAN class=Keyword>mov &lt;mem&gt;,&lt;reg&gt;</SPAN> <BR></FONT><FONT size=2><SPAN class=Keyword>mov &lt;reg&gt;,&lt;const&gt;</SPAN> <BR></FONT><FONT size=2><SPAN class=Keyword>mov &lt;mem&gt;,&lt;const&gt;</SPAN> <BR></FONT><FONT size=2><EM>Examples</EM> <BR></FONT><FONT size=2><SPAN class=Keyword>mov eax, ebx</SPAN><SPAN>&nbsp;</SPAN>&#8212; copy the value in ebx into eax <BR></FONT><FONT size=2><SPAN class=Keyword>mov byte ptr [var], 5</SPAN><SPAN>&nbsp;</SPAN>&#8212; store the value 5 into the byte at location var</FONT> 
<P></P></BLOCKQUOTE>
<P class=page></P>
<P><SPAN class=Keyword><B>push</B></SPAN><SPAN><SPAN>&nbsp;</SPAN>&#8212; Push stack (Opcodes: FF, 89, 8A, 8B, 8C, 8E, ...)</SPAN> </P>
<BLOCKQUOTE><SPAN class=extract>The<SPAN>&nbsp;</SPAN><SPAN class=keyword>push</SPAN><SPAN>&nbsp;</SPAN>instruction places its operand onto the top of the hardware supported stack in memory. Specifically,<SPAN>&nbsp;</SPAN><SPAN class=Keyword>push</SPAN><SPAN>&nbsp;</SPAN>first decrements ESP by 4, then places its operand into the contents of the 32-bit location at address [ESP]. ESP (the stack pointer) is decremented by push since the x86 stack grows down - i.e. the stack grows from high addresses to lower addresses</SPAN>. <BR><FONT size=2><EM>Syntax</EM> <BR></FONT><FONT size=2><SPAN class=Keyword>push &lt;reg32&gt;</SPAN> <BR></FONT><FONT size=2><SPAN class=Keyword>push &lt;mem&gt;</SPAN> <BR></FONT><FONT size=2><SPAN class=Keyword>push &lt;con32&gt;</SPAN> <BR></FONT><FONT size=2><EM>Examples</EM> <BR></FONT><FONT size=2><SPAN class=Keyword>push eax</SPAN><SPAN>&nbsp;</SPAN>&#8212; push eax on the stack <BR></FONT><FONT size=2><SPAN class=Keyword>push [var]</SPAN><SPAN>&nbsp;</SPAN>&#8212; push the 4 bytes at address<SPAN>&nbsp;</SPAN><EM>var</EM><SPAN>&nbsp;</SPAN>onto the stack</FONT></BLOCKQUOTE><SPAN class=Keyword><B><SPAN class=extract>
<P><SPAN class=Keyword><B>pop</B></SPAN><SPAN><SPAN>&nbsp;</SPAN>&#8212; Pop stack</SPAN> </P>
<BLOCKQUOTE>The<SPAN>&nbsp;</SPAN><SPAN class=Keyword>pop</SPAN><SPAN>&nbsp;</SPAN>instruction removes the 4-byte data element from the top of the hardware-supported stack into the specified operand (i.e. register or memory location). It first moves the 4 bytes located at memory location<SPAN>&nbsp;</SPAN><SPAN class=Keyword>[SP]</SPAN><SPAN>&nbsp;</SPAN>into the specified register or memory location, and then increments<SPAN>&nbsp;</SPAN><SPAN class=Keyword>SP</SPAN><SPAN>&nbsp;</SPAN>by 4. <BR><FONT size=2><EM>Syntax</EM> <BR></FONT><FONT size=2><SPAN class=Keyword>pop &lt;reg32&gt;</SPAN> <BR></FONT><SPAN class=Keyword><FONT size=2>pop &lt;mem&gt;<BR></FONT></SPAN><FONT size=2><EM>Examples</EM> <BR></FONT><FONT size=2><SPAN class=Keyword>pop edi</SPAN><SPAN>&nbsp;</SPAN>&#8212; pop the top element of the stack into EDI. <BR></FONT><FONT size=2><SPAN class=Keyword>pop [ebx]</SPAN><SPAN>&nbsp;</SPAN>&#8212; pop the top element of the stack into memory at the four bytes starting at location EBX</FONT></BLOCKQUOTE>
<P></SPAN></B></SPAN><FONT size=2>.</FONT></P><SPAN class=Keyword><B><SPAN class=extract>
<P><SPAN class=Keyword><B>lea</B></SPAN><SPAN><SPAN>&nbsp;</SPAN>&#8212; Load effective address</SPAN> </P>
<BLOCKQUOTE>The<SPAN>&nbsp;</SPAN><SPAN class=Keyword>lea</SPAN><SPAN>&nbsp;</SPAN>instruction places the<SPAN>&nbsp;</SPAN><EM>address</EM><SPAN>&nbsp;</SPAN>specified by its second operand into the register specified by its first operand. Note, the<SPAN>&nbsp;</SPAN><EM>contents</EM><SPAN>&nbsp;</SPAN>of the memory location are not loaded, only the effective address is computed and placed into the register. This is useful for obtaining a pointer into a memory region. <BR><FONT size=2><EM>Syntax</EM> <BR></FONT><SPAN class=Keyword><FONT size=2>lea &lt;reg32&gt;,&lt;mem&gt;<BR></FONT></SPAN><FONT size=2><EM>Examples</EM> <BR></FONT><FONT size=2><SPAN class=Keyword>lea edi, [ebx+4*esi]</SPAN><SPAN>&nbsp;</SPAN>&#8212; the quantity EBX+4*ESI is placed in EDI. <BR></FONT><FONT size=2><SPAN class=Keyword>lea eax, [var]</SPAN><SPAN>&nbsp;</SPAN>&#8212; the value in<SPAN>&nbsp;</SPAN><EM>var</EM><SPAN>&nbsp;</SPAN>is placed in EAX. <BR></FONT><FONT size=2><SPAN class=Keyword>lea eax, [val]</SPAN><SPAN>&nbsp;</SPAN>&#8212; the value<SPAN>&nbsp;</SPAN><EM>val</EM><SPAN>&nbsp;</SPAN>is placed in EAX.</FONT></BLOCKQUOTE></SPAN></B></SPAN>