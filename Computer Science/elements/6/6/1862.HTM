<H2><SPAN class=headers>Title:</SPAN></B><SPAN class=RefText> x86 Assembly Guide : Calling Convention</SPAN></FONT></H2>
<P><SPAN>To allow separate programmers to share code and develop libraries for use by many programs, and to simplify the use of subroutines in general, programmers typically adopt a common<SPAN>&nbsp;</SPAN></SPAN><EM>calling convention</EM><SPAN>. The calling convention is a protocol about how to call and return from routines. For example, given a set of calling convention rules, a programmer need not examine the definition of a subroutine to determine how parameters should be passed to that subroutine. Furthermore, given a set of calling convention rules, high-level language compilers can be made to follow the rules, thus allowing hand-coded assembly language routines and high-level language routines to call one another.</SPAN> </P>
<P></P>
<P><SPAN>In practice, many calling conventions are possible. We will use the widely used C language calling convention. Following this convention will allow you to write assembly language subroutines that are safely callable from C (and C++) code, and will also enable you to call C library functions from your assembly language code.</SPAN> </P>
<P></P>
<P><SPAN>The C calling convention is based heavily on the use of the hardware-supported stack. It is based on the<SPAN>&nbsp;</SPAN></SPAN><SPAN class=Keyword>push</SPAN><SPAN>,<SPAN>&nbsp;</SPAN></SPAN><SPAN class=Keyword>pop</SPAN><SPAN>,<SPAN>&nbsp;</SPAN></SPAN><SPAN class=Keyword>call</SPAN><SPAN>, and<SPAN>&nbsp;</SPAN></SPAN><SPAN class=Keyword>ret</SPAN><SPAN><SPAN>&nbsp;</SPAN>instructions. Subroutine parameters are passed on the stack. Registers are saved on the stack, and local variables used by subroutines are placed in memory on the stack. The vast majority of high-level procedural languages implemented on most processors have used similar calling conventions.</SPAN> </P>
<P></P>
<P><SPAN>The calling convention is broken into two sets of rules. The first set of rules is employed by the caller of the subroutine, and the second set of rules is observed by the writer of the subroutine (the callee). It should be emphasized that mistakes in the observance of these rules quickly result in fatal program errors since the stack will be left in an inconsistent state; thus meticulous care should be used when implementing the call convention in your own subroutines.</SPAN> </P>
<P class=page></P>
<CENTER><img src="https://www.cs.virginia.edu/~evans/cs216/guides/stack-convention.png" width=500>&nbsp; 
<P><B>Stack during Subroutine Call</B> 
<P>[Thanks to Maxence Faldor for providing a correct figure and to James Peterson for finding and fixing the bug in the original version of this figure!]</CENTER>
<P>A good way to visualize the operation of the calling convention is to draw the contents of the nearby region of the stack during subroutine execution. The image above depicts the contents of the stack during the execution of a subroutine with three parameters and three local variables. The cells depicted in the stack are 32-bit wide memory locations, thus the memory addresses of the cells are 4 bytes apart. The first parameter resides at an offset of 8 bytes from the base pointer. Above the parameters on the stack (and below the base pointer), the<SPAN>&nbsp;</SPAN><SPAN class=Keyword>call</SPAN><SPAN>&nbsp;</SPAN>instruction placed the return address, thus leading to an extra 4 bytes of offset from the base pointer to the first parameter. When the<SPAN>&nbsp;</SPAN><SPAN class=Keyword>ret</SPAN><SPAN>&nbsp;</SPAN>instruction is used to return from the subroutine, it will jump to the return address stored on the stack