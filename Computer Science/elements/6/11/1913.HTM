<STRONG><FONT style="BACKGROUND-COLOR: #7be1e1" color=blue>: </FONT></STRONG>
<H3 class=sectionHead><FONT style="BACKGROUND-COLOR: #7be1e1"><SPAN class=headers>Title:</SPAN></B><SPAN class=RefText> 2.4 Implementing Safe Mode Transfer</SPAN></FONT></FONT></H3>
<P></A><FONT style="BACKGROUND-COLOR: #7be1e1">Whether transitioning from user to kernel mode or in the opposite direction, care must be taken to ensure that a buggy or malicious user program cannot corrupt the kernel. Although the basic idea is simple, the low-level implementation can be a bit complex: the processor must save its state and switch what it is doing, while executing instructions that might alter the state that it is in the process of saving. This is akin to rebuilding a car&#8217;s transmission while it barrels down the road at 60 mph. </FONT></P>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">The context switch code must be carefully crafted, and it relies on hardware support. To avoid confusion and reduce the possibility of error, most operating systems have a common sequence of instructions both for entering the kernel &#8212; whether due to interrupts, processor exceptions or system calls &#8212; and for returning to user level, again regardless of the cause. </FONT></P>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">At a minimum, this common sequence must provide: </FONT></P>
<UL class=itemize1>
<LI class=itemize>
<P><FONT style="BACKGROUND-COLOR: #7be1e1"><B>Limited entry into the kernel.</B> To transfer control to the operating system kernel, the hardware must ensure that the entry point into the kernel is one set up by the kernel. User programs cannot be allowed to jump to arbitrary locations in the kernel. For example, the kernel code for handling the read file system call first checks whether the user program has permission to do so. If not, the kernel should return an error. Without limited entry points into the kernel, a malicious program could jump immediately after the code to perform the check, allowing the program to access to anyone&#8217;s file. </FONT></P>
<LI class=itemize>
<P><FONT style="BACKGROUND-COLOR: #7be1e1"><B>Atomic changes to processor state.</B> In user mode, the program counter and stack point to memory locations in the user process; memory protection prevents the user process from accessing any memory outside of its region. In kernel mode, the program counter and stack point to memory locations in the kernel; memory protection is changed to allow the kernel to access both its own data and that of the user process. Transitioning between the two is atomic &#8212; the mode, program counter, stack, and memory protection are all changed at the same time. </FONT></P>
<LI class=itemize>
<P><FONT style="BACKGROUND-COLOR: #7be1e1"><B>Transparent, restartable execution.</B> An event may interrupt a user-level process at any point, between any instruction and the next one. For example, the processor could have calculated a memory address, loaded it into a register, and be about to store a value to that address. The operating system must be able to restore the state of the user program exactly as it was before the interrupt occurred. To the user process, an interrupt is invisible, except that the program temporarily slows down. A &#8220;hello world&#8221; program is not written to understand interrupts, but an interrupt might still occur while the program is running. </FONT></P>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">On an interrupt, the processor saves its current state to memory, temporarily defers further events, changes to kernel mode, and then jumps to the interrupt or exception handler. When the handler finishes, the steps are reversed: the processor state is restored from its saved location, with the interrupted program none the wiser. </FONT></P></LI></UL>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">With that context, we now describe the hardware and software mechanism for handling an interrupt, processor exception, or system call. Later, we reuse this same basic mechanism as a building block for implementing user-level signals. </FONT><A id=x1-40001r63 name=x1-40001r63></A></P>
<H4 class=subsectionHead><FONT style="BACKGROUND-COLOR: #7be1e1">2.4.1 </FONT><A id=x1-410001 name=x1-410001></A><FONT style="BACKGROUND-COLOR: #7be1e1">Interrupt Vector Table</FONT></H4><FONT style="BACKGROUND-COLOR: #7be1e1">When an interrupt, processor exception or system call trap occurs, the operating system must take different actions depending on whether the event is a divide-by-zero exception, a file read system call, or a timer interrupt. How does the processor know what code to run? </FONT><A id=x1-410018 name=x1-410018></A><FONT style="BACKGROUND-COLOR: #7be1e1">
<HR>
</FONT>
<CENTER><FONT style="BACKGROUND-COLOR: #7be1e1"><img alt="" src="file:///[PrimaryStorage]Images/image00196.gif" data-calibre-src="OEBPS/Images/image00196.gif"> </FONT></CENTER>
<TABLE cellPadding=10>
<TBODY>
<TR>
<TD align=left>
<P class=caption width=0><FONT style="BACKGROUND-COLOR: #7be1e1"><B>Figure&nbsp;2.8: </B>An interrupt vector table lists the kernel routines to handle various hardware interrupts, processor exceptions, and system calls.</FONT></P></TD></TR></TBODY></TABLE><FONT style="BACKGROUND-COLOR: #7be1e1">
<HR>
</FONT>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">As Figure&nbsp;</FONT><A data-ixbpernmnjoud4qz9ktzkg='{"name": "OEBPS/Text/part0000.xhtml", "frag": "x1-410018"}'><FONT style="BACKGROUND-COLOR: #7be1e1">2.8</FONT></A><FONT style="BACKGROUND-COLOR: #7be1e1"> illustrates, the processor has a special register that points to an area of kernel memory called the <EM><A data-ixbpernmnjoud4qz9ktzkg='{"name": "OEBPS/Text/part0000.xhtml", "frag": "glo:interrupt vector table"}'>interrupt vector table</A></EM>. The interrupt vector table is an array of pointers, with each entry pointing to the first instruction of a different handler procedure in the kernel. An <EM><A data-ixbpernmnjoud4qz9ktzkg='{"name": "OEBPS/Text/part0000.xhtml", "frag": "glo:interrupt handler"}'>interrupt handler</A></EM> is the term used for the procedure called by the kernel on an interrupt. </FONT></P>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">The format of the interrupt vector table is processor-specific. On the x86, for example, interrupt vector table entries 0 - 31 are for different types of processor exceptions (such as divide-by-zero); entries 32 - 255 are for different types of interrupts (timer, keyboard, and so forth); and, by convention, entry 64 points to the system call trap handler. The hardware determines which hardware device caused the interrupt, whether the trap instruction was executed, or what exception condition occurred. Thus, the hardware can select the right entry from the interrupt vector table and invoke the appropriate handler. </FONT></P>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">Some other processors have a smaller number of entry points, instead putting a code indicating the cause of the interrupt into a special hardware register. In that case, the operating system software uses the code to index into the interrupt vector table. </FONT></P>
<P><FONT style="BACKGROUND-COLOR: #7be1e1"><B>EXAMPLE: </B>Why is the interrupt vector table stored in kernel rather than user memory? </FONT></P>
<P><FONT style="BACKGROUND-COLOR: #7be1e1"><B>ANSWER: </B>If the interrupt vector table could be modified by application code, the application could potentially hijack the network by directing all network interrupts to its own code. Similarly, the hardware register that points to the interrupt vector table must be a protected register that can be set only when in kernel mode. &#9633; </FONT></P>
<P><FONT style="BACKGROUND-COLOR: #7be1e1"></FONT></P>
<DIV class=sidebar align=center><FONT style="BACKGROUND-COLOR: #7be1e1">
<HR>
</FONT>
<TABLE cellPadding=10>
<TBODY>
<TR>
<TD style="BACKGROUND-COLOR: #f0f0f0" align=left>
<P width=0><FONT style="BACKGROUND-COLOR: #7be1e1"><SPAN class=sidebar_name><B><I>Multiprocessors and interrupt routing</I></B></SPAN> </FONT></P>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">On a multiprocessor, which of the various processors should take an interrupt? Some early multiprocessors dedicated a single processor (&#8220;processor 0") to handle all external interrupts. If an event required a change to what one of the other processors was doing, processor 0 could send an interprocessor interrupt to trigger that processor to switch to a new process. </FONT></P>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">For systems needing to do a large amount of input and output, such as a web server, directing all I/O through a single processor can become a bottleneck. In modern systems, interrupt routing is increasingly programmable, under control of the kernel. Each processor usually has its own hardware timer. Likewise, disk I/O events can be sent directly to the processor that requested the I/O operation rather than to a random processor. Modern processors can run substantially faster if their data is already loaded into the processor cache, versus if their code and data are in some other processor&#8217;s cache. </FONT></P>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">Efficient delivery of network I/O packets is even more challenging. A high performance server might send and receive tens of thousands of packets per second, representing thousands of different connections. From a processing perspective, it is best to deliver incoming packets to the processor responsible for handling that connection; this requires the network interface hardware to re-direct the incoming packet based on the contents of its header (e.g., the IP address and port number of the client). Recent network controllers accomplish this by supporting multiple buffer descriptor rings for the same device, choosing which ring to use, and therefore which processor to interrupt, based on the header of the arriving packet. </FONT></P>
<P><FONT style="BACKGROUND-COLOR: #7be1e1"></FONT></P></TD></TR></TBODY></TABLE><FONT style="BACKGROUND-COLOR: #7be1e1">
<HR>
</FONT></DIV><A id=x1-41002r65 name=x1-41002r65></A>
<H4 class=subsectionHead><FONT style="BACKGROUND-COLOR: #7be1e1">2.4.2 </FONT><A id=x1-420002 name=x1-420002></A><FONT style="BACKGROUND-COLOR: #7be1e1">Interrupt Stack</FONT></H4><FONT style="BACKGROUND-COLOR: #7be1e1">Where should the interrupted process&#8217;s state be saved, and what stack should the kernel&#8217;s code use? </FONT>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">On most processors, a special, privileged hardware register points to a region of kernel memory called the <EM><A data-ixbpernmnjoud4qz9ktzkg='{"name": "OEBPS/Text/part0000.xhtml", "frag": "glo:interrupt stack"}'>interrupt stack</A></EM>. When an interrupt, processor exception, or system call trap causes a context switch into the kernel, the hardware changes the stack pointer to point to the base of the kernel&#8217;s interrupt stack. The hardware automatically saves some of the interrupted process&#8217;s registers by pushing them onto the interrupt stack before calling the kernel&#8217;s handler. </FONT></P>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">When the kernel handler runs, it pushes any remaining registers onto the stack before performing its work. When returning from the interrupt, processor exception or system call trap, the reverse occurs: first, the handler pops the saved registers, and then, the hardware restores the registers it saved, returning to the point where the process was interrupted. When returning from a system call, the value of the saved program counter must be incremented so that the hardware returns to the instruction immediately <EM>after</EM> the one that caused the trap. </FONT></P>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">You might think you could use the process&#8217;s user-level stack to store its state. However, a separate, kernel-level interrupt stack is needed for two reasons. </FONT></P>
<UL class=itemize1>
<LI class=itemize>
<P><FONT style="BACKGROUND-COLOR: #7be1e1"><B>Reliability.</B> The process&#8217;s user-level stack pointer might not be a valid memory address (e.g., if the program has a bug), but the kernel handler must continue to work properly. </FONT></P>
<LI class=itemize>
<P><FONT style="BACKGROUND-COLOR: #7be1e1"><B>Security.</B> On a multiprocessor, other threads running in the same process can modify user memory during the system call. If the kernel handler stores its local variables on the user-level stack, the user program might be able to modify the kernel&#8217;s return address, potentially causing the kernel to jump to arbitrary code. </FONT></P></LI></UL>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">On a multiprocessor, each processor needs to have its own interrupt stack so that, for example, the kernel can handle simultaneous system calls and exceptions across multiple processors. For each processor, the kernel allocates a separate region of memory as that processor&#8217;s interrupt stack. </FONT><A id=x1-42001r67 name=x1-42001r67></A></P>
<H4 class=subsectionHead><FONT style="BACKGROUND-COLOR: #7be1e1">2.4.3 </FONT><A id=x1-430003 name=x1-430003></A><FONT style="BACKGROUND-COLOR: #7be1e1">Two Stacks per Process</FONT></H4><FONT style="BACKGROUND-COLOR: #7be1e1">Most operating system kernels go one step farther and allocate a kernel interrupt stack for every user-level process (and as we discuss in Chapter&nbsp;4, every thread that executes user code). When a user-level process is running, the hardware interrupt stack points to that process&#8217;s kernel stack. Note that when a process is running at user level, it is not running in the kernel so its kernel stack is empty. </FONT>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">Allocating a kernel stack per process makes it easier to switch to a new process inside an interrupt or system call handler. For example, a timer interrupt handler might decide to give the processor to a different process. Likewise, a system call might need to wait for an I/O operation to complete; in the meantime, some other process should run. With per-process stacks, to suspend a process, we store a pointer to its kernel stack in the process control block, and switch to the stack of the new process. We describe this mechanism in more detail in Chapter&nbsp;4. </FONT><A id=x1-430019 name=x1-430019></A></P><FONT style="BACKGROUND-COLOR: #7be1e1">
<HR>
</FONT>
<CENTER><FONT style="BACKGROUND-COLOR: #7be1e1"><img alt="" src="file:///[PrimaryStorage]Images/image00197.gif" data-calibre-src="OEBPS/Images/image00197.gif"> </FONT></CENTER>
<TABLE cellPadding=10>
<TBODY>
<TR>
<TD align=left>
<P class=caption width=0><FONT style="BACKGROUND-COLOR: #7be1e1"><B>Figure&nbsp;2.9: </B>In most operating systems, a process has two stacks: one for executing user code and one for kernel code. The Figure shows the kernel and user stacks for various states of a process. When a process is running in user mode, its kernel stack is empty. When a process has been preempted (ready but not running), its kernel stack will contain the user-level processor state at the point when the user process was interrupted. When a process is inside a system call waiting for I/O, the kernel stack contains the context to be resumed when the I/O completes, and the user stack contains the context to be resumed when the system call returns.</FONT></P></TD></TR></TBODY></TABLE><FONT style="BACKGROUND-COLOR: #7be1e1">
<HR>
</FONT>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">Figure&nbsp;</FONT><A data-ixbpernmnjoud4qz9ktzkg='{"name": "OEBPS/Text/part0000.xhtml", "frag": "x1-430019"}'><FONT style="BACKGROUND-COLOR: #7be1e1">2.9</FONT></A><FONT style="BACKGROUND-COLOR: #7be1e1"> summarizes the various states of a process&#8217;s user and kernel stacks: </FONT></P>
<UL class=itemize1>
<LI class=itemize>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">If the process is running on the processor in user mode, its kernel stack is empty, ready to be used for an interrupt, processor exception, or system call. </FONT></P>
<LI class=itemize>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">If the process is running on the processor in kernel mode &#8212; due to an interrupt, processor exception or system call &#8212; its kernel stack is in use, containing the saved registers from the suspended user-level computation as well as the current state of the kernel handler. </FONT></P>
<LI class=itemize>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">If the process is available to run but is waiting for its turn on the processor, its kernel stack contains the registers and state to be restored when the process is resumed. </FONT></P>
<LI class=itemize>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">If the process is waiting for an I/O event to complete, its kernel stack contains the suspended computation to be resumed when the I/O finishes.</FONT></P></LI></UL>
<P><FONT style="BACKGROUND-COLOR: #7be1e1"></FONT></P>
<DIV class=sidebar align=center><FONT style="BACKGROUND-COLOR: #7be1e1">
<HR>
</FONT>
<TABLE cellPadding=10>
<TBODY>
<TR>
<TD style="BACKGROUND-COLOR: #f0f0f0" align=left>
<P width=0><FONT style="BACKGROUND-COLOR: #7be1e1"><SPAN class=sidebar_name><B><I>UNIX and kernel stacks</I></B></SPAN> </FONT></P>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">In the original implementation of UNIX, kernel memory was at a premium; main memory was roughly one million times more expensive per byte than it is today. The initial system could run with only 50KB of main memory. Instead of allocating an entire interrupt stack per process, UNIX allocated just enough memory in the process control block to store the user-level registers saved on a mode switch. In this way, UNIX could suspend a user-level process with the minimal amount of memory. UNIX still needed a few kernel stacks: one to run the interrupt handler and one for every system call waiting for an I/O event to complete, but that is much less than one for every process. </FONT></P>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">Of course, now that memory is much cheaper, most systems keep things simple and allocate a kernel stack per process or thread. </FONT></P>
<P><FONT style="BACKGROUND-COLOR: #7be1e1"></FONT></P></TD></TR></TBODY></TABLE><FONT style="BACKGROUND-COLOR: #7be1e1">
<HR>
</FONT></DIV><A id=x1-43002r68 name=x1-43002r68></A>
<H4 class=subsectionHead><FONT style="BACKGROUND-COLOR: #7be1e1">2.4.4 </FONT><A id=x1-440004 name=x1-440004></A><FONT style="BACKGROUND-COLOR: #7be1e1">Interrupt Masking</FONT></H4><FONT style="BACKGROUND-COLOR: #7be1e1">Interrupts arrive asynchronously; the processor could be executing either user or kernel code when an interrupt arrives. In certain regions of the kernel &#8212; such as inside interrupt handlers themselves, or inside the CPU scheduler &#8212; taking an interrupt could cause confusion. If an interrupt handler is interrupted, we cannot set the stack pointer to point to the base of the kernel&#8217;s interrupt stack &#8212; doing so would obliterate the state of the first handler. </FONT>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">To simplify the kernel design, the hardware provides a privileged instruction to temporarily defer delivery of an interrupt until it is safe to do so. On the x86 and several other processors, this instruction is called <EM><A data-ixbpernmnjoud4qz9ktzkg='{"name": "OEBPS/Text/part0000.xhtml", "frag": "glo:interrupt disable"}'>disable interrupts</A></EM>. However, this is a misnomer: the interrupt is only deferred (masked), and not ignored. Once a corresponding <EM><A data-ixbpernmnjoud4qz9ktzkg='{"name": "OEBPS/Text/part0000.xhtml", "frag": "glo:interrupt enable"}'>enable interrupts</A></EM> instruction is executed, any pending interrupts are delivered to the processor. The instructions to mask and unmask interrupts must be privileged; otherwise, user code could inadvertently or maliciously disable the hardware timer, allowing the machine to freeze. </FONT></P>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">If multiple interrupts arrive while interrupts are disabled, the hardware delivers them in turn when interrupts are re-enabled. However, since the hardware has limited buffering for pending interrupts, some interrupts may be lost if interrupts are disabled for too long a period of time. Generally, the hardware will buffer one interrupt of each type; the interrupt handler is responsible for checking the device hardware to see if multiple pending I/O events need to be processed. </FONT></P>
<P><FONT style="BACKGROUND-COLOR: #7be1e1"></FONT></P>
<DIV class=sidebar align=center><FONT style="BACKGROUND-COLOR: #7be1e1">
<HR>
</FONT>
<TABLE cellPadding=10>
<TBODY>
<TR>
<TD style="BACKGROUND-COLOR: #f0f0f0" align=left>
<P width=0><FONT style="BACKGROUND-COLOR: #7be1e1"><SPAN class=sidebar_name><B><I>Interrupt handlers: top and bottom halves</I></B></SPAN> </FONT></P>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">When a machine invokes an interrupt handler because some hardware event occurred (e.g., a timer expired, a key was pressed, a network packet arrived, or a disk I/O completed), the processor hardware typically masks interrupts while the interrupt handler executes. While interrupts are disabled, another hardware event will not trigger another invocation of the interrupt handler until the interrupt is re-enabled. </FONT></P>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">Some interrupts can trigger a large amount of processing, and it is undesirable to leave interrupts masked for too long. Hardware I/O devices have a limited amount of buffering, which can lead to dropped events if interrupts are not processed in a timely fashion. For example, keyboard hardware can drop keystrokes if the keyboard buffer is full. Interrupt handlers are therefore divided into a <EM>top half </EM>and a <EM>bottom half </EM>. Unfortunately, this terminology can differ a bit from system to system; in Linux, the sense of top and bottom are reversed. In this book, we adopt the more common (non-Linux) usage. </FONT></P>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">The interrupt handler&#8217;s bottom half is invoked by the hardware and executes with interrupts masked. It is designed to complete quickly. The bottom half typically saves the state of the hardware device, resets it so that it can receive a new event, and notifies the scheduler that the top half needs to run. At this point, the bottom half is done, and it can re-enable interrupts and return to the interrupted task or (if the event is high priority) switch to the top half but with interrupts enabled. When the top half runs, it can do more general kernel tasks, such as parsing the arriving packet, delivering it to the correct user-level process, sending an acknowledgment, and so forth. The top half can also do operations that require the kernel to wait for exclusive access to shared kernel data structures, the topic of Chapter&nbsp;5. </FONT></P>
<P><FONT style="BACKGROUND-COLOR: #7be1e1"></FONT></P></TD></TR></TBODY></TABLE><FONT style="BACKGROUND-COLOR: #7be1e1">
<HR>
</FONT></DIV>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">If the processor takes an interrupt in kernel mode with interrupts enabled, it is safe to use the current stack pointer rather than resetting it to the base of the interrupt stack. This approach can recursively push a series of handlers&#8217; states onto the stack; then, as each one completes, its state is popped from the stack, and the earlier handler is resumed where it left off. </FONT><A id=x1-44001r70 name=x1-44001r70></A></P>
<H4 class=subsectionHead><FONT style="BACKGROUND-COLOR: #7be1e1">2.4.5 </FONT><A id=x1-450005 name=x1-450005></A><FONT style="BACKGROUND-COLOR: #7be1e1">Hardware Support for Saving and Restoring Registers</FONT></H4><FONT style="BACKGROUND-COLOR: #7be1e1">An interrupted process&#8217;s registers must be saved so that the process can be restarted exactly where it left off. Because the handler might change the values in those registers as it executes, the state must be saved <EM>before</EM> the handler runs. Because most instructions modify the contents of registers, the hardware typically provides special instructions to make it easier to save and restore user state. </FONT>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">To make this concrete, consider the x86 architecture. Rather than relying on handler software to do all the work, when an interrupt or trap occurs: </FONT></P>
<UL class=itemize1>
<LI class=itemize>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">If the processor is in user mode, the x86 pushes the interrupted process&#8217;s stack pointer onto the kernel&#8217;s interrupt stack and switches to the kernel stack. </FONT></P>
<LI class=itemize>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">The x86 pushes the interrupted process&#8217;s instruction pointer. </FONT></P>
<LI class=itemize>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">The x86 pushes the x86 <EM>processor status word</EM>. The processor status word includes control bits, such as whether the most recent arithmetic operation in the interrupted code resulted in a positive, negative, or zero value. This needs to be saved and restored for the correct behavior of any subsequent conditional branch instruction.</FONT></P></LI></UL>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">The hardware saves the values for the stack pointer, program counter, and processor status word <EM>before</EM> jumping through the interrupt vector table to the interrupt handler. Once the handler starts running, these values will be those of the handler, not those of the interrupted process. </FONT></P>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">Once the handler starts running, it can use the pushad (&#8220;push all double&#8221;) instruction to save the remaining registers onto the stack. This instruction saves all 32-bit x86 integer registers. On a 16-bit x86, pusha is used instead. Because the kernel does not typically perform floating point operations, those do not need to be saved unless the kernel switches to a different process. </FONT></P>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">The x86 architecture has complementary features for restoring state: a popad instruction to pop an array of integer register values off the stack into the registers and an iret (return from interrupt) instruction that loads a stack pointer, instruction pointer, and processor status word off of the stack into the appropriate processor registers. </FONT></P>
<P><FONT style="BACKGROUND-COLOR: #7be1e1"></FONT></P>
<DIV class=sidebar align=center><FONT style="BACKGROUND-COLOR: #7be1e1">
<HR>
</FONT>
<TABLE cellPadding=10>
<TBODY>
<TR>
<TD style="BACKGROUND-COLOR: #f0f0f0" align=left>
<P width=0><FONT style="BACKGROUND-COLOR: #7be1e1"><SPAN class=sidebar_name><B><I>Architectural support for fast mode switches</I></B></SPAN> </FONT></P>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">Some processor architectures are able to execute user- and kernel-mode switches very efficiently, while other architectures are much slower at performing these switches. </FONT></P>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">The SPARC architecture is in the first camp. SPARC defines a set of <EM>register windows</EM> that operate like a hardware stack. Each register window includes a full set of the registers defined by the SPARC instruction set. When the processor performs a procedure call, it shifts to a new window, so the compiler never needs to save and restore registers across procedure calls, making them quite fast. (At a deep enough level of recursion, the SPARC will run out of its register windows; it then takes an exception that saves half the windows and resumes execution. Another exception occurs when the processor pops its last window, allowing the kernel to reload the saved windows.) </FONT></P>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">Mode switches can be quite fast on the SPARC. On a mode switch, the processor switches to a different register window. The kernel handler can then run, using the registers from the new window and not disturbing the values stored in the interrupted process&#8217;s copy of its registers. Unfortunately, this comes at a cost: switching between different processes is quite expensive on the SPARC, as the kernel needs to save and restore the entire register set of every active window. </FONT></P>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">The Motorola 88000 was in the second camp. The 88000 was an early pipelined architecture; now, almost all modern computers are pipelined. For improved performance, pipelined architectures execute multiple instructions at the same time. For example, one instruction is being fetched while another is being decoded, a third is completing a floating point operation, and a fourth is finishing a store to memory. When an interrupt or processor exception occurred on the 88000, the pipeline operation was suspended, and the operating system kernel was required to save and restore the entire state of the pipeline to preserve transparency to user code. </FONT></P>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">Most modern processors with deep execution pipelines, such as the x86, instead provide <EM>precise interrupts</EM>: the hardware first completes all instructions that occur, in program order, before the interrupted instruction. The hardware annuls any instruction that occurs, in program order, after the interrupt or trap, even if the instruction is in progress when the processor detects the interrupt. </FONT></P>
<P><FONT style="BACKGROUND-COLOR: #7be1e1"></FONT></P></TD></TR></TBODY></TABLE><FONT style="BACKGROUND-COLOR: #7be1e1">
<HR>
</FONT></DIV><A id=x1-45001r64 name=x1-45001r64></A><A id=x1-460005 name=x1-460005></A>