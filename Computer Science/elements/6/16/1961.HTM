<STRONG><FONT color=blue>: </FONT></STRONG><STRONG><FONT color=blue>: </FONT></STRONG>
<H3 class=sectionHead><SPAN class=headers>Title:</SPAN></B><SPAN class=RefText> 2.4 Implementing Safe Mode Transfer</SPAN></FONT></H3>
<P></A><FONT style="BACKGROUND-COLOR: #ffffff">Whether transitioning from user to kernel mode or in the opposite direction, care must be taken to ensure that a buggy or malicious user program cannot corrupt the kernel. Although the basic idea is simple, the low-level implementation can be a bit complex: the processor must save its state and switch what it is doing, while executing instructions that might alter the state that it is in the process of saving. This is akin to rebuilding a car&#8217;s transmission while it barrels down the road at 60 mph. </FONT></P><SPAN class=extract><SPAN class=extract>
<P><SPAN class=extract>The context switch code must be carefully crafted, and it relies on hardware support</SPAN>. To avoid confusion and reduce the possibility of error, most operating systems have a common sequence of instructions both for entering the kernel &#8212; whether due to interrupts, processor exceptions or system calls &#8212; and for returning to user level, again regardless of the cause. </P></SPAN></SPAN><SPAN class=extract>
<P>At a minimum, this common sequence must provide: </P>
<P></SPAN><B><SPAN class=extract><B>Limited entry into the kernel.</B> To transfer control to the operating system kernel, the hardware must ensure that the entry point into the kernel is one set up by the kernel. User programs cannot be allowed to jump to arbitrary locations in the kernel. For example, the kernel code for handling the read file system call first checks whether the user program has permission to do so. If not, the kernel should return an error. Without limited entry points into the kernel, a malicious program could jump immediately after the code to perform the check, allowing the program to access to anyone&#8217;s file. </P>
<UL class=itemize1>
<LI class=itemize>
<P></SPAN></B><B><SPAN class=extract><B>Atomic changes to processor state.</B> In user mode, the program counter and stack point to memory locations in the user process; memory protection prevents the user process from accessing any memory outside of its region. In kernel mode, the program counter and stack point to memory locations in the kernel; memory protection is changed to allow the kernel to access both its own data and that of the user process. Transitioning between the two is atomic &#8212; the mode, program counter, stack, and memory protection are all changed at the same time</SPAN></B>. </P>
<LI class=itemize>
<P><B><SPAN class=extract><B>Transparent, restartable execution.</B> An event may interrupt a user-level process at any point, between any instruction and the next one. For example, the processor could have calculated a memory address, loaded it into a register, and be about to store a value to that address. The operating system must be able to restore the state of the user program exactly as it was before the interrupt occurred. To the user process, an interrupt is invisible, except that the program temporarily slows down. A &#8220;hello world&#8221; program is not written to understand interrupts, but an interrupt might still occur while the program is running</SPAN></B>. </P>
<P><SPAN class=extract>On an interrupt, the processor saves its current state to memory, temporarily defers further events, changes to kernel mode, and then jumps to the interrupt or exception handler. When the handler finishes, the steps are reversed: the processor state is restored from its saved location, with the interrupted program none the wiser</SPAN>. </P></LI></UL>
<P>With that context, we now describe the hardware and software mechanism for handling an interrupt, processor exception, or system call. Later, we reuse this same basic mechanism as a building block for implementing user-level signals. <A id=x1-40001r63 name=x1-40001r63></A>