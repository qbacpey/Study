<H4><SPAN class=headers>Title:</SPAN></B><SPAN class=RefText> x86 Assembly Guide : Caller Rules</SPAN></FONT></H4>
<P><SPAN>To make a subrouting call, the caller should:</SPAN> </P>
<OL>
<LI>Before calling a subroutine, the caller should save the contents of certain registers that are designated<SPAN>&nbsp;</SPAN><EM>caller-saved</EM>. The caller-saved registers are EAX, ECX, EDX. Since the called subroutine is allowed to modify these registers, if the caller relies on their values after the subroutine returns, the caller must push the values in these registers onto the stack (so they can be restore after the subroutine returns. 
<LI><SPAN class=extract>To pass parameters to the subroutine, push them onto the stack before the call. The parameters should be pushed in inverted order (i.e. last parameter first). Since the stack grows down, the first parameter will be stored at the lowest address (this inversion of parameters was historically used to allow functions to be passed a variable number of parameters)</SPAN>. 
<LI><SPAN class=extract>To call the subroutine, use the<SPAN>&nbsp;</SPAN><SPAN class=Keyword>call</SPAN><SPAN>&nbsp;</SPAN>instruction. This instruction places the return address on top of the parameters on the stack, and branches to the subroutine code</SPAN>. This invokes the subroutine, which should follow the callee rules below.</LI></OL>
<P><SPAN><SPAN class=extract><SPAN>After the subroutine returns (immediately following the<SPAN>&nbsp;</SPAN></SPAN><SPAN class=Keyword>call</SPAN><SPAN><SPAN>&nbsp;</SPAN>instruction), the caller can expect to find the return value of the subroutine in the register EAX</SPAN></SPAN></SPAN><SPAN>. To restore the machine state, the caller should:</SPAN> </P>
<OL>
<LI>Remove the parameters from stack. This restores the stack to its state before the call was performed. 
<LI>Restore the contents of caller-saved registers (EAX, ECX, EDX) by popping them off of the stack. The caller can assume that no other registers were modified by the subroutine.</LI></OL>
<P><B>Example</B><SPAN></SPAN></P>
<P><SPAN>The code below shows a function call that follows the caller rules. The caller is calling a function<SPAN>&nbsp;</SPAN></SPAN><EM>_myFunc</EM><SPAN><SPAN>&nbsp;</SPAN>that takes three integer parameters. First parameter is in EAX, the second parameter is the constant 216; the third parameter is in memory location<SPAN>&nbsp;</SPAN></SPAN><EM>var</EM><SPAN>.</SPAN> </P>
<P><BR><FONT size=2>push [var] ; Push last parameter first<BR>push 216&nbsp;&nbsp; ; Push the second parameter<BR>push eax&nbsp;&nbsp; ; Push first parameter last<BR>call _myFunc ; Call the function (assume C naming)<BR>add esp, 12</FONT></P>
<P><SPAN>Note that after the call returns, the caller cleans up the stack using the<SPAN>&nbsp;</SPAN></SPAN><SPAN class=Keyword>add</SPAN><SPAN><SPAN>&nbsp;</SPAN>instruction. We have 12 bytes (3 parameters * 4 bytes each) on the stack, and the stack grows down. Thus, to get rid of the parameters, we can simply add 12 to the stack pointer.</SPAN> </P>
<P>The result produced by<SPAN>&nbsp;</SPAN><EM>_myFunc</EM><SPAN>&nbsp;</SPAN>is now available for use in the register EAX. The values of the caller-saved registers (ECX and EDX), may have been changed. If the caller uses them after the call, it would have needed to save them on the stack before the call and restore them after it