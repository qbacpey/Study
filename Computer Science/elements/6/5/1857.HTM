<H3><SPAN class=headers>Title:</SPAN></B><SPAN class=RefText> x86 Assembly Guide : Control Flow Instructions</SPAN></FONT></H3>
<P><SPAN>The x86 processor maintains an instruction pointer (IP) register that is a 32-bit value indicating the location in memory where the current instruction starts. Normally, it increments to point to the next instruction in memory begins after execution an instruction. <SPAN class=extract>The IP register cannot be manipulated directly, but is updated implicitly by provided control flow instructions</SPAN>.</SPAN> </P>
<P>We use the notation<SPAN>&nbsp;</SPAN><SPAN class=Keyword>&lt;label&gt;</SPAN><SPAN>&nbsp;</SPAN>to refer to labeled locations in the program text. Labels can be inserted anywhere in x86 assembly code text by entering a label name followed by a colon. For example,</P>
<BLOCKQUOTE><PRE>   mov esi, [ebp+8]
begin: xor ecx, ecx
       mov eax, [esi]
</PRE></BLOCKQUOTE>
<P><SPAN>The second instruction in this code fragment is labeled<SPAN>&nbsp;</SPAN></SPAN><SPAN class=Keyword>begin</SPAN><SPAN>. Elsewhere in the code, we can refer to the memory location that this instruction is located at in memory using the more convenient symbolic name<SPAN>&nbsp;</SPAN></SPAN><SPAN class=Keyword>begin</SPAN><SPAN>. <SPAN class=extract>This label is just a convenient way of expressing the location instead of its 32-bit value</SPAN>.</SPAN> </P><SPAN class=Keyword><B><SPAN class=extract>
<P><SPAN class=Keyword><B>jmp</B></SPAN><SPAN>&nbsp;</SPAN>&#8212; Jump</P>
<BLOCKQUOTE>Transfers program control flow to the instruction at the memory location indicated by the operand. <BR><FONT size=2><EM>Syntax</EM> <BR></FONT><SPAN class=Keyword><FONT size=2>jmp &lt;label&gt;<BR></FONT></SPAN><FONT size=2><EM>Example</EM> <BR></FONT><FONT size=2><SPAN class=Keyword>jmp begin</SPAN><SPAN>&nbsp;</SPAN>&#8212; Jump to the instruction labeled<SPAN>&nbsp;</SPAN><SPAN class=Keyword>begin</SPAN>.</FONT></BLOCKQUOTE></SPAN></B></SPAN><SPAN class=Keyword><B><SPAN class=extract>
<P><SPAN class=Keyword><B>j<EM>condition</EM></B></SPAN><SPAN><SPAN>&nbsp;</SPAN>&#8212; Conditional Jump</SPAN> </P>
<BLOCKQUOTE>These instructions are conditional jumps that are based on the status of a set of condition codes that are stored in a special register called the<SPAN>&nbsp;</SPAN><EM>machine status word</EM>. The contents of the machine status word include information about the last arithmetic operation performed. For example, one bit of this word indicates if the last result was zero. Another indicates if the last result was negative. Based on these condition codes, a number of conditional jumps can be performed. For example, the<SPAN>&nbsp;</SPAN><SPAN class=Keyword>jz</SPAN><SPAN>&nbsp;</SPAN>instruction performs a jump to the specified operand label if the result of the last arithmetic operation was zero. Otherwise, control proceeds to the next instruction in sequence. 
<P>A number of the conditional branches are given names that are intuitively based on the last operation performed being a special compare instruction,<SPAN>&nbsp;</SPAN><SPAN class=Keyword>cmp</SPAN><SPAN>&nbsp;</SPAN>(see below). For example, conditional branches such as<SPAN>&nbsp;</SPAN><SPAN class=Keyword>jle</SPAN><SPAN>&nbsp;</SPAN>and<SPAN>&nbsp;</SPAN><SPAN class=Keyword>jne</SPAN><SPAN>&nbsp;</SPAN>are based on first performing a cmp operation on the desired operands.<BR><FONT size=2><EM>Syntax</EM> <BR></FONT><FONT size=2><SPAN class=Keyword>je &lt;label&gt;</SPAN><SPAN>&nbsp;</SPAN>(jump when equal) <BR></FONT><FONT size=2><SPAN class=Keyword>jne &lt;label&gt;</SPAN><SPAN>&nbsp;</SPAN>(jump when not equal) <BR></FONT><FONT size=2><SPAN class=Keyword>jz &lt;label&gt;</SPAN><SPAN>&nbsp;</SPAN>(jump when last result was zero) <BR></FONT><FONT size=2><SPAN class=Keyword>jg &lt;label&gt;</SPAN><SPAN>&nbsp;</SPAN>(jump when greater than) <BR></FONT><FONT size=2><SPAN class=Keyword>jge &lt;label&gt;</SPAN><SPAN>&nbsp;</SPAN>(jump when greater than or equal to) <BR></FONT><FONT size=2><SPAN class=Keyword>jl &lt;label&gt;</SPAN><SPAN>&nbsp;</SPAN>(jump when less than) <BR></FONT><FONT size=2><SPAN class=Keyword>jle &lt;label&gt;</SPAN><SPAN>&nbsp;</SPAN>(jump when less than or equal to)<BR></FONT><FONT size=2><EM>Example</EM> <BR></FONT><SPAN class=Keyword><FONT size=2>cmp eax, ebx <BR></FONT><FONT size=2>jle done</FONT></SPAN></P>
<DIV class=explanation>If the contents of EAX are less than or equal to the contents of EBX, jump to the label<SPAN>&nbsp;</SPAN><EM>done</EM>. Otherwise, continue to the next instruction</DIV></BLOCKQUOTE>
<P></SPAN></B></SPAN>.</P><SPAN class=Keyword><B><SPAN class=extract>
<P><SPAN class=Keyword><B>cmp</B></SPAN><SPAN><SPAN>&nbsp;</SPAN>&#8212; Compare</SPAN> </P>
<BLOCKQUOTE>Compare the values of the two specified operands, setting the condition codes in the machine status word appropriately. This instruction is equivalent to the<SPAN>&nbsp;</SPAN><SPAN class=Keyword>sub</SPAN><SPAN>&nbsp;</SPAN>instruction, except the result of the subtraction is discarded instead of replacing the first operand. <BR><FONT size=2><EM>Syntax</EM> <BR></FONT><FONT size=2><SPAN class=Keyword>cmp &lt;reg&gt;,&lt;reg&gt;</SPAN> <BR></FONT><FONT size=2><SPAN class=Keyword>cmp &lt;reg&gt;,&lt;mem&gt;</SPAN> <BR></FONT><FONT size=2><SPAN class=Keyword>cmp &lt;mem&gt;,&lt;reg&gt;</SPAN> <BR></FONT><SPAN class=Keyword><FONT size=2>cmp &lt;reg&gt;,&lt;con&gt;<BR></FONT></SPAN><FONT size=2><EM>Example</EM> <BR></FONT><SPAN class=Keyword><FONT size=2>cmp DWORD PTR [var], 10 <BR></FONT><FONT size=2>jeq loop</FONT></SPAN> 
<DIV class=explanation>If the 4 bytes stored at location<SPAN>&nbsp;</SPAN><EM>var</EM><SPAN>&nbsp;</SPAN>are equal to the 4-byte integer constant 10, jump to the location labeled<SPAN>&nbsp;</SPAN><EM>loop</EM>.</DIV></BLOCKQUOTE></SPAN></B></SPAN><SPAN class=Keyword><B><SPAN class=extract>
<P><SPAN class=Keyword><B>call</B>,<SPAN>&nbsp;</SPAN><B>ret</B></SPAN><SPAN><SPAN>&nbsp;</SPAN>&#8212; Subroutine call and return</SPAN> </P>
<BLOCKQUOTE>These instructions implement a subroutine call and return. The<SPAN>&nbsp;</SPAN><SPAN class=Keyword>call</SPAN><SPAN>&nbsp;</SPAN>instruction first pushes the current code location onto the hardware supported stack in memory (see the<SPAN>&nbsp;</SPAN><SPAN class=Keyword>push</SPAN><SPAN>&nbsp;</SPAN>instruction for details), and then performs an unconditional jump to the code location indicated by the label operand. Unlike the simple jump instructions, the<SPAN>&nbsp;</SPAN><SPAN class=Keyword>call</SPAN><SPAN>&nbsp;</SPAN>instruction saves the location to return to when the subroutine completes. 
<P>The<SPAN>&nbsp;</SPAN><SPAN class=Keyword>ret</SPAN><SPAN>&nbsp;</SPAN>instruction implements a subroutine return mechanism. This instruction first pops a code location off the hardware supported in-memory stack (see the<SPAN>&nbsp;</SPAN><SPAN class=Keyword>pop</SPAN><SPAN>&nbsp;</SPAN>instruction for details). It then performs an unconditional jump to the retrieved code location.<BR><FONT size=2><EM>Syntax</EM> <BR></FONT><FONT size=2><SPAN class=Keyword>call &lt;label&gt;</SPAN> <BR></FONT><SPAN class=Keyword><FONT size=2>ret</FONT></SPAN></P></BLOCKQUOTE></SPAN></B></SPAN>