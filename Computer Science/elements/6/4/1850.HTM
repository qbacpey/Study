<SPAN class=Keyword><SPAN class=headers>Title:</SPAN></B><SPAN class=RefText> x86 Assembly Guide : Arithmetic and Logic Instructions</SPAN></FONT></SPAN> 
<P></P><SPAN class=Keyword><B><SPAN class=extract>
<P><SPAN class=Keyword><B>add</B></SPAN><SPAN><SPAN>&nbsp;</SPAN>&#8212; Integer Addition</SPAN> </P>
<P></P>
<BLOCKQUOTE>The<SPAN>&nbsp;</SPAN><SPAN class=Keyword>add</SPAN><SPAN>&nbsp;</SPAN>instruction adds together its two operands, storing the result in its first operand. Note, whereas both operands may be registers, at most one operand may be a memory location. <BR><FONT size=2><EM>Syntax</EM> <BR></FONT><FONT size=2><SPAN class=Keyword>add &lt;reg&gt;,&lt;reg&gt;</SPAN> <BR></FONT><FONT size=2><SPAN class=Keyword>add &lt;reg&gt;,&lt;mem&gt;</SPAN> <BR></FONT><FONT size=2><SPAN class=Keyword>add &lt;mem&gt;,&lt;reg&gt;</SPAN> <BR></FONT><FONT size=2><SPAN class=Keyword>add &lt;reg&gt;,&lt;con&gt;</SPAN> <BR></FONT><FONT size=2><SPAN class=Keyword>add &lt;mem&gt;,&lt;con&gt;</SPAN> <BR></FONT><FONT size=2><EM>Examples</EM> <BR></FONT><FONT size=2><SPAN class=Keyword>add eax, 10</SPAN><SPAN>&nbsp;</SPAN>&#8212; EAX &#8592; EAX + 10 <BR></FONT><FONT size=2><SPAN class=Keyword>add BYTE PTR [var], 10</SPAN><SPAN>&nbsp;</SPAN>&#8212; add 10 to the single byte stored at memory address var</FONT></BLOCKQUOTE>
<P></SPAN></B></SPAN><SPAN class=Keyword><B>sub</B></SPAN><SPAN><SPAN>&nbsp;</SPAN>&#8212; Integer Subtraction</SPAN> </P>
<BLOCKQUOTE>The<SPAN>&nbsp;</SPAN><SPAN class=Keyword>sub</SPAN><SPAN>&nbsp;</SPAN>instruction stores in the value of its first operand the result of subtracting the value of its second operand from the value of its first operand. As with<SPAN>&nbsp;</SPAN><SPAN class=Keyword>add <BR><FONT size=2><EM>Syntax</EM> <BR><SPAN class=Keyword>sub &lt;reg&gt;,&lt;reg&gt;</SPAN> <BR><SPAN class=Keyword>sub &lt;reg&gt;,&lt;mem&gt;</SPAN> <BR><SPAN class=Keyword>sub &lt;mem&gt;,&lt;reg&gt;</SPAN> <BR><SPAN class=Keyword>sub &lt;reg&gt;,&lt;con&gt;</SPAN> <BR><SPAN class=Keyword>sub &lt;mem&gt;,&lt;con&gt;</SPAN> <BR><EM>Examples</EM> <BR><SPAN class=Keyword>sub al, ah</SPAN><SPAN>&nbsp;</SPAN>&#8212; AL &#8592; AL - AH <BR><SPAN class=Keyword>sub eax, 216</SPAN><SPAN>&nbsp;</SPAN>&#8212; subtract 216 from the value stored in EAX</FONT></SPAN></BLOCKQUOTE><SPAN class=Keyword><B><SPAN class=extract>
<P><SPAN class=Keyword><B>inc, dec</B></SPAN><SPAN><SPAN>&nbsp;</SPAN>&#8212; Increment, Decrement</SPAN> </P>
<BLOCKQUOTE>The<SPAN>&nbsp;</SPAN><SPAN class=Keyword>inc</SPAN><SPAN>&nbsp;</SPAN>instruction increments the contents of its operand by one. The<SPAN>&nbsp;</SPAN><SPAN class=Keyword>dec</SPAN><SPAN>&nbsp;</SPAN>instruction decrements the contents of its operand by one. <BR><FONT size=2><EM>Syntax</EM> <BR></FONT><FONT size=2><SPAN class=Keyword>inc &lt;reg&gt;</SPAN> <BR></FONT><FONT size=2><SPAN class=Keyword>inc &lt;mem&gt;</SPAN> <BR></FONT><FONT size=2><SPAN class=Keyword>dec &lt;reg&gt;</SPAN> <BR></FONT><SPAN class=Keyword><FONT size=2>dec &lt;mem&gt;<BR></FONT></SPAN><FONT size=2><EM>Examples</EM> <BR></FONT><FONT size=2><SPAN class=Keyword>dec eax</SPAN><SPAN>&nbsp;</SPAN>&#8212; subtract one from the contents of EAX. <BR></FONT><FONT size=2><SPAN class=Keyword>inc DWORD PTR [var]</SPAN><SPAN>&nbsp;</SPAN>&#8212; add one to the 32-bit integer stored at location<SPAN>&nbsp;</SPAN><EM>var</EM></FONT></BLOCKQUOTE></SPAN></B></SPAN><SPAN class=Keyword><B><SPAN class=extract>
<P><SPAN class=Keyword><B>imul</B></SPAN><SPAN><SPAN>&nbsp;</SPAN>&#8212; Integer Multiplication</SPAN> </P>
<BLOCKQUOTE>The<SPAN>&nbsp;</SPAN><SPAN class=Keyword>imul</SPAN><SPAN>&nbsp;</SPAN>instruction has two basic formats: two-operand (first two syntax listings above) and three-operand (last two syntax listings above). 
<P></P>The two-operand form multiplies its two operands together and stores the result in the first operand. The result (i.e. first) operand must be a register. 
<P></P>The three operand form multiplies its second and third operands together and stores the result in its first operand. Again, the result operand must be a register. Furthermore, the third operand is restricted to being a constant value. <BR><FONT size=2><EM>Syntax</EM> <BR></FONT><FONT size=2><SPAN class=Keyword>imul &lt;reg32&gt;,&lt;reg32&gt;</SPAN> <BR></FONT><FONT size=2><SPAN class=Keyword>imul &lt;reg32&gt;,&lt;mem&gt;</SPAN> <BR></FONT><FONT size=2><SPAN class=Keyword>imul &lt;reg32&gt;,&lt;reg32&gt;,&lt;con&gt;</SPAN> <BR></FONT><FONT size=2><SPAN class=Keyword>imul &lt;reg32&gt;,&lt;mem&gt;,&lt;con&gt;</SPAN> <BR></FONT><FONT size=2><EM>Examples</EM> <BR></FONT><FONT size=2><SPAN class=Keyword>imul eax, [var]</SPAN><SPAN>&nbsp;</SPAN>&#8212; multiply the contents of EAX by the 32-bit contents of the memory location<SPAN>&nbsp;</SPAN><EM>var</EM>. Store the result in EAX.<BR></FONT><FONT size=2><SPAN class=Keyword>imul esi, edi, 25</SPAN><SPAN>&nbsp;</SPAN>&#8212; ESI &#8594; EDI * 25</FONT></BLOCKQUOTE></SPAN></B></SPAN><SPAN class=Keyword><B><SPAN class=extract>
<P><SPAN class=Keyword><B>idiv</B></SPAN><SPAN><SPAN>&nbsp;</SPAN>&#8212; Integer Division</SPAN> </P>
<BLOCKQUOTE>The<SPAN>&nbsp;</SPAN><SPAN class=Keyword>idiv</SPAN><SPAN>&nbsp;</SPAN>instruction divides the contents of the 64 bit integer EDX:EAX (constructed by viewing EDX as the most significant four bytes and EAX as the least significant four bytes) by the specified operand value. The quotient result of the division is stored into EAX, while the remainder is placed in EDX. <BR><FONT size=2><EM>Syntax</EM> <BR></FONT><FONT size=2><SPAN class=Keyword>idiv &lt;reg32&gt;</SPAN> <BR></FONT><SPAN class=Keyword><FONT size=2>idiv &lt;mem&gt;<BR></FONT></SPAN><EM><FONT size=2>Examples<BR></FONT></EM><FONT size=2><SPAN class=Keyword>idiv ebx</SPAN><SPAN>&nbsp;</SPAN>&#8212; divide the contents of EDX:EAX by the contents of EBX. Place the quotient in EAX and the remainder in EDX.<BR></FONT><FONT size=2><SPAN class=Keyword>idiv DWORD PTR [var]</SPAN><SPAN>&nbsp;</SPAN>&#8212; divide the contents of EDX:EAX by the 32-bit value stored at memory location<SPAN>&nbsp;</SPAN><EM>var</EM>. Place the quotient in EAX and the remainder in EDX</FONT></BLOCKQUOTE>
<P></SPAN></B></SPAN><FONT size=2>.</FONT></P><SPAN class=Keyword><B><SPAN class=extract>
<P><SPAN class=Keyword><B>and, or, xor</B></SPAN><SPAN><SPAN>&nbsp;</SPAN>&#8212; Bitwise logical and, or and exclusive or</SPAN> </P>
<BLOCKQUOTE>These instructions perform the specified logical operation (logical bitwise and, or, and exclusive or, respectively) on their operands, placing the result in the first operand location. <BR><FONT size=2><EM>Syntax</EM> <BR></FONT><FONT size=2><SPAN class=Keyword>and &lt;reg&gt;,&lt;reg&gt;</SPAN> <BR></FONT><FONT size=2><SPAN class=Keyword>and &lt;reg&gt;,&lt;mem&gt;</SPAN> <BR></FONT><FONT size=2><SPAN class=Keyword>and &lt;mem&gt;,&lt;reg&gt;</SPAN> </FONT></BLOCKQUOTE>
<P></SPAN></B></SPAN><FONT size=2><BR></FONT><FONT size=2><SPAN class=Keyword>and &lt;reg&gt;,&lt;con&gt;</SPAN> <BR></FONT><FONT size=2><SPAN class=Keyword>and &lt;mem&gt;,&lt;con&gt;</SPAN> <BR></FONT><FONT size=2><SPAN class=Keyword>or &lt;reg&gt;,&lt;reg&gt;</SPAN> <BR></FONT><FONT size=2><SPAN class=Keyword>or &lt;reg&gt;,&lt;mem&gt;</SPAN> <BR></FONT><FONT size=2><SPAN class=Keyword>or &lt;mem&gt;,&lt;reg&gt;</SPAN> <BR></FONT><FONT size=2><SPAN class=Keyword>or &lt;reg&gt;,&lt;con&gt;</SPAN> <BR></FONT><FONT size=2><SPAN class=Keyword>or &lt;mem&gt;,&lt;con&gt;</SPAN> <BR></FONT><FONT size=2><SPAN class=Keyword>xor &lt;reg&gt;,&lt;reg&gt;</SPAN> <BR></FONT><FONT size=2><SPAN class=Keyword>xor &lt;reg&gt;,&lt;mem&gt;</SPAN> <BR></FONT><FONT size=2><SPAN class=Keyword>xor &lt;mem&gt;,&lt;reg&gt;</SPAN> <BR></FONT><FONT size=2><SPAN class=Keyword>xor &lt;reg&gt;,&lt;con&gt;</SPAN> <BR></FONT><FONT size=2><SPAN class=Keyword>xor &lt;mem&gt;,&lt;con&gt;</SPAN> <BR></FONT><FONT size=2><EM>Examples</EM> <BR></FONT><FONT size=2><SPAN class=Keyword>and eax, 0fH</SPAN><SPAN>&nbsp;</SPAN>&#8212; clear all but the last 4 bits of EAX. <BR></FONT><FONT size=2><SPAN class=Keyword>xor edx, edx</SPAN><SPAN>&nbsp;</SPAN>&#8212; set the contents of EDX to zero.</FONT></P><SPAN class=Keyword><B><SPAN class=extract>
<P><SPAN class=Keyword><B>not</B></SPAN><SPAN><SPAN>&nbsp;</SPAN>&#8212; Bitwise Logical Not</SPAN> </P>
<BLOCKQUOTE>Logically negates the operand contents (that is, flips all bit values in the operand). <BR><FONT size=2><EM>Syntax</EM> <BR></FONT><FONT size=2><SPAN class=Keyword>not &lt;reg&gt;</SPAN> <BR></FONT><SPAN class=Keyword><FONT size=2>not &lt;mem&gt;<BR></FONT></SPAN><FONT size=2><EM>Example</EM> <BR></FONT><FONT size=2><SPAN class=Keyword>not BYTE PTR [var]</SPAN><SPAN>&nbsp;</SPAN>&#8212; negate all bits in the byte at the memory location<SPAN>&nbsp;</SPAN><EM>var</EM>.</FONT></BLOCKQUOTE></SPAN></B></SPAN>
<P class=page></P><SPAN class=Keyword><B><SPAN class=extract>
<P><SPAN class=Keyword><B>neg</B></SPAN><SPAN><SPAN>&nbsp;</SPAN>&#8212; Negate</SPAN> </P>
<BLOCKQUOTE>Performs the two's complement negation of the operand contents. <BR><FONT size=2><EM>Syntax</EM> <BR></FONT><FONT size=2><SPAN class=Keyword>neg &lt;reg&gt;</SPAN> <BR></FONT><SPAN class=Keyword><FONT size=2>neg &lt;mem&gt;<BR></FONT></SPAN><FONT size=2><EM>Example</EM> <BR></FONT><FONT size=2><SPAN class=Keyword>neg eax</SPAN><SPAN>&nbsp;</SPAN>&#8212; EAX &#8594; - EAX</FONT></BLOCKQUOTE></SPAN></B></SPAN><SPAN class=Keyword><B><SPAN class=extract>
<P><SPAN class=Keyword><B>shl, shr</B></SPAN><SPAN><SPAN>&nbsp;</SPAN>&#8212; Shift Left, Shift Right</SPAN> </P>
<BLOCKQUOTE>
<P>These instructions shift the bits in their first operand's contents left and right, padding the resulting empty bit positions with zeros. The shifted operand can be shifted up to 31 places. The number of bits to shift is specified by the second operand, which can be either an 8-bit constant or the register CL. In either case, shifts counts of greater then 31 are performed modulo 32. <BR><FONT size=2><EM>Syntax</EM> <BR></FONT><FONT size=2><SPAN class=Keyword>shl &lt;reg&gt;,&lt;con8&gt;</SPAN> <BR></FONT><FONT size=2><SPAN class=Keyword>shl &lt;mem&gt;,&lt;con8&gt;</SPAN> <BR></FONT><FONT size=2><SPAN class=Keyword>shl &lt;reg&gt;,&lt;cl&gt;</SPAN> <BR></FONT><SPAN class=Keyword><FONT size=2>shl &lt;mem&gt;,&lt;cl&gt;<BR></FONT></SPAN><FONT size=2><SPAN class=Keyword>shr &lt;reg&gt;,&lt;con8&gt;</SPAN> <BR></FONT><FONT size=2><SPAN class=Keyword>shr &lt;mem&gt;,&lt;con8&gt;</SPAN> <BR></FONT><FONT size=2><SPAN class=Keyword>shr &lt;reg&gt;,&lt;cl&gt;</SPAN> <BR></FONT><SPAN class=Keyword><FONT size=2>shr &lt;mem&gt;,&lt;cl&gt;<BR></FONT></SPAN><FONT size=2><EM>Examples</EM> <BR></FONT><FONT size=2><SPAN class=Keyword>shl eax, 1</SPAN><SPAN>&nbsp;</SPAN>&#8212; Multiply the value of EAX by 2 (if the most significant bit is 0)<BR></FONT><FONT size=2><SPAN class=Keyword>shr ebx, cl</SPAN><SPAN>&nbsp;</SPAN>&#8212; Store in EBX the floor of result of dividing the value of EBX by 2<SUP><EM>n</EM></SUP><SPAN>&nbsp;</SPAN>where<EM>n</EM><SPAN>&nbsp;</SPAN>is the value in CL.</FONT></P></BLOCKQUOTE></SPAN></B></SPAN>