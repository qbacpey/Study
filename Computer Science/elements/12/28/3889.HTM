<STRONG><FONT color=blue>Operating Systems: Principles and Practice (Second Edition) Volume II : 4. Concurrency and Threads : </FONT></STRONG>
<H4 class=subsectionHead><SPAN class=headers>Title:</SPAN></B><SPAN class=RefText> 4.2.2 Why &#8220;Unpredictable Speed&#8221;?</SPAN></FONT></H4><SPAN class=extract>
<P>It may seem strange to require programmers to assume that a thread&#8217;s virtual processor runs at an unpredictable speed and that any interleaving with other threads is possible.</P>
<P>&#31243;&#24207;&#21592;&#24517;&#39035;&#20551;&#35774;&#32447;&#31243;&#25191;&#34892;&#26102;&#25152;&#20351;&#29992;&#30340;&#34394;&#25311;&#22788;&#29702;&#22120;&#20197;&#20219;&#20309;&#21487;&#33021;&#30340;&#36895;&#24230;&#25191;&#34892;&#65292;&#21516;&#26102;&#20063;&#38656;&#35201;&#20551;&#35774;&#20219;&#20309;&#21487;&#33021;&#20986;&#29616;&#30340;&#32447;&#31243;&#31359;&#25554;&#24773;&#20917;</P></SPAN>
<P>&nbsp;Surely, the programmer should be able to take advantage of the fact that some interleavings are more likely than others? </P>
<P><SPAN class=extract>The thread programming model adopts this assumption as a way to guide programmers when reasoning about correctness. Rather than assuming that one thread runs at the same speed as another (or faster or slower) and trying to write programs that coordinate threads based on their relative speed of execution, multi-threaded programs should make no assumptions about the behavior of the thread scheduler.</SPAN> In turn, the kernel&#8217;s scheduling decisions &#8212; when to assign a thread to a processor, and when to preempt it for a different thread &#8212; can be made without worrying whether they might affect program correctness. </P><SPAN class=extract>
<P>If threads are completely independent of each other, sharing no memory or other resources, then the order of execution will not matter &#8212; any schedule will produce the same output as any other. Most multi-threaded programs share data structures, however. In this case, as Chapter&nbsp;<A data-9uzdtcnnj6xqoalwmdp3qa='{"name": "OEBPS/Text/part0000.xhtml", "frag": "x1-390005"}'>5</A> describes, the programmer must use explicit synchronization to ensure program correctness regardless of the possible interleaving of instructions of different threads. </P>
<P>&#32771;&#34385;&#21040;&#32447;&#31243;&#38388;&#24448;&#24448;&#20849;&#20139;&#25968;&#25454;&#32467;&#26500;&#65292;&#22240;&#27492;&#31243;&#24207;&#21592;&#24517;&#39035;&#26174;&#24335;&#22320;&#36827;&#34892;&#21516;&#27493;&#65292;&#20174;&#32780;&#22312;&#20219;&#20309;&#21487;&#33021;&#30340;&#12289;&#20114;&#24322;&#30340;&#32447;&#31243;&#31359;&#25554;&#24773;&#20917;&#20013;&#37117;&#33021;&#20445;&#35777;&#31243;&#24207;&#33021;&#22815;&#27491;&#30830;&#22320;&#36816;&#34892;</P></SPAN>
<P>Even if we could ignore the issue of scheduling &#8212; e.g., if there are more processors than threads so that each thread is assigned its own physical processor &#8212; the physical reality is that the relative execution speed of different threads can be significantly affected by factors outside their control. An extreme example is that the programmer may be debugging one thread by single-stepping it, while other threads run at full speed on other processors. </P><SPAN class=extract>
<P>If the programmer is to have any hope of understanding concurrent program behavior, the program&#8217;s correctness cannot depend on which threads are being observed. </P>
<P>&#22914;&#26524;&#31243;&#24207;&#21592;&#24819;&#35201;&#29702;&#35299;&#26576;&#20010;&#24182;&#34892;&#31243;&#24207;&#30340;&#25191;&#34892;&#36807;&#31243;&#65292;&#37027;&#20040;&#36825;&#20010;&#24182;&#34892;&#31243;&#24207;&#30340;&#34892;&#20026;&#23601;&#19981;&#33021;&#20381;&#36182;&#20110;&#35813;&#31243;&#24207;&#30340;&#21738;&#19968;&#20010;&#32447;&#31243;&#27491;&#22312;&#34987;&#35266;&#23519;</P></SPAN>
<P>Variability in execution speed occurs during normal operation as well. Accessing memory can stall a processor for hundreds or thousands of cycles if a cache miss occurs. Other factors include how frequently the scheduler preempts the thread, how many physical processors are present on a machine, how large the caches are, how fast the memory is, how the energy-saving firmware adjusts the processors&#8217; clock speeds, what network messages arrive, or what input is received from the user. Execution speeds for the different threads of a program are hard to predict, can vary on different hardware, and can even vary from run to run on the same hardware. </P><SPAN class=extract>
<P>As a result, we must coordinate thread actions through explicit synchronization rather than by trying to reason about their relative speed. </P>
<P>&#25105;&#20204;&#24517;&#39035;&#36890;&#36807;&#26174;&#24335;&#21516;&#27493;&#32447;&#31243;&#34892;&#20026;&#65292;&#32780;&#19981;&#26159;&#23492;&#24076;&#26395;&#20110;&#23427;&#20204;&#30340;&#30456;&#23545;&#36895;&#24230;&#26469;&#21327;&#35843;&#32447;&#31243;&#30340;&#34892;&#20026;</P></SPAN><B><SPAN class=extract>
<P><B>EXAMPLE: </B>Is a kernel interrupt handler a thread? </P>
<P><B>ANSWER: </B><B>No, an interrupt handler is not a thread.</B> A kernel interrupt handler shares some resemblance to a thread: it is a single sequence of instructions that executes from beginning to end. However, an interrupt handler is not independently schedulable: it is triggered by a hardware I/O event, rather than a decision by the thread scheduler in the kernel. Once started, the interrupt handler runs to completion, unless preempted by another (higher priority) interrupt. &#9633; <A id=x1-15001r25 name=x1-15001r25></A></P>
<P></SPAN></B><A id=x1-160003 name=x1-160003>