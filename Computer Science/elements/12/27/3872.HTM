<STRONG><FONT style="BACKGROUND-COLOR: #7be1e1" color=blue>Operating Systems: Principles and Practice (Second Edition) Volume II : </FONT></STRONG>
<H3 class=sectionHead><FONT style="BACKGROUND-COLOR: #7be1e1">4.2 Thread Abstraction</FONT></H3></A><FONT style="BACKGROUND-COLOR: #7be1e1">Thus far, we have described what a thread is and why it is useful. Before we go farther, we must define the thread abstraction and its properties more precisely. </FONT>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">A <EM><A data-9uzdtcnnj6xqoalwmdp3qa='{"name": "OEBPS/Text/part0000.xhtml", "frag": "glo:thread"}'>thread</A></EM> is <EM>a single execution sequence</EM> that represents <EM>a separately schedulable task</EM>. </FONT></P>
<UL class=itemize1>
<LI class=itemize>
<P><FONT style="BACKGROUND-COLOR: #7be1e1"><B>Single execution sequence.</B> Each thread executes a sequence of instructions &#8212; assignments, conditionals, loops, procedures, and so on &#8212; just as in the familiar sequential programming model. </FONT></P>
<LI class=itemize>
<P><FONT style="BACKGROUND-COLOR: #7be1e1"><B>Separately schedulable task.</B> The operating system can run, suspend, or resume a thread at any time. </FONT></P></LI></UL><A id=x1-13001r24 name=x1-13001r24></A>
<H4 class=subsectionHead><FONT style="BACKGROUND-COLOR: #7be1e1">4.2.1 </FONT><A id=x1-140001 name=x1-140001></A><FONT style="BACKGROUND-COLOR: #7be1e1">Running, Suspending, and Resuming Threads</FONT></H4><FONT style="BACKGROUND-COLOR: #7be1e1">Threads provide the illusion of an infinite number of processors. How does the operating system implement this illusion? It must execute instructions from each thread so that each thread makes progress, but the underlying hardware has only a limited number of processors, and perhaps only one! </FONT>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">To map an arbitrary set of threads to a fixed set of processors, operating systems include a <EM><A data-9uzdtcnnj6xqoalwmdp3qa='{"name": "OEBPS/Text/part0000.xhtml", "frag": "glo:thread scheduler"}'>thread scheduler</A></EM> that can switch between threads that are running and those that are ready but not running. For example, in the previous Figure&nbsp;</FONT><A data-9uzdtcnnj6xqoalwmdp3qa='{"name": "OEBPS/Text/part0000.xhtml", "frag": "x1-100011"}'><FONT style="BACKGROUND-COLOR: #7be1e1">4.1</FONT></A><FONT style="BACKGROUND-COLOR: #7be1e1">, a scheduler might suspend thread 1 from processor 1, move it to the list of ready threads, and then resume thread 5 by moving it from the ready list to run on processor 1. </FONT></P>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">Switching between threads is transparent to the code being executed within each thread. The abstraction makes each thread appear to be a single stream of execution; this means the programmer can pay attention to the sequence of instruction within a thread and not whether or when that sequence may be (temporarily) suspended to let another thread run. </FONT></P>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">Threads thus provide an execution model in which <EM>each thread runs on a dedicated virtual processor with unpredictable and variable speed.</EM> From the point of view of a thread&#8217;s code, each instruction appears to execute immediately after the preceding one. However, the scheduler may suspend a thread between one instruction and the next and resume running it later. It is as if the thread were running on a processor that sometimes becomes very slow. </FONT><A id=x1-140013 name=x1-140013></A></P><FONT style="BACKGROUND-COLOR: #7be1e1">
<HR>
</FONT>
<CENTER><FONT style="BACKGROUND-COLOR: #7be1e1"><img alt="" src="file:///[PrimaryStorage]Images/image00390.gif" data-calibre-src="OEBPS/Images/image00390.gif"> </FONT></CENTER>
<TABLE cellPadding=10>
<TBODY>
<TR>
<TD align=left>
<P class=caption width=0><FONT style="BACKGROUND-COLOR: #7be1e1"><B>Figure&nbsp;4.3: </B>Three possible ways that a thread might execute, all of which are equivalent to the programmer.</FONT></P></TD></TR></TBODY></TABLE><FONT style="BACKGROUND-COLOR: #7be1e1">
<HR>
</FONT>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">Figure&nbsp;</FONT><A data-9uzdtcnnj6xqoalwmdp3qa='{"name": "OEBPS/Text/part0000.xhtml", "frag": "x1-140013"}'><FONT style="BACKGROUND-COLOR: #7be1e1">4.3</FONT></A><FONT style="BACKGROUND-COLOR: #7be1e1"> illustrates a programmer&#8217;s view of a simple program and three (of many) possible ways the program might be executed, depending on what the scheduler does. From the thread&#8217;s point of view, other than the speed of execution, the alternatives are equivalent. Indeed, the thread would typically be unaware of which of these (or other) executions actually occurs. </FONT><A id=x1-140024 name=x1-140024></A></P><FONT style="BACKGROUND-COLOR: #7be1e1">
<HR>
</FONT>
<CENTER><FONT style="BACKGROUND-COLOR: #7be1e1"><img alt="" src="file:///[PrimaryStorage]Images/image00391.gif" data-calibre-src="OEBPS/Images/image00391.gif"> </FONT></CENTER>
<TABLE cellPadding=10>
<TBODY>
<TR>
<TD align=left>
<P class=caption width=0><FONT style="BACKGROUND-COLOR: #7be1e1"><B>Figure&nbsp;4.4: </B>Some of the many possible ways that three threads might be interleaved at runtime.</FONT></P></TD></TR></TBODY></TABLE><FONT style="BACKGROUND-COLOR: #7be1e1">
<HR>
</FONT>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">How threads are scheduled affects a thread&#8217;s interleavings with other threads. Figure&nbsp;</FONT><A data-9uzdtcnnj6xqoalwmdp3qa='{"name": "OEBPS/Text/part0000.xhtml", "frag": "x1-140024"}'><FONT style="BACKGROUND-COLOR: #7be1e1">4.4</FONT></A><FONT style="BACKGROUND-COLOR: #7be1e1"> shows some of the many possible interleavings of a program with three threads. Thread programmers should therefore not make any assumptions about the relative speed with which different threads execute. </FONT></P>
<P><FONT style="BACKGROUND-COLOR: #7be1e1"></FONT></P>
<DIV class=sidebar align=center><FONT style="BACKGROUND-COLOR: #7be1e1">
<HR>
</FONT>
<TABLE cellPadding=10>
<TBODY>
<TR>
<TD style="BACKGROUND-COLOR: #f0f0f0" align=left>
<P width=0><FONT style="BACKGROUND-COLOR: #7be1e1"><SPAN class=sidebar_name><B><I>Cooperative vs. preemptive multi-threading</I></B></SPAN> </FONT></P>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">Although most thread systems include a scheduler that can &#8212; at least in principle &#8212; run any thread at any time, some systems provide the abstraction of <EM>cooperative threads</EM>. In these systems, a thread runs without interruption until it explicitly relinquishes control of the processor to another thread. An advantage of cooperative multi-threading is increased control over the interleavings among threads. For example, in most cooperative multi-threading systems, only one thread runs at a time, so while a thread is running, no other thread can run and affect the system&#8217;s state. </FONT></P>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">Unfortunately, cooperative multi-threading has significant disadvantages. For example, a long-running thread can monopolize the processor, starving other threads and making the system&#8217;s user interface sluggish or non-responsive. Additionally, modern multiprocessor machines run multiple threads at a time, so one would still have to reason about the possible interactions between threads even if cooperative multi-threading were used. Thus, although cooperative multi-threading was used in some significant systems in the past, including early versions of Apple&#8217;s MacOS operating system, it is less often used today. </FONT></P>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">The alternative we describe in this book is sometimes called <EM>preemptive multi-threading</EM> since running threads can be switched at any time. Whenever the book uses the term &#8220;multi-threading,&#8221; it means preemptive multi-threading unless we explicitly state otherwise. </FONT></P>
<P><FONT style="BACKGROUND-COLOR: #7be1e1"></FONT></P></TD></TR></TBODY></TABLE><FONT style="BACKGROUND-COLOR: #7be1e1">
<HR>
</FONT></DIV><A id=x1-14003r26 name=x1-14003r26></A>
<H4 class=subsectionHead><FONT style="BACKGROUND-COLOR: #7be1e1">4.2.2 </FONT><A id=x1-150002 name=x1-150002></A><FONT style="BACKGROUND-COLOR: #7be1e1">Why &#8220;Unpredictable Speed&#8221;?</FONT></H4><FONT style="BACKGROUND-COLOR: #7be1e1">It may seem strange to require programmers to assume that a thread&#8217;s virtual processor runs at an unpredictable speed and that any interleaving with other threads is possible. Surely, the programmer should be able to take advantage of the fact that some interleavings are more likely than others? </FONT>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">The thread programming model adopts this assumption as a way to guide programmers when reasoning about correctness. Rather than assuming that one thread runs at the same speed as another (or faster or slower) and trying to write programs that coordinate threads based on their relative speed of execution, multi-threaded programs should make no assumptions about the behavior of the thread scheduler. In turn, the kernel&#8217;s scheduling decisions &#8212; when to assign a thread to a processor, and when to preempt it for a different thread &#8212; can be made without worrying whether they might affect program correctness. </FONT></P>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">If threads are completely independent of each other, sharing no memory or other resources, then the order of execution will not matter &#8212; any schedule will produce the same output as any other. Most multi-threaded programs share data structures, however. In this case, as Chapter&nbsp;</FONT><A data-9uzdtcnnj6xqoalwmdp3qa='{"name": "OEBPS/Text/part0000.xhtml", "frag": "x1-390005"}'><FONT style="BACKGROUND-COLOR: #7be1e1">5</FONT></A><FONT style="BACKGROUND-COLOR: #7be1e1"> describes, the programmer must use explicit synchronization to ensure program correctness regardless of the possible interleaving of instructions of different threads. </FONT></P>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">Even if we could ignore the issue of scheduling &#8212; e.g., if there are more processors than threads so that each thread is assigned its own physical processor &#8212; the physical reality is that the relative execution speed of different threads can be significantly affected by factors outside their control. An extreme example is that the programmer may be debugging one thread by single-stepping it, while other threads run at full speed on other processors. If the programmer is to have any hope of understanding concurrent program behavior, the program&#8217;s correctness cannot depend on which threads are being observed. </FONT></P>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">Variability in execution speed occurs during normal operation as well. Accessing memory can stall a processor for hundreds or thousands of cycles if a cache miss occurs. Other factors include how frequently the scheduler preempts the thread, how many physical processors are present on a machine, how large the caches are, how fast the memory is, how the energy-saving firmware adjusts the processors&#8217; clock speeds, what network messages arrive, or what input is received from the user. Execution speeds for the different threads of a program are hard to predict, can vary on different hardware, and can even vary from run to run on the same hardware. As a result, we must coordinate thread actions through explicit synchronization rather than by trying to reason about their relative speed. </FONT></P>
<P><FONT style="BACKGROUND-COLOR: #7be1e1"><B>EXAMPLE: </B>Is a kernel interrupt handler a thread? </FONT></P>
<P><FONT style="BACKGROUND-COLOR: #7be1e1"><B>ANSWER: </B><B>No, an interrupt handler is not a thread.</B> A kernel interrupt handler shares some resemblance to a thread: it is a single sequence of instructions that executes from beginning to end. However, an interrupt handler is not independently schedulable: it is triggered by a hardware I/O event, rather than a decision by the thread scheduler in the kernel. Once started, the interrupt handler runs to completion, unless preempted by another (higher priority) interrupt. &#9633; </FONT><A id=x1-15001r25 name=x1-15001r25></A></P><A id=x1-160003 name=x1-160003><BR><BR><FONT style="BACKGROUND-COLOR: #7be1e1">