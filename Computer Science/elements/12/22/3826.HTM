<strong><font color="blue">Operating Systems: Principles and Practice (Second Edition) Volume II : </font></strong><h3 class=sectionHead>5.9 Summary and Future Directions</H3></A><FONT style="BACKGROUND-COLOR: #ffffff">This chapter advocates using a systematic, structured approach to writing multi-threaded code that shares state across threads. The approach, shared objects with concurrent access managed with locks and condition variables, has stood the test of time. Using shared objects makes reasoning about multi-threaded programs vastly simpler than it would be if we tried to reason about the possible interleavings of individual loads and stores. Further, by following a systematic approach, we make it possible for others to read, understand, maintain, and change the multi-threaded code we write. </FONT>
<P>In this chapter, we have discussed: </P>
<UL class=itemize1>
<LI class=itemize>
<P><B>Race conditions.</B> The fundamental challenge to writing multi-threaded code that uses shared data is that the behavior of the program may depend on the precise ordering of operations executed by each thread. This non-deterministic behavior is difficult to reason about, reproduce, and debug. </P>
<LI class=itemize>
<P><B>Locks and condition variables.</B> Two useful sychronization abstractions are locks, providing mutual exclusion, and condition variables, for waiting for shared state to change. </P>
<LI class=itemize>
<P><B>A methodology for writing shared objects.</B> Using locks and condition variables, we outlined a sequence of steps to writing correct synchronization code for coordinating access to shared objects. Following this methodology has proven enormously helpful for students in our classes by reducing the likelihood of design errors. </P>
<LI class=itemize>
<P><B>Implementations of synchronization.</B> Locks and condition variables can be efficiently implemented using hardware support for atomic read-modify-write instructions and, where necessary, the ability to temporarily defer hardware interrupts. In particular, we showed that the overhead of acquiring and releasing a non-contested lock can be as low as four instructions. </P>
<LI class=itemize>
<P><B>Semaphores.</B> Semaphores are a widely implemented alternative to locks and condition variables, with a constructive role in managing hardware I/O interrupts.</P></LI></UL>
<P>In short, this chapter defines a set of core skills that almost any programmer will use over and over again during the coming decade or longer. </P>
<P>That is not the whole story. As the next chapter will discuss, complex systems often include many shared objects and threads. This poses new challenges: synchronizing operations that span multiple shared objects, avoiding deadlocks in which a set of threads are all waiting for each other to do something, and maximizing performance when large numbers of threads are contending for a single object. <A id=x1-75001r122 name=x1-75001r122></A></P>
<H4 class=subsectionHead>5.9.1 <A id=x1-760001 name=x1-760001></A>Historical Notes</H4>Once researchers accepted the need to explicitly manage concurrency using threads, the challenge became how best to coordinate multi-threaded access to shared data. A large number of different abstractions were proposed, and it took some time to work out the different strengths and weaknesses of the various approaches. 
<P>Monitors &#8212; that is, managing shared data structures with locks and condition variables &#8212; were proposed in the early 1970&#8217;s in separate papers by Tony Hoare&nbsp;[<A data-9uzdtcnnj6xqoalwmdp3qa='{"name": "OEBPS/Text/part0000.xhtml", "frag": "XHoare74monitors:an"}'>83</A>] and Per Brinch Hansen&nbsp;[<A data-9uzdtcnnj6xqoalwmdp3qa='{"name": "OEBPS/Text/part0000.xhtml", "frag": "XHansen:1970:NMS:362258.362278"}'>75</A>]. One early advantage of monitors was the ability to formally prove properties about multi-threaded code; for example with Hoare-style semantics for condition variables, any statement which is true of the shared object immediately before a <TT>signal</TT>&nbsp;is also true of the object immediately after the return from <TT>wait</TT>. As we saw with the Too Much Milk example, without explicit synchronization, it can be quite difficult to reason about concurrent execution. </P>
<P>By the early 1980&#8217;s, Xerox PARC had built the first personal computer, the Alto, with all of its system software written using threads (called lightweight processes at the time) and monitors. The methodology we present in this chapter originated with that project&nbsp;[<A data-9uzdtcnnj6xqoalwmdp3qa='{"name": "OEBPS/Text/part0000.xhtml", "frag": "XLampson:1980:EPM:358818.358824"}'>98</A>]. It is hard to overstate how radical an approach this was; almost all widely used operating systems of the time, including UNIX, were built using semaphores. </P>
<P>An alternative line of work advocated completely prohibiting access by threads to shared data, as a way of eliminating race conditions. Instead of shared data, all data was private to a single thread; as a result, locks were never needed. An early example of this approach was Communicating Sequential Processes (CSP), also developed by Tony Hoare&nbsp;[<A data-9uzdtcnnj6xqoalwmdp3qa='{"name": "OEBPS/Text/part0000.xhtml", "frag": "XHoare:1978:CSP:359576.359585"}'>84</A>]. Google&#8217;s Go language for concurrent web programming is a modern language that supports both monitors and the CSP style of programming. With CSP and Go, a thread that needs to perform an operation on some other thread&#8217;s data sends it a message; the receiving thread can either reply with the result, or in data-flow style, forward the result onto some other thread. </P>
<P>While there was considerable and vigorous debate at the time as to whether message-passing or shared-memory were better models for programming concurrency, the debate was largely resolved by a simple observation made by Lauer and Needham&nbsp;[<A data-9uzdtcnnj6xqoalwmdp3qa='{"name": "OEBPS/Text/part0000.xhtml", "frag": "XLauer79onthe"}'>101</A>]. Any program using monitors can be recast into CSP using a simple transformation, and vice versa. The execution of a procedure with a monitor lock is equivalent to processing a message in CSP; a monitor is, in effect, single-threaded while it is holding the lock. Thus, the choice of which style to use is largely a matter of taste and convention, and most programmers have chosen to use threads and monitors. <A id=Q1-1-126 name=Q1-1-126></A><A id=Q1-1-127 name=Q1-1-127></A></P><A id=x1-770001 name=x1-770001>