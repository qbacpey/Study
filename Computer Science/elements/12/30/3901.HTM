<STRONG><FONT color=blue>Operating Systems: Principles and Practice (Second Edition) Volume II : 4. Concurrency and Threads : </FONT></STRONG><STRONG><FONT color=blue>Operating Systems: Principles and Practice (Second Edition) Volume II : </FONT></STRONG>
<H3 class=sectionHead>4.3 Simple Thread API</H3></A><A id=x1-160015 name=x1-160015></A>
<HR>

<P></P>
<DIV align=center>
<TABLE class=texttable border=0>
<TBODY>
<TR class=tr>
<TD class=td colSpan=2 align=left>
<P class=tabp><FONT style="BACKGROUND-COLOR: #7be1e1"></FONT></P>
<DIV class=multicolumn align=center noWrap><B><FONT style="BACKGROUND-COLOR: #7be1e1">Simple Threads API</FONT></B></DIV></TD></TR>
<TR class=tr>
<TD class=td align=left>
<P class=tabp><FONT style="BACKGROUND-COLOR: #7be1e1"></FONT></P>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">void thread_create (thread, func, arg)</FONT></P></TD>
<TD class=td align=left>
<P class=tabp><FONT style="BACKGROUND-COLOR: #7be1e1"></FONT></P>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">Create a new thread, storing information about it in thread. Concurrently with the calling thread, thread executes the function func with the argument arg. </FONT></P></TD></TR>
<TR class=tr>
<TD class=td align=left>
<P class=tabp><FONT style="BACKGROUND-COLOR: #7be1e1"></FONT></P></TD></TR>
<TR class=tr>
<TD class=td align=left>
<P class=tabp><FONT style="BACKGROUND-COLOR: #7be1e1"></FONT></P></TD></TR>
<TR class=tr>
<TD class=td align=left>
<P class=tabp><FONT style="BACKGROUND-COLOR: #7be1e1"></FONT></P>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">void thread_yield ()</FONT></P></TD>
<TD class=td align=left>
<P class=tabp><FONT style="BACKGROUND-COLOR: #7be1e1"></FONT></P>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">The calling thread voluntarily gives up the processor to let some other thread(s) run. The scheduler can resume running the calling thread whenever it chooses to do so.</FONT> </P></TD></TR>
<TR class=tr>
<TD class=td align=left>
<P class=tabp></P></TD></TR>
<TR class=tr>
<TD class=td align=left>
<P class=tabp></P></TD></TR>
<TR class=tr>
<TD class=td align=left>
<P class=tabp></P>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">int thread_join (thread)</FONT></P></TD>
<TD class=td align=left>
<P class=tabp><FONT style="BACKGROUND-COLOR: #7be1e1"></FONT></P>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">Wait for thread to finish if it has not already done so; then return the value passed to thread_exit by that thread. Note that thread_join may be called only once for each thread.</FONT> </P></TD></TR>
<TR class=tr>
<TD class=td align=left>
<P class=tabp></P></TD></TR>
<TR class=tr>
<TD class=td align=left>
<P class=tabp></P></TD></TR>
<TR class=tr>
<TD class=td align=left>
<P class=tabp></P>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">void thread_exit (ret)</FONT></P></TD>
<TD class=td align=left>
<P class=tabp><FONT style="BACKGROUND-COLOR: #7be1e1"></FONT></P>
<P><FONT style="BACKGROUND-COLOR: #7be1e1">Finish the current thread. Store the value ret in the current thread&#8217;s data structure. If another thread is already waiting in a call to thread_join, resume it.</FONT> </P></TD></TR>
<TR class=tr>
<TD class=td align=left>
<P class=tabp></P></TD></TR></TBODY></TABLE></DIV>
<DIV class=caption align=center>
<TABLE cellPadding=10>
<TBODY>
<TR>
<TD align=left>
<P class=caption width=0><B>Figure&nbsp;4.5: </B>Simplified API for using threads.</P></TD></TR></TBODY></TABLE></DIV>
<HR>
Figure <A data-9uzdtcnnj6xqoalwmdp3qa='{"name": "OEBPS/Text/part0000.xhtml", "frag": "x1-160015"}'>4.5</A> shows a simple API for using threads. This simplified API is based on the POSIX standard pthreads API, but it omits some POSIX options and error handling for simplicity. Most other thread packages are quite similar; if you understand how to program with this API, you will find it easy to write code with most standard thread APIs. 
<P><SPAN class=extract>&nbsp;</P>
<P>A good way to understand the simple threads API is that it provides a way to invoke an <EM><A data-9uzdtcnnj6xqoalwmdp3qa='{"name": "OEBPS/Text/part0000.xhtml", "frag": "glo:asynchronous procedure call"}'>asynchronous procedure call</A></EM>. A normal procedure call passes a set of arguments to a function, runs the function immediately on the caller&#8217;s stack, and when the function is completed, returns control back to the caller with the result. An asynchronous procedure call separates the call from the return: with thread_create, the caller starts the function, but unlike a normal procedure call, the caller continues execution concurrently with the called function. Later, the caller can wait for the function completion (with thread_join). </P>
<P>&#21487;&#20197;&#23558;&#32447;&#31243;&#29702;&#35299;&#20026;&#24322;&#27493;&#30340;&#20989;&#25968;&#35843;&#29992;&#65306;Caller &#21644; Callee &#19968;&#36215;&#36816;&#34892;</P></SPAN>
<P><SPAN class=extract>In Chapter&nbsp;3, we saw similar concepts in the UNIX process abstraction. thread_create&nbsp;is analogous to UNIX process fork and exec, while thread_join&nbsp;is analogous to UNIX process wait.</SPAN> UNIX fork creates a new process that runs concurrently with the process calling fork; UNIX exec causes that process to run a specific program. UNIX wait allows the calling process to suspend execution until the completion of the new process. <A id=x1-16002r29 name=x1-16002r29></A>