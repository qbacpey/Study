<STRONG><FONT color=blue>Operating Systems: Principles and Practice (Second Edition) Volume II : 4. Concurrency and Threads : </FONT></STRONG><STRONG><FONT color=blue>Operating Systems: Principles and Practice (Second Edition) Volume II : </FONT></STRONG>
<H3 class=sectionHead>4.1 Thread Use Cases</H3></A><FONT style="BACKGROUND-COLOR: #ffffff">The intuition behind the thread abstraction is simple: in a program, we can represent each concurrent task as a </FONT><EM>thread</EM><FONT style="BACKGROUND-COLOR: #ffffff">. Each thread provides the abstraction of sequential execution similar to the traditional programming model. In fact, we can think of a traditional program as </FONT><EM><A data-9uzdtcnnj6xqoalwmdp3qa='{"name": "OEBPS/Text/part0000.xhtml", "frag": "glo:single-threaded program"}'>single-threaded</A></EM><FONT style="BACKGROUND-COLOR: #ffffff"> with one logical sequence of steps as each instruction follows the previous one. The program executes statements, iterates through loops, and calls/returns from procedures one after another. </FONT>
<P>A <EM><A data-9uzdtcnnj6xqoalwmdp3qa='{"name": "OEBPS/Text/part0000.xhtml", "frag": "glo:multi-threaded program"}'>multi-threaded program</A></EM> is a generalization of the same basic programming model. Each individual thread follows a single sequence of steps as it executes statements, iterates through loops, calls/returns from procedures, etc. However, a program can now have several such threads executing at the same time. </P>
<P>When is it appropriate to use multiple threads within the same program? Threads have become widely used in both operating system and application code, and based on that experience, we can identify several common themes. We illustrate these themes by describing one application in some detail, to show how and why it leverages threads. <A id=x1-110012 name=x1-110012></A></P>
<HR>

<P></P>
<CENTER><img alt="" src="file:///[PrimaryStorage]Images/image00389.gif" data-calibre-src="OEBPS/Images/image00389.gif"></CENTER>
<TABLE cellPadding=10>
<TBODY>
<TR>
<TD align=left>
<P class=caption width=0><B>Figure&nbsp;4.2: </B>In the Earth Visualizer example, two threads each draw part of the scene, a third thread manages the user interface widgets, and a fourth thread fetches new data from a remote server. Satellite Image Credit: NASA Earth Observatory.</P></TD></TR></TBODY></TABLE>
<HR>

<P><B>EXAMPLE: </B>Consider an Earth Visualizer application similar to Google Earth (<A href="http://earth.google.com/">http://earth.google.com/</A>). This application lets a user virtually fly anywhere in the world, see aerial images at different resolutions, and view other information associated with each location. A key part of the design is that the user&#8217;s controls are always operable: when the user moves the mouse to a new location, the image is redrawn in the background at successively better resolutions while the program continues to let the user adjust the view, select additional information about the location for display, or enter search terms. </P>
<P>To implement this application, as Figure&nbsp;<A data-9uzdtcnnj6xqoalwmdp3qa='{"name": "OEBPS/Text/part0000.xhtml", "frag": "x1-110012"}'>4.2</A> illustrates, the programmer might write code to draw a portion of the screen, display user interface (UI) widgets, process user inputs, and fetch higher resolution images for newly visible areas. In a sequential program, these functions would run in turn. <SPAN class=extract>With threads, they can run concurrently so that the user interface is responsive even while new data is being fetched and the screen being redrawn.</SPAN> <A id=x1-11002r1 name=x1-11002r1></A>