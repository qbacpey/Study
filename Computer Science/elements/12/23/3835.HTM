<strong><font color="blue">Operating Systems: Principles and Practice (Second Edition) Volume II : </font></strong><h3 class=sectionHead>6.7 Summary and Future Directions</H3></A><FONT style="BACKGROUND-COLOR: #ffffff">Advanced synchronization techniques should be approached with caution. Your first goal should be to construct a program that works, even if doing so means putting &#8220;one big lock&#8221; around everything in a data structure or even in an entire program. </FONT>
<P>Resist the temptation to do anything more complicated unless you <B>know</B> that doing so is necessary. How do you know? Do not guess. Measure your system&#8217;s performance. Measuring the &#8220;before&#8221; and &#8220;after&#8221; performance of a program and its subsystems not only helps you make good decisions about the program on which you are working, but it also helps you develop good intuition for the programs you write in the future. </P>
<P>Spend time early in the design process developing a clean structure for your program. Given that issues with multi-object synchronization often blur module boundaries, it is vital to have an overall structure that lets you reason about how the different pieces of your program will interact. Strive for a strict layering or hierarchy of modules. It is easier to make such programs deadlock-free, and it is easier to test them as well. </P>
<P>Although performance is important, it is usually easier to start with a clean, simple, and correct design, measure it to identify its bottlenecks, and then optimize the bottlenecks than to start with a complex design and try to tune its performance, let alone fix its bugs. </P>
<P>In this chapter, we have presented a set of conceptual tools and techniques for managing complex, multi-object concurrent programs. We have addressed: estimating the impact of locks on multiprocessor performance, design patterns to reduce contention for locks, implementation techniques such as MCS and RCU for high-contention locks, strategies for achieving atomicity across multiple operations on the same object or across objects, and algorithms for deadlock prevention and recovery. </P>
<P>Yet, writing concurrent programs remains frustratingly complex. We believe that an important area for future work will be to develop better tools for managing and reducing that complexity. The last decade has seen the development of a new generation of tools for helping programmers improve software reliability, by automatically identifying test coverage, memory leaks, reuse of de-allocated data, buffer overflows, and bad pointer arithmetic. </P>
<P>Extending this approach to concurrent programs is a grand challenge. A promising avenue is to use automated tools for detecting memory races; a well-written program should have no reads or writes to shared memory without holding the lock that protects that data structure. Once a program has been shown to be without races, model checking can be used to systematically test that shared objects work for all possible thread interleavings. <A id=Q1-1-180 name=Q1-1-180></A><A id=Q1-1-181 name=Q1-1-181></A></P><A id=x1-1060007 name=x1-1060007>