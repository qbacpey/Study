<strong><font color="blue">Operating Systems: Principles and Practice (Second Edition) Volume II : </font></strong><h3 class=sectionHead>6.4 Multi-Object Atomicity</H3></A><FONT style="BACKGROUND-COLOR: #ffffff">Once a program has multiple shared objects, it becomes both necessary and challenging to reason about interactions across objects. For example, consider a system storing a bank&#8217;s accounts. A reasonable design choice might be for each customer&#8217;s account to be a shared object with a lock (either a </FONT><A data-9uzdtcnnj6xqoalwmdp3qa='{"name": "OEBPS/Text/part0000.xhtml", "frag": "x1-490003"}'>mutual exclusion lock</A><FONT style="BACKGROUND-COLOR: #ffffff"> or a </FONT><A data-9uzdtcnnj6xqoalwmdp3qa='{"name": "OEBPS/Text/part0000.xhtml", "frag": "x1-630001"}'>readers/writers lock</A><FONT style="BACKGROUND-COLOR: #ffffff">, as described in Chapter&nbsp;</FONT><A data-9uzdtcnnj6xqoalwmdp3qa='{"name": "OEBPS/Text/part0000.xhtml", "frag": "x1-390005"}'>5</A><FONT style="BACKGROUND-COLOR: #ffffff">). Consider, however, transferring $100 from account A to account B, as follows: </FONT>
<P><BR></P><PRE class=code>   &nbsp;A-&gt;subtract(100);
   &nbsp;B-&gt;add(100);</PRE><BR>
<P>Although each individual action is atomic, the sequence of actions is not. As a result, there may be a time where, say, A tells B that the money has been sent, but the money is not yet in B&#8217;s account. </P>
<P>Similarly, consider a bank manager who wants to answer a question: &#8220;How much money does the bank have?&#8221; If the manager&#8217;s program simply reads from each account, the calculation may exclude or double-count money &#8220;in flight&#8221; between accounts, such as in the transfer from A to B. </P>
<P>These examples illustrate a general problem that arises whenever a program contains multiple shared objects. Even if the object guarantees that each method operates atomically, <EM>sequences</EM> of operations by different threads can be interleaved. The same issues of managing multiple locks also apply to fine-grained locking within an object. <A id=x1-92001r144 name=x1-92001r144></A></P>
<H4 class=subsectionHead>6.4.1 <A id=x1-930001 name=x1-930001></A>Careful Class Design</H4>Sometimes it is possible to address this issue through careful class and interface design. This includes the design of individual objects (e.g., specifying clean interfaces that expose the right abstractions). It also includes the architecture of how those objects interact (e.g., structuring a system architecture in well-defined layers). 
<P>For example, you would face the same issues if you tried to solve Too Much Milk problem with a Note object that has two methods, readNote and writeNote, and a Fridge object with two methods, checkForMilk and addMilk. Atomicity of these individual operations is not sufficient to provide the desired behavior without considerable programming effort. </P>
<P>On the other hand, if we refactor the objects so that we have: </P>
<P><BR></P><PRE class=code>   &nbsp;Fridge::checkforMilkAndSetNoteIfNeeded();
   &nbsp;Fridge::addMilk();</PRE><BR>
<P>Then, the problem becomes straightforward. </P>
<P>This advice may seem obvious: of course, you should strive for elegant designs for both single- and multi-threaded code. Nonetheless, we emphasize that the choices you make for your interfaces, abstractions, and software architecture can dramatically affect the complexity or feasibility of your designs. <A id=x1-93001r156 name=x1-93001r156></A></P>
<H4 class=subsectionHead>6.4.2 <A id=x1-940002 name=x1-940002></A>Acquire-All/Release-All</H4>Better interface design has limits, however. Sometimes, multiple locks are needed for program structure or for greater concurrency. Is there a general technique to perform a set of operations that require multiple locks, so that the group of operations appears atomic? For clarity, we will refer to a group of operations as a <EM>request</EM>. 
<P>One approach, called <EM><A data-9uzdtcnnj6xqoalwmdp3qa='{"name": "OEBPS/Text/part0000.xhtml", "frag": "glo:acquire-all/release-all"}'>acquire-all/release-all</A></EM> is to acquire <EM>every</EM> lock that may be needed at any point while processing the entire set of operations in the request. Then, once the thread has all of the locks it might need, the thread can execute the request, and finally, release the locks. </P>
<P><B>EXAMPLE: </B>Consider a hash table with one lock per hash bucket. To move an item from one bucket to another, the hash table supports a changeKey(item, k1, k2) operation. With acquire-all/release-all, this function could be implemented to first acquire both the locks for k1 and k2, then remove the item under k1 and insert it under k2, and finally release both locks. </P>
<P>Acquire-all/release-all allows significant concurrency. When individual requests touch non-overlapping subsets of state protected by different locks, they can proceed in parallel. </P>
<P>A key property of this approach is <EM><A data-9uzdtcnnj6xqoalwmdp3qa='{"name": "OEBPS/Text/part0000.xhtml", "frag": "glo:serializability"}'>serializability</A></EM> across requests: the result of any program execution is equivalent to an execution in which requests are processed one at a time in some sequential order. Serializability allows one to reason about multi-step tasks <EM>as if </EM>each task executed alone. </P>
<P>As Figure&nbsp;<A data-9uzdtcnnj6xqoalwmdp3qa='{"name": "OEBPS/Text/part0000.xhtml", "frag": "x1-9400113"}'>6.13</A> illustrates, requests that access non-overlapping data can proceed in parallel. The result is the same as if the system first executed one request and then the other (or equivalently, the reverse). On the other hand, if two requests touch the same data, then the fact that all locks are acquired at the beginning and released at the end implies that one request is completed before the other one begins. <A id=x1-9400113 name=x1-9400113></A></P>
<HR>

<P></P>
<CENTER><img alt="" src="about:../Images/image00409.gif" data-calibre-src="OEBPS/Images/image00409.gif"></CENTER>
<TABLE cellPadding=10>
<TBODY>
<TR>
<TD align=left>
<P class=caption width=0><B>Figure&nbsp;6.13: </B>Locking multiple objects using an acquire-all/release-all pattern results in a serializable execution that is equivalent to an execution where requests are executed sequentially in some order.</P></TD></TR></TBODY></TABLE>
<HR>

<P>One challenge to using this approach is knowing exactly what locks will be needed by a request before beginning to process it. A potential solution is to conservatively acquire more locks than needed (e.g., acquire any locks that <EM>may</EM> be needed by a particular request), but this may be difficult to determine. Without first executing the request, how can we know which locks will be needed? <A id=x1-94002r157 name=x1-94002r157></A></P>
<H4 class=subsectionHead>6.4.3 <A id=x1-950003 name=x1-950003></A>Two-Phase Locking</H4><EM><A data-9uzdtcnnj6xqoalwmdp3qa='{"name": "OEBPS/Text/part0000.xhtml", "frag": "glo:two-phase locking"}'>Two phase locking</A></EM> refines the acquire-all/release-all pattern to address this concern. Instead of acquiring all locks before processing the request, locks can be acquired as needed for each operation. However, locks are not <EM>released</EM> until all locks needed by the request have been acquired. Most implementations simply release all locks at the end of the request. 
<P>Two-phase locking avoids needing to know what locks to grab <EM>a priori</EM>. Therefore, programs can avoid acquiring locks they do not need, and they may not need to hold locks as long. </P>
<P><B>EXAMPLE: </B>The changeKey(item, k1, k2) function for a hash table with per-bucket locks could be implemented to acquire k1&#8217;s lock, remove the item using key k1, acquire k2&#8217;s lock, insert the item using key k2, and release both locks. </P>
<P>Like acquire-all/release-all, two-phase locking is serializable. If two requests have non-overlapping data, they are commutative and therefore serializable. Otherwise, there is some overlapping data between the two requests, protected by one or more locks. Provided a request completes, it must have acquired all of those locks, and made its changes to the overlapping data, before releasing any of them. Thus, any overlapping request must have read or modified the data in the overlap either entirely before or after the other request. </P>
<P>Unlike acquire-all/release-all, however, two-phase locking can in some cases lead to deadlock, the topic of the next section. </P>
<P><B>EXAMPLE: </B>Suppose one thread starts executing changeKey(item, k1, k2) and another thread simultaneously tries to move a different item in the other direction from k2 to k1. If the first thread acquires k1&#8217;s lock and the second thread acquires k2&#8217;s lock, neither will be able to make progress. <A id=x1-95001r155 name=x1-95001r155></A></P><A id=x1-960005 name=x1-960005>