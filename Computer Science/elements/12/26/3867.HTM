<STRONG><FONT color=blue>Operating Systems: Principles and Practice (Second Edition) Volume II : 4. Concurrency and Threads : </FONT></STRONG>
<H4 class=subsectionHead>4.1.1 <A id=x1-120001 name=x1-120001></A>Four Reasons to Use Threads</H4>Using threads to express and manage concurrency has several advantages: 
<UL class=itemize1>
<LI class=itemize>
<P><B><SPAN class=extract><B>Program structure: expressing logically concurrent tasks.</B> Programs often interact with or simulate real-world applications that have concurrent activities. Threads let you express an application&#8217;s natural concurrency by writing each concurrent task as a separate thread.</SPAN></B> </P>
<P>In the Earth Visualizer application, threads let different activities &#8212; updating the screen, fetching additional data, and receiving new user inputs &#8212; run at the same time. For example, to get mouse input while also re-drawing the screen and sending and receiving packets off the network, the physical processors need to split their time among these tasks. </P>
<P>Although one could imagine manually writing a program that interleaves these activities (e.g., draw a few pixels on the screen, then check to see if the user has moved the mouse, then check to see if new image data have arrived on the network, . . . ), using threads greatly simplifies concurrent code. </P>
<P>Another example is on the server side of the Earth Visualizer. The server needs to manage the requests of a large number of clients, each focused on a different point on the planet. Since the clients are likely behind a wide variety of access link technologies (e.g., from dialup to gigabit Ethernet), it would slow everyone down if each request needed to be completely handled before the server could start on the next one. By creating a separate thread for each client, the computation and networking needed for that client can be intermixed with other clients, without affecting the logical structure of the program. This design pattern &#8212; one server thread per client &#8212; is common; for example, the popular Apache web server assigns each client its own thread when it first connects to the server. </P>
<LI class=itemize>
<P><B><SPAN class=extract><B>Responsiveness: shifting work to run in the background.</B> To improve user responsiveness and performance, a common design pattern is to create threads to perform work in the background, without the user waiting for the result. This way, the user interface can remain responsive to further commands, regardless of the complexity of the user request. In a web browser, for example, the cancel button should continue to work even (or especially!) if the downloaded page is gigantic or a script on the page takes a long time to execute.</SPAN></B> </P>
<P>How does this work? Many applications have a loop: get a user command, then execute the command, then get the next command. If some commands take a long time to perform, however, an application that executes everything sequentially will not be able to check for the next operation until the previous one completes. <SPAN class=extract>To keep the interface responsive, we can use threads to split each command into two parts: anything that can be done instantly can be done in the main event loop, and a separate thread can perform the rest of the task in the background.</SPAN> In the Earth Visualizer example, we used threads to move the computationally difficult parts of the application logic &#8212; rendering the display &#8212; out of the main loop. </P>
<P>Operating system kernels make extensive use of threads to preserve responsiveness. Many operating systems are designed so that the common case is fast. For example, when writing a file, the operating system stores the modified data in a kernel buffer, and returns immediately to the application. In the background, the operating system kernel runs a separate thread to flush the modified data out to disk. Another example is on file reads: the kernel can have a thread which attempts to anticipate which blocks are likely to be read next (e.g., if the application is reading a large file from beginning to end), and to bring those blocks from disk before the application asks for them. </P>
<LI class=itemize>
<P><B><SPAN class=extract><B>Performance: exploiting multiple processors.</B> Programs can use threads on a multiprocessor to do work in parallel; they can do the same work in less time or more work in the same elapsed time.</SPAN></B> Today, a server might have more than a dozen processors; a desktop or laptop may include eight processor cores; even most smartphones are multicore machines. Looking forward, Moore&#8217;s law makes it likely that the number of processors per system will continue to increase. An <SPAN class=extract>advantage to using threads for parallelism is that the number of threads need not exactly match the number of processors in the hardware on which it is running. The operating system transparently switches which threads run on which processors.</SPAN> </P>
<P>For an 8-processor machine, you could parallelize the Earth Visualizer application by splitting the demanding job of rendering different portions of the image on the screen across six threads. Then, the operating system could run those six rendering threads on six processors and run the various other threads on the two remaining processors to update the on-screen navigation widgets, construct the network messages needed to fetch additional images from the distant servers, and parse reply messages. </P>
<LI class=itemize>
<P><B>Performance: managing I/O devices.</B> To do useful work, computers must interact with the outside world via I/O devices. By running tasks as separate threads, when one task is waiting for I/O, the processor can make progress on a different task. </P><SPAN class=extract>
<P>The benefit of concurrency between the processor and the I/O is two-fold: First, processors are often much faster than the I/O systems with which they interact, so keeping the processor idle during I/O would waste much of its capacity. For example, the latency to read from disk can be tens of milliseconds, enough to execute more than 10 million instructions on a modern processor. After requesting a block from disk, the operating system can switch to another program, or another thread within the same program, until the disk completes and the original thread is ready to resume. </P>
<P>Second, I/O provides a way for the computer to interact with external entities, such as users pressing keys on a keyboard or a remote computer sending network packets. The arrival of this type of I/O event is unpredictable, so the processor must be able to work on other tasks while still responding quickly to these external events.</SPAN></P>
<P>In the Earth Visualizer application, a snappy user interface is essential, but much of the imagery is stored on remote servers and fetched by the application only when needed. The application provides a responsive experience when a user changes location by first downloading a small, low-resolution view of the new location. While rendering those images with one thread, another thread simultaneously fetches progressively higher-resolution images, allowing the rendering thread to update the view as the higher-resolution images arrive. </P></LI></UL>
<P></P>
<DIV class=sidebar align=center>
<HR>

<TABLE cellPadding=10>
<TBODY>
<TR>
<TD style="BACKGROUND-COLOR: #f0f0f0" align=left>
<P width=0><SPAN class=sidebar_name><B><I>Threads vs. processes</I></B></SPAN> </P>
<P>In Chapter&nbsp;2, we described a process as the execution of a program with restricted rights. A thread is an independent sequence of instructions running within a program. Perhaps the best way to see how these concepts are related, is to see how different operating systems combine them in different ways: </P>
<UL class=itemize1>
<LI class=itemize>
<P><B>One thread per process.</B> A simple single-threaded application has one sequence of instructions, executing from beginning to end. The operating system kernel runs those instructions in user mode to restrict access to privileged operations or system memory. The process performs system calls to ask the kernel to perform privileged operations on its behalf. </P>
<LI class=itemize>
<P><B><SPAN class=extract><B>Many threads per process.</B> Alternately, a program may be structured as several concurrent threads, each executing within the restricted rights of the process. At any given time, a subset of the process&#8217;s threads may be running, while the rest are suspended. Any thread running in a process can make system calls into the kernel, blocking that thread until the call returns but allowing other threads to continue to run. Likewise, when the processor gets an I/O interrupt, it preempts one of the running threads so the kernel can run the interrupt handler; when the handler finishes, the kernel resumes that thread</SPAN></B>. </P>
<LI class=itemize>
<P><B>Many single-threaded processes.</B> As recently as twenty years ago, many operating systems supported multiple processes but only one thread per process. To the kernel, however, each process looks like a thread: a separate sequence of instructions, executing sometimes in the kernel and sometimes at user level. For example, on a multiprocessor, if multiple processes perform system calls at the same time, the kernel, in effect, has multiple threads executing concurrently in kernel mode. </P>
<LI class=itemize>
<P><B>Many kernel threads.</B> To manage complexity, shift work to the background, exploit parallelism, and hide I/O latency, the operating system kernel itself can benefit from using multiple threads. In this case, each kernel thread runs with the privileges of the kernel: it can execute privileged instructions, access system memory, and issue commands directly to I/O devices. The operating system kernel itself implements the thread abstraction for its own use. </P></LI></UL>
<P>Because of the usefulness of threads, almost all modern operating systems support both multiple threads per process and multiple kernel threads. </P>
<P></P></TD></TR></TBODY></TABLE>
<HR>
</DIV><A id=x1-12001r22 name=x1-12001r22></A><A id=x1-130002 name=x1-130002>