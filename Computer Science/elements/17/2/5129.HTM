<B><SPAN class=headers>Title:</SPAN></B><SPAN class=RefText> 4.6.3 Thread Context Switch : What Triggers a Kernel Thread Context Switch?</SPAN></FONT></B> 
<P></P>
<P>A thread context switch can be triggered by either a voluntary call into the thread library, or an involuntary interrupt or processor exception. </P>
<P><SPAN class=extract>&#20869;&#26680;&#32447;&#31243;&#30340;&#19978;&#19979;&#25991;&#20999;&#25442;&#26082;&#21487;&#20197;&#36890;&#36807;&#32447;&#31243;&#24211;&#20989;&#25968;&#30001;&#32447;&#31243;&#20027;&#21160;&#35302;&#21457;&#65292;&#20063;&#21487;&#20197;&#30001;&#20013;&#26029;&#25110;&#32773;&#22788;&#29702;&#22120;&#24322;&#24120;&#34987;&#21160;&#35302;&#21457;</SPAN></P>
<P><SPAN class=extract>&#25152;&#35859;&#32447;&#31243;&#24211;&#25351;&#30340;&#23601;&#26159;&#25552;&#20379;&#32447;&#31243;&#30456;&#20851;&#25805;&#20316;&#30340;&#24211;</SPAN></P>
<P></P>
<UL class=itemize1>
<LI class=itemize>
<P><B>Voluntary.</B> The thread could call a thread library function that triggers a context switch. For example, most thread libraries provide a thread_yield&nbsp;call that lets the currently running thread voluntarily give up the processor to the next thread on the ready list. Similarly, the thread_join&nbsp;and thread_exit&nbsp;calls suspend execution of the current thread and start running a different one. <BR><BR>thread_yield&#65306;&#35753;&#24403;&#21069;&#36827;&#31243;&#20027;&#21160;&#35753;&#20986; CPU &#30340;&#20351;&#29992;&#26435;</P>
<LI class=itemize>
<P><B>Involuntary.</B> An <EM>interrupt</EM> or <EM>processor exception</EM> could invoke an interrupt handler. The interrupt hardware saves the state of the running thread and executes the handler&#8217;s code. The handler can decide that some other thread should run, and then switch to it. Alternatively, if the current thread should continue running, the handler restores the state of the interrupted thread and resumes execution. <BR><BR><SPAN class=extract>&#38750;&#33258;&#24895;&#30340;&#20013;&#26029;&#24182;&#19981;&#19968;&#23450;&#23548;&#33268;&#19978;&#19979;&#25991;&#20999;&#25442;&#65292;&#26159;&#21542;&#20999;&#25442;&#30001;&#20013;&#26029;&#22788;&#29702;&#22120;&#20915;&#23450;</SPAN></P>
<P>For example, many thread systems are designed to ensure that no thread can monopolize the processor. To accomplish this, they set a hardware timer to interrupt the processor periodically (e.g., every few milliseconds). The timer interrupt handler saves the state of the running thread, chooses another thread to run, and runs that thread by restoring its state to the processor. </P>
<P>Other I/O hardware events (e.g., a keyboard key is pressed, a network packet arrives, or a disk operation completes) also invoke interrupt handlers. In these cases as well, the handlers save the state of the currently running thread so that it can be restored later. They then execute the handler code, and when the handler is done, they either restore the state of the current thread, or switch to a new thread. A new thread will be run if the I/O event moves a thread onto the ready list with a higher priority than the previously running thread.<BR><BR>&#20063;&#23601;&#26159;&#35828;&#65292;<SPAN class=extract>&#22914;&#26524;&#20013;&#26029;&#20026;&#20934;&#22791;&#21015;&#34920;&#24102;&#26469;&#20102;&#19968;&#20010;&#27604;&#34987;&#20013;&#26029;&#32447;&#31243;&#25317;&#26377;&#26356;&#39640;&#20248;&#20808;&#32423;&#30340;&#36827;&#31243;&#30340;&#35805;&#65292;&#24674;&#22797;&#19978;&#19979;&#25991;&#30340;&#26102;&#20505;&#23601;&#20250;&#36716;&#32780;&#25191;&#34892;&#35813;&#32447;&#31243;&#32780;&#38750;&#24674;&#22797;&#19978;&#19979;&#25991;</SPAN></P></LI></UL>
<P>Regardless, the thread system must save the current processor state, so that when the current thread resumes execution, it appears <EM>to the thread</EM> as if the event never occurred except for some time having elapsed. This provides the abstraction of thread execution on a virtual processor with unpredictable and variable speed. </P>
<P>&#26080;&#35770;&#22914;&#20309;&#65292;&#32447;&#31243;&#31995;&#32479;&#24517;&#39035;&#20445;&#23384;&#24403;&#21069;&#22788;&#29702;&#22120;&#30340;&#29366;&#24577;</P>
<P>To keep things simple, we do not want to do an involuntary context switch while we are in the middle of a voluntary one. When switching between two threads, we need to temporarily defer interrupts until the switch is complete, to avoid confusion. Processors contain privileged instructions to defer and re-enable interrupts; we make use of these in our implementation below.</P>
<P>&#20540;&#24471;&#27880;&#24847;&#30340;&#26159;&#65292;<SPAN class=extract>&#20026;&#20102;&#30830;&#20445;&#32447;&#31243;&#20999;&#25442;&#20855;&#26377;&#21407;&#23376;&#24615;&#65292;&#22240;&#27492;&#22312;&#25191;&#34892;&#32447;&#31243;&#20999;&#25442;&#30340;&#36807;&#31243;&#20013;&#65292;&#25105;&#20204;&#20250;&#26242;&#26102;&#24615;&#22320;&#31105;&#29992;&#20013;&#26029;</SPAN>