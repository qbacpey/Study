The timer ISR doesn't call<SPAN>&nbsp;</SPAN><CODE><FONT face="Courier New">schedule()</FONT></CODE><SPAN>&nbsp;</SPAN>directly. It ends up calling<SPAN>&nbsp;</SPAN><CODE><FONT face="Courier New">update_process_times()</FONT></CODE><SPAN>&nbsp;</SPAN>so the scheduler process accounting information is up to date.</P>
<P>The scheduler is eventually called when returning to userspace. If the kernel is preemptive, it is also called when returning from the timer interrupt to kernelspace.</P>
<P>As an example, imagine a process A which issues a syscall which is interrupted by a device-generated interrupt, that is then interrupted by a timer interrupt:</P><PRE style="OVERFLOW: auto; BORDER-TOP: 0px; FONT-FAMILY: var(--ff-mono); BORDER-RIGHT: 0px; WIDTH: auto; VERTICAL-ALIGN: baseline; WORD-SPACING: 0px; MARGIN-TOP: 0px; BORDER-BOTTOM: 0px; TEXT-TRANSFORM: none; FONT-WEIGHT: 400; COLOR: ; FONT-STYLE: normal; TEXT-ALIGN: left; MARGIN-LEFT: 0px; BORDER-LEFT: 0px; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; MAX-HEIGHT: 600px; MARGIN-RIGHT: 0px; TEXT-INDENT: 0px; font-variant-ligatures: normal; font-variant-caps: normal; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; -webkit-text-stroke-width: 0px; text-decoration-style: initial; text-decoration-color: initial; border-radius: var(--br-md); overflow-wrap: normal">  <FONT size=2> process A userspace &#8594; process A kernelspace &#8594; device ISR &#8594; timer ISR
                    syscall               device IRQ    timer IRQ</FONT></PRE>
<P>When the timer ISR ends, it returns to another ISR, that then returns to kernelspace, which then returns to userspace. A preemptive kernel checks if it needs to reschedule processes at every return. A non-preemptive kernel only does that check when returning to userspace.</P>
<P>In ARM land, the codepath goes broadly like:</P>
<UL>
<LI>An IRQ received while in userspace ends up calling<SPAN>&nbsp;</SPAN><CODE><FONT face="Courier New">__irq_usr</FONT></CODE>, while an IRQ received while in SVC mode ends up calling<SPAN>&nbsp;</SPAN><CODE><FONT face="Courier New">__irq_svc</FONT></CODE>. IRQs should not be received while in other processor modes. 
<LI>In<SPAN>&nbsp;</SPAN><CODE><FONT face="Courier New">__irq_svc</FONT></CODE>, after handling the IRQ,<SPAN>&nbsp;</SPAN><EM>if the kernel is preemptive</EM>, preemption is not disabled, and a reschedule is needed, the kernel jumps to<SPAN>&nbsp;</SPAN><CODE><FONT face="Courier New">svc_preempt</FONT></CODE>, which calls<SPAN>&nbsp;</SPAN><CODE><FONT face="Courier New">preempt_schedule_irq</FONT></CODE>, which calls<SPAN>&nbsp;</SPAN><CODE><FONT face="Courier New">schedule</FONT></CODE>. Otherwise, no reschedule is done. 
<LI>Eventually, the CPU will return to userspace, either from an IRQ handler (<CODE><FONT face="Courier New">__irq_usr</FONT></CODE><SPAN>&nbsp;</SPAN>&#8594;<SPAN>&nbsp;</SPAN><CODE><FONT face="Courier New">ret_to_user_from_irq</FONT></CODE>), or from a syscall (<CODE><FONT face="Courier New">vector_swi</FONT></CODE><SPAN>&nbsp;</SPAN>&#8594;<SPAN>&nbsp;</SPAN><CODE><FONT face="Courier New">ret_fast_syscall</FONT></CODE>). There, the kernel checks whether there is work to be done, and if a reschedule is needed,<SPAN>&nbsp;</SPAN><CODE><FONT face="Courier New">schedule</FONT></CODE><SPAN>&nbsp;</SPAN>is called.</LI></UL>