<B>Implementation Details.</B> On most processor architectures, a simple (but inefficient) way to swap to the next thread from within an interrupt handler is to call thread_switch&nbsp;just before the handler returns. As we have already seen, thread_switch&nbsp;saves the state of the current thread (that is, the state of the interrupt handler) and switches to the new kernel thread. When the original thread resumes, it will return from thread_switch, and immediately pop the interrupt context off the stack, resuming execution at the point where it was interrupted. 
<P></P>
<P>Most systems, such as Linux, make a small optimization to improve interrupt handling performance. The state of the interrupted thread is already saved on the stack, albeit in the format specified by the interrupt hardware. If we modify thread_switch&nbsp;to save and restore registers exactly as the interrupt hardware does, then returning from an interrupt and resuming a thread are the same action: they both pop the interrupt frame off the stack to resume the next thread to run. </P>
<P>&#31616;&#21333;&#26469;&#35828;&#23601;&#26159;&#65292;&#35753; thread_switch &#27169;&#20223;&#32447;&#31243;&#34987;&#20013;&#26029;&#26102;&#30828;&#20214;&#65288;&#21644;&#20013;&#26029;&#22788;&#29702;&#31243;&#24207;&#65289;&#20445;&#23384;&#29366;&#24577;&#26102;&#25152;&#37319;&#29992;&#30340;&#26684;&#24335;&#65292;&#23601;&#33021;&#37319;&#29992;&#24674;&#22797;&#20013;&#26029;&#32447;&#31243;&#29366;&#24577;&#26102;&#25152;&#37319;&#29992;&#30340;&#20195;&#30721;&#24674;&#22797; thread_switch &#20986;&#21435;&#30340;&#32447;&#31243;&#12290;&#36825;&#26679;&#20013;&#26029;&#22788;&#29702;&#31243;&#24207;&#23601;&#19981;&#38656;&#35201;&#26681;&#25454;&#39537;&#21160;&#32447;&#31243;&#25191;&#34892;&#19978;&#19979;&#25991;&#20999;&#25442;&#30340;&#21407;&#22240;&#65292;&#26469;&#36873;&#25321;&#19981;&#21516;&#30340;&#24674;&#22797;&#25163;&#27573;&#20102;</P>
<P>&#20043;&#21069;&#22909;&#20687;&#30475;&#21040;&#36807;&#65292;&#20013;&#26029;&#22788;&#29702;&#31243;&#24207;&#20250;&#23436;&#20840;&#25215;&#25285;&#36215;&#24674;&#22797;&#32447;&#31243;&#29366;&#24577;&#30340;&#20219;&#21153;&#65292;&#26080;&#38656;&#30828;&#20214;&#21442;&#19982;</P>
<P>For example, to be compatible with x86 interrupt hardware, the software implementation of thread_switch&nbsp;would simulate the hardware case, saving the return instruction pointer and eflags register before calling pushad to save the general-purpose registers. After switching to the new stack, it would call iret to resume the new thread, whether the new thread was suspended by a hardware event or a software call.</P>
<P>&#24863;&#35273;&#36825;&#37324;&#30340;&#20851;&#38190;&#20854;&#23454;&#24182;&#19981;&#22312;&#20110;&#25552;&#21319;&#20013;&#26029;&#22788;&#29702;&#30340;&#24615;&#33021;&#20043;&#31867;&#30340;&#19996;&#35199;&#65292;&#26356;&#37325;&#35201;&#30340;&#26159;&#65292;&#22914;&#20309;&#35753;&#20013;&#26029;&#24674;&#22797;&#21644;&#32447;&#31243;&#20999;&#25442;&#37117;&#20351;&#29992;&#30456;&#21516;&#30340;&#19968;&#22871;&#20195;&#30721;&#20445;&#23384;&#29366;&#24577;&#21644;&#24674;&#22797;&#29366;&#24577;</P>
<P><SPAN class=extract>&#23454;&#36341;&#20013;&#65292;thread_switch &#20445;&#23384;&#32447;&#31243;&#29366;&#24577;&#21644;&#24674;&#22797;&#32447;&#31243;&#29366;&#24577;&#30340;&#20195;&#30721;&#21644;&#35841;&#26159;&#30456;&#21516;&#30340;&#65311;&#20013;&#26029;&#22788;&#29702;&#31243;&#24207;</SPAN>