As to the historic rationale, I can't say for certain (because I didn't design them). My<SPAN>&nbsp;</SPAN><EM>thoughts</EM><SPAN>&nbsp;</SPAN>on the matter are that early CPUs got their original program counter set to 0 and it was a natural desire to start the stack at the other end and grow downwards, since their code naturally grows upward.</P>
<BLOCKQUOTE>
<P>As an aside, note that this setting of the program counter to 0 on reset is not the case for<SPAN>&nbsp;</SPAN><EM>all</EM><SPAN>&nbsp;</SPAN>early CPUs. For example, the Motorola 6809 would fetch the program counter from addresses<SPAN>&nbsp;</SPAN><CODE><FONT face="Courier New">0xfffe/f</FONT></CODE><SPAN>&nbsp;</SPAN>so you could start running at an arbitrary location, depending on what was supplied at that address (usually, but by no means limited to, ROM).</P></BLOCKQUOTE>
<P>One of the first things some historical systems would do would be to scan memory from the top until it found a location that would read back the same value written, so that it would know the actual RAM installed (e.g., a z80 with 64K address space didn't necessarily have 64K or RAM, in fact 64K would have been<SPAN>&nbsp;</SPAN><EM>massive</EM><SPAN>&nbsp;</SPAN>in my early days). Once it found the top actual address, it would set the stack pointer appropriately and could then start calling subroutines. This scanning would generally be done by the CPU running code in ROM as part of start-up.</P>
<P>With regard to the stacks growth, not all of them grow downwards, see<SPAN>&nbsp;</SPAN><A href="https://stackoverflow.com/questions/664744/what-is-the-direction-of-stack-growth-in-most-modern-systems/664779#664779">this answer</A><SPAN>&nbsp;</SPAN>for details.