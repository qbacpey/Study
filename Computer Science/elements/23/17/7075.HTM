<SPAN class=headers>Title:</SPAN></B><SPAN class=RefText> G.4 Backtraces</SPAN></FONT> 
<P></P><SPAN class=extract>
<P>When the kernel panics, it prints a &#8220;backtrace,&#8221; that is, a summary of how your program got where it is, as a list of addresses inside the functions that were running at the time of the panic. </P>
<P>backtrace &#22823;&#25269;&#21487;&#20197;&#29702;&#35299;&#20026;&#38024;&#23545;&#36804;&#20170;&#20026;&#27490;&#31243;&#24207;&#36816;&#34892;&#36712;&#36857;&#30340;&#19968;&#27425;&#24635;&#32467;</P></SPAN><SPAN class=extract>
<P>You can also insert a call to debug_backtrace, prototyped in &lt;debug.h&gt;, to print a backtrace at any point in your code. </P>
<P>&#22914;&#26524;&#24819;&#35201;&#25171;&#21360;&#24403;&#21069;&#32447;&#31243;&#30340; backtrace&#65292;&#21487;&#20197;&#35843;&#29992; debug_backtrace&#12290;&#26082;&#21487;&#20197;&#23558;&#36825;&#20010;&#20989;&#25968;&#25918;&#22312;&#31243;&#24207;&#30340;&#26576;&#19968;&#28857;&#22788;&#65292;&#24403;&#31243;&#24207;&#36816;&#34892;&#21040;&#37027;&#20010;&#20301;&#32622;&#23601;&#20250;&#25171;&#21360;&#24403;&#26102;&#24403;&#22320;&#30340; backtrace&#65307;&#20063;&#21487;&#20197;&#22312;&#20351;&#29992; GDB &#35843;&#35797;&#31243;&#24207;&#30340;&#26102;&#20505;&#65292;&#20351;&#29992;&#8220;call&#8221;&#35843;&#29992;&#27492;&#20989;&#25968;&#20197;&#25171;&#21360;&#32447;&#31243;&#27492;&#26102;&#30340; backtrace</P>
<P>&#36825;&#20010;&#20989;&#25968;&#30340;&#21407;&#22411;&#20301;&#20110; &lt;debug.h&gt; &#25991;&#20214;&#20013;</P></SPAN><SPAN class=extract>
<P>debug_backtrace_all, also declared in &lt;debug.h&gt;, prints backtraces of all threads.</P>
<P>&#22914;&#26524;&#24819;&#35201;&#25171;&#21360;&#25152;&#26377;&#32447;&#31243;&#30340; backtrace&#65292;&#21487;&#20197;&#25191;&#34892; debug_backtrace_all &#20989;&#25968;</P></SPAN><SPAN class=extract>
<P>The addresses in a backtrace are listed as raw hexadecimal numbers, which are di&#64259;cult to interpret. We provide a tool called <STRONG>backtrace</STRONG> to translate these into function names and source &#64257;le line numbers. Give it the name of your kernel.o as the &#64257;rst argument and the hexadecimal numbers composing the backtrace (including the 0x pre&#64257;xes) as the remaining arguments. It outputs the function name and source &#64257;le line numbers that correspond to each address.</P>
<P>&#32771;&#34385;&#21040;&#20351;&#29992;&#22914;&#19978;&#20004;&#20010;&#20989;&#25968;&#25171;&#21360;&#20986;&#26469;&#30340;&#19996;&#35199;&#26159;&#21407;&#22987;&#30340;&#21313;&#20845;&#36827;&#21046;&#22320;&#22336;&#65292;&#22240;&#27492;&#25105;&#20204;&#21487;&#20197;&#20351;&#29992;&#19968;&#20010;&#21483;&#20570; backtrace &#30340;&#24037;&#20855;&#23558;&#36825;&#20123;&#21313;&#20845;&#36827;&#21046;&#22320;&#22336;&#36716;&#21270;&#20026;&#19982;&#20043;&#30456;&#20851;&#30340;&#20989;&#25968;&#21517;&#21644;&#28304;&#25991;&#20214;&#34892;&#21495;&#12290;</P>
<P>&#22914;&#26524;&#24819;&#35201;&#20351;&#29992;&#36825;&#20010;&#24037;&#20855;&#65292;&#23558; kernel.o &#30340;&#21517;&#23383;&#20316;&#20026;&#23427;&#30340;&#31532;&#19968;&#20010;&#21442;&#25968;&#65292;&#21313;&#20845;&#36827;&#21046;&#25968;&#65288;&#21253;&#25324; 0x&#65289;&#21069;&#32512;&#20316;&#20026;&#21097;&#20313;&#21442;&#25968;&#22312;&#21629;&#20196;&#34892;&#65288;&#25110;&#32773;&#21035;&#30340;&#20160;&#20040;&#22320;&#26041;&#65289;&#35843;&#29992;&#23427;&#21363;&#21487;</P></SPAN><SPAN class=extract>
<P>If the translated form of a backtrace is garbled, or doesn&#8217;t make sense (e.g.: function A is listed above function B, but B doesn&#8217;t call A), then it&#8217;s a good sign that you&#8217;re corrupting a kernel thread&#8217;s stack, because the backtrace is extracted from the stack. Alternatively, it could be that the kernel.o you passed to backtrace is not the same kernel that produced the backtrace.</P>
<P>Backtrace &#26159;&#20174;&#26632;&#20013;&#25552;&#21462;&#20986;&#26469;&#30340;&#65292;&#22240;&#27492;&#22914;&#26524;&#36716;&#21270;&#24471;&#21040;&#30340;&#25968;&#25454;&#27809;&#26377;&#24847;&#20041;&#65288;&#25110;&#32773;&#35828;&#26080;&#27861;&#29702;&#35299;&#65289;&#37027;&#23601;&#35828;&#26126;&#26632;&#26412;&#36523;&#30340;&#25968;&#25454;&#21463;&#21040;&#20102;&#30772;&#22351;&#12290;&#24403;&#28982;&#65292;&#20063;&#26377;&#21487;&#33021;&#26159;&#20256;&#36882;&#32473; backtrace &#30340;&#20869;&#26680;&#25991;&#20214;&#24182;&#38750;&#26159;&#20135;&#29983;&#36825;&#20010; backtrace &#30340;&#20869;&#26680;&#25991;&#20214;</P></SPAN><SPAN class=extract>
<P>Sometimes backtraces can be confusing without any corruption. Compiler optimizations can cause surprising behavior. When a function has called another function as its &#64257;nal action (a tail call), the calling function may not appear in a backtrace at all. </P>
<P>&#26377;&#26102;&#30001;&#20110;&#32534;&#35793;&#20248;&#21270;&#30340;&#32536;&#25925;&#65292;&#24403;&#26576;&#20010;&#20989;&#25968;&#22312;&#36820;&#22238;&#35821;&#21477;&#20013;&#35843;&#29992;&#21478;&#19968;&#20010;&#20989;&#25968;&#65292;&#20027;&#35843;&#20989;&#25968;&#21487;&#33021;&#23601;&#19981;&#20250;&#20986;&#29616;&#22312; backtrace &#20013;</P></SPAN>
<P><SPAN class=extract>Similarly, when function A calls another function B that never returns, the compiler may optimize such that an unrelated function C appears in the backtrace instead of A. Function C is simply the function that happens to be in memory just after A.</SPAN></P>
<P>Here&#8217;s an example. Suppose that Pintos printed out this following call stack:</P>
<P><FONT size=3 face="Ubuntu Mono">Call stack: 0xc0106eff 0xc01102fb 0xc010dc22 0xc010cf67 0xc0102319</FONT></P>
<P><FONT size=3 face="Ubuntu Mono">0xc010325a 0x804812c 0x8048a96 0x8048ac8.</FONT></P><SPAN class=extract>
<P>You would then invoke the backtrace utility like shown below, cutting and pasting the backtrace information into the command line. This assumes that kernel.o is in the current directory. </P>
<P>kernel.o &#25991;&#20214;&#38656;&#35201;&#20301;&#20110;&#35843;&#29992; backtrace &#30340;&#30446;&#24405;&#20013;</P></SPAN>
<P>You would of course enter all of the following on a single shell command line, even though that would over&#64258;ow our margins here:</P>
<P><FONT size=3 face="Ubuntu Mono">backtrace kernel.o 0xc0106eff 0xc01102fb 0xc010dc22 0xc010cf67 0xc0102319 0xc010325a 0x804812c 0x8048a96 0x8048ac8</FONT></P>
<P>The backtrace output would then look something like this:<BR><BR><FONT size=3 face="Ubuntu Mono">0xc0106eff: debug_panic (lib/debug.c:86)<BR></FONT><FONT size=3 face="Ubuntu Mono">0xc01102fb: file_seek (filesys/file.c:405)<BR></FONT><FONT size=3 face="Ubuntu Mono">0xc010dc22: seek (userprog/syscall.c:744)<BR></FONT><FONT size=3 face="Ubuntu Mono">0xc010cf67: syscall_handler (userprog/syscall.c:444)<BR></FONT><FONT size=3 face="Ubuntu Mono">0xc0102319: intr_handler (threads/interrupt.c:334)<BR></FONT><FONT size=3 face="Ubuntu Mono">0xc010325a: intr_entry (threads/intr-stubs.s:38)<BR></FONT><FONT size=3 face="Ubuntu Mono">0x0804812c: (unknown)<BR></FONT><FONT size=3 face="Ubuntu Mono">0x08048a96: (unknown)<BR></FONT><FONT size=3 face="Ubuntu Mono">0x08048ac8: (unknown)</FONT></P><SPAN class=extract>
<P>The &#64257;rst line in the backtrace refers to debug_panic, the function that implements kernel panics. Because backtraces commonly result from kernel panics, debug_panic will often be the &#64257;rst function shown in a backtrace.</P>
<P>&#19968;&#33324;&#26469;&#35828;&#65292;&#30001;&#20110;&#35302;&#21457;&#20869;&#26680;&#38169;&#35823;&#23601;&#24448;&#24448;&#24847;&#21619;&#30528;&#38656;&#35201;&#26597;&#30475; backtrace&#65292;&#22240;&#27492;&#23454;&#29616;&#20102;&#20869;&#26680;&#38169;&#35823;&#30340;&#20989;&#25968; debug_panic &#24448;&#24448;&#23601;&#20301;&#20110;&#20989;&#25968;&#35843;&#29992;&#26632;&#30340;&#26368;&#19978;&#26041;</P></SPAN>
<P>The second line shows file_seek as the function that panicked, in this case as the result of an assertion failure. In the source code tree used for this example, line 405 of filesys/file.c is the assertion<BR><BR><FONT size=3 face="Ubuntu Mono">assert (file_ofs &gt;= 0);</FONT></P>
<P>(This line was also cited in the assertion failure message.) Thus, file_seek panicked because it passed a negative &#64257;le o&#64256;set argument.</P>
<P>The third line indicates that seek called file_seek, presumably without validating the o&#64256;set argument. In this submission, seek implements the seek system call.</P>
<P>The fourth line shows that syscall_handler, the system call handler, invoked seek.</P>
<P>The &#64257;fth and sixth lines are the interrupt handler entry path.</P><SPAN class=extract>
<P>The remaining lines are for addresses below phys_base. This means that they refer to addresses in the user program, not in the kernel. If you know what user program was running when the kernel panicked, you can re-run backtrace on the user program, like so: (typing the command on a single line, of course):</P>
<P>&#20313;&#19979;&#37027;&#20123;&#27809;&#26377;&#34987;&#25171;&#21360;&#20986;&#26469;&#30340;&#20449;&#24687;&#65288;unknown&#65289;&#23454;&#38469;&#19978;&#23601;&#26159;&#24847;&#21619;&#30528;&#36825;&#20123;&#20989;&#25968;&#35843;&#29992;&#21457;&#29983;&#22312;&#29992;&#25143;&#20869;&#23384;&#31354;&#38388;&#20013;&#65292;&#22240;&#27492;&#20165;&#38752;&#30528; kernel.o &#27809;&#26377;&#21150;&#27861;&#33719;&#21462;&#21040;&#23427;&#20204;&#30340;&#20449;&#24687;&#12290;&#32780;&#22914;&#26524;&#24819;&#35201;&#35753; backtrace &#23558;&#36825;&#20123;&#20063;&#25171;&#21360;&#20986;&#26469;&#65292;&#23601;&#38656;&#35201;&#22312;&#21629;&#20196;&#34892;&#20013;&#22768;&#26126;&#21457;&#29983;&#36825;&#20123;&#20989;&#25968;&#35843;&#29992;&#30340;&#31243;&#24207;</P>
<P><FONT size=3 face="Ubuntu Mono">backtrace tests/filesys/extended/grow-too-big 0xc0106eff 0xc01102fb 0xc010dc22 0xc010cf67 0xc0102319 0xc010325a 0x804812c 0x8048a96 0x8048ac8</FONT></P>
<P>The results look like this:<BR><BR><FONT size=3 face="Ubuntu Mono">0xc0106eff: (unknown) <BR>0xc01102fb: (unknown) <BR>0xc010dc22: (unknown) <BR>0xc010cf67: (unknown) <BR>0xc0102319: (unknown) <BR>0xc010325a: (unknown) <BR>0x0804812c: test_main (...xtended/grow-too-big.c:20) <BR>0x08048a96: main (tests/main.c:10) <BR>0x08048ac8: _start (lib/user/entry.c:9)</FONT></P>
<P></SPAN><SPAN class=extract>&nbsp;</P>
<P>You can even specify both the kernel and the user program names on the command line, like so:</P>
<P>&#27492;&#22806;&#65292;&#20063;&#21487;&#20197;&#22312;&#21629;&#20196;&#34892;&#20013;&#22768;&#26126;&#22810;&#20010;&#25991;&#20214;&#65292;&#36827;&#32780;&#21576;&#29616;&#23436;&#25972;&#30340;&#20989;&#25968;&#35843;&#29992;&#26632;</P>
<P><FONT size=3 face="Ubuntu Mono">backtrace kernel.o tests/filesys/extended/grow-too-big 0xc0106eff 0xc01102fb 0xc010dc22 0xc010cf67 0xc0102319 0xc010325a 0x804812c 0x8048a96 0x8048ac8</FONT></P>
<P></SPAN>The result is a combined backtrace:<BR><BR><FONT size=3 face="Ubuntu Mono">in kernel.o:<BR>0xc0106eff: debug_panic (lib/debug.c:86)| <BR>0xc01102fb: file_seek (filesys/file.c:405)| <BR>0xc010dc22: seek (userprog/syscall.c:744)| <BR>0xc010cf67: syscall_handler (userprog/syscall.c:444)| <BR>0xc0102319: intr_handler (threads/interrupt.c:334)| <BR>0xc010325a: intr_entry (threads/intr-stubs.s:38)|</FONT> <BR></P>
<P>in <FONT size=3 face="Ubuntu Mono">tests/filesys/extended/grow-too-big: </FONT><BR><BR><FONT size=3 face="Ubuntu Mono">0x0804812c: test_main (...xtended/grow-too-big.c:20)| <BR>0x08048a96: main (tests/main.c:10)| <BR>0x08048ac8: _start (lib/user/entry.c:9)|</FONT></P><SPAN class=extract>
<P>Here&#8217;s an extra tip: backtrace is smart enough to strip the Call stack: header and . trailer from the command line if you include them. This can save you a little bit of trouble in cutting and pasting. Thus, the following command prints the same output as the &#64257;rst one we used:</P>
<P>&#21478;&#22806;&#65292;&#30452;&#25509;&#23558;&#25171;&#21360;&#20986;&#26469;&#30340;&#22320;&#22336;&#36830;&#21516;&#8220;Call stack&#8221;&#36825;&#20010;&#21069;&#32512;&#21644;&#8220;.&#8221;&#21518;&#32512;&#19968;&#36215;&#25918;&#36827;&#21629;&#20196;&#34892;&#20063;&#26159;&#27809;&#26377;&#38382;&#39064;&#30340;&#65292;backtrace &#33021;&#33258;&#21160;&#35782;&#21035;&#36825;&#20123;&#19996;&#35199;&#65288;&#24182;&#23558;&#20182;&#20204;&#31227;&#38500;&#65289;</P>
<P><FONT size=3 face="Ubuntu Mono">backtrace kernel.o Call stack: 0xc0106eff 0xc01102fb 0xc010dc22 0xc010cf67 0xc0102319 0xc010325a 0x804812c 0x8048a96 0x8048ac8.</FONT></P>
<P></SPAN><FONT size=3 face="Ubuntu Mono">