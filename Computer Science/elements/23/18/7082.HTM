<SPAN class=headers>Title:</SPAN></B><SPAN class=RefText> F List</SPAN></FONT> 
<P></P><SPAN class=extract>
<P>Pintos contains a linked list data structure in <STRONG>lib/kernel/list.h</STRONG> that is used for many di&#64256;erent pur- poses. This linked list implementation is di&#64256;erent from most other linked list implementations you may have encountered, because it does not use any dynamic memory allocation.</P>
<P>Pintos &#30340;&#38142;&#34920;&#25968;&#25454;&#32467;&#26500;&#20301;&#20110; lib/kernel/list.h &#25991;&#20214;&#20013;</P>
<P></SPAN><BR><BR><FONT size=3 face="Ubuntu Mono">/* List. */ <BR>struct list {<BR>&nbsp;&nbsp;&nbsp; struct list_elem head; /* List head. */ <BR>&nbsp;&nbsp;&nbsp; struct list_elem tail; /* List tail. */ <BR>};</FONT></P><SPAN class=extract>
<P>In a Pintos linked list, each list element contains a &#8220;<STRONG>struct list_elem</STRONG>&#8221;, which contains the pointers to the next and previous element. Because the list elements themselves have enough space to hold the <STRONG>prev</STRONG> and <STRONG>next</STRONG> pointers, we don&#8217;t need to allocate any extra space to support our linked list. Here is an example of a linked list element which can hold an integer:</P>
<P>Pintos &#20013;&#30340;&#38142;&#34920;&#26159;&#21452;&#21521;&#38142;&#34920;&#65292;&#38142;&#34920;&#30340;&#20803;&#32032;&#23454;&#38469;&#19978;&#21576;&#29616;&#23884;&#22871;&#20851;&#31995;&#65306;&#22806;&#23618;&#26159;&#33258;&#24049;&#22768;&#26126;&#30340;&#19968;&#20010;&#32467;&#26500;&#20307;&#65288;struct int_list_elem&#65289;&#20854;&#20803;&#32032;&#20010;&#25968;&#24517;&#28982;&#20026;&#20108;&#12290;&#35813;&#32467;&#26500;&#20307;&#30340;&#39318;&#20010;&#20803;&#32032;&#23601;&#26159;&#38142;&#34920;&#30340;&#25968;&#25454;&#31867;&#22411;&#65288;int value&#65289;&#65292;&#35813;&#32467;&#26500;&#20307;&#30340;&#31532;&#20108;&#20010;&#20803;&#32032;&#23601;&#26159;&#29992;&#20110;&#32500;&#25252;&#38142;&#34920;&#32467;&#26500;&#20307;&#30340;&#39592;&#26550;&#65288;struct list_elem elem&#65289;<BR><BR><FONT size=2 face="Ubuntu Mono">/* Integer linked list */ <BR>struct int_list_elem {<BR>&nbsp;&nbsp;&nbsp; int value; <BR>&nbsp;&nbsp;&nbsp; struct list_elem elem; <BR>};</FONT></P></SPAN>
<P>struct list_elem &#26377;&#20004;&#20010;&#23383;&#27573;&#65292;&#21069;&#19968;&#20010;&#23383;&#27573;&#26159;&#25351;&#21521;&#38142;&#34920;&#20013;&#21069;&#19968;&#20010;&#20803;&#32032;&#30340; elem &#30340;&#25351;&#38024;&#65292;&#21518;&#19968;&#20010;&#23383;&#27573;&#26159;&#25351;&#21521;&#38142;&#34920;&#20013;&#21518;&#19968;&#20010;&#20803;&#32032;&#30340; elem &#30340;&#25351;&#38024;&#65288;&#27880;&#24847;&#65292;&#20004;&#32773;&#30340;&#31867;&#22411;&#37117;&#20026; struct list_elem&#65289;&#65306;<BR><BR><FONT size=3 face="Ubuntu Mono">/* List element. */ <BR>struct list_elem {<BR>&nbsp;&nbsp;&nbsp; struct list_elem *prev;&nbsp; /* Previous list element. */ <BR>&nbsp;&nbsp;&nbsp; struct list_elem *next;&nbsp; /* Next list element. */ <BR>};</FONT></P>
<P>&#33267;&#20110;&#35848;&#21040;&#38142;&#34920;&#26412;&#36523;&#65292;&#21017;&#24517;&#39035;&#26159;&#19968;&#20010; struct list &#31867;&#22411;&#30340;&#32467;&#26500;&#20307;&#65292;&#35813;&#32467;&#26500;&#20307;&#20013;&#30340;&#20869;&#23481;&#23601;&#26159;&#38142;&#34920;&#39318;&#20301;&#20004;&#20010;&#20803;&#32032;&#30340; elem &#32467;&#26500;&#20307;&#26412;&#36523;</P>
<P>Next, you must create a &#8220;<STRONG>struct list</STRONG>&#8221; to represent the whole list. Initialize it with <STRONG>list_init().</STRONG><BR><BR><FONT size=3 face="Ubuntu Mono"><SPAN class=extract></P>
<P><FONT size=3 face="Ubuntu Mono">/* Declare and initialize a list */ <BR>struct list my_list; <BR>list_init (&amp;my_list);</FONT></P>
<P>&#22914;&#26524;&#24819;&#35201;&#21021;&#22987;&#21270;&#19968;&#20010;&#38142;&#34920;&#30340;&#35805;&#65292;&#39318;&#20808;&#35201;&#21021;&#22987;&#21270;&#36825;&#20010;&#38142;&#34920;&#26412;&#36523;&#65292;&#20063;&#23601;&#26159;&#22312;&#26632;&#20013;&#22768;&#26126;&#19968;&#20010;&nbsp;struct list &#32467;&#26500;&#20307;&#65292;&#24182;&#35843;&#29992; list_init &#23545;&#35813;&#32467;&#26500;&#20307;&#36827;&#34892;&#21021;&#22987;&#21270;</P></SPAN></FONT><SPAN class=extract>
<P>Now, you can declare a list element and add it to the end of the list. Notice that the second argument of <STRONG>list_push_back()</STRONG> is the address of a &#8220;<STRONG>struct list_elem</STRONG>&#8221;, not the &#8220;<STRONG>struct int_list_elem</STRONG>&#8221; itself.</P>
<P>&#38543;&#21518;&#65292;&#22914;&#26524;&#24819;&#35201;&#21521;&#25351;&#23450;&#38142;&#34920;&#20013;&#28155;&#21152;&#20803;&#32032;&#30340;&#35805;&#65292;&#19968;&#26041;&#38754;&#26159;&#38656;&#35201;&#22768;&#26126;&#19968;&#20010;&#38142;&#34920;&#20803;&#32032;&#65288;&#27880;&#24847;&#65292;&#24102;&#26377;&#29992;&#25143;&#21464;&#37327;&#65289;&#65292;&#21478;&#19968;&#26041;&#38754;&#26159;&#35843;&#29992; list_push_back &#20989;&#25968;</P>
<P>&#27880;&#24847; &nbsp;list_push_back &#20989;&#25968;&#30340;&#31532;&#19968;&#20010;&#21442;&#25968;&#26159;&#38142;&#34920;&#26412;&#36523;&#30340;&#22320;&#22336;&#65292;&#21478;&#19968;&#20010;&#21442;&#25968;&#26159;&#38142;&#34920;&#20803;&#32032;&#30340; elem &#20803;&#32032;&#30340;&#22320;&#22336;&#65288;&#30001;&#27492;&#26469;&#30475; list &#26412;&#36523;&#30340;&#20004;&#20010; elem &#20803;&#32032;&#20272;&#35745;&#26159;&#21736;&#20853;&#20540;&#65289;<BR><BR><FONT size=3 face="Ubuntu Mono">/* Declare a list element. */ <BR>struct int_list_elem three = {3, {NULL, NULL}};<BR><BR>/* Add it to the list */ <BR>list_push_back (&amp;my_list, &amp;three.elem);</FONT></P>
<P></SPAN><SPAN class=extract>&nbsp;</P>
<P>We can use the <STRONG>list_entry()</STRONG> macro to convert a generic &#8220;<STRONG>struct list_elem</STRONG>&#8221; into our custom &#8220;<STRONG>struct int_list_elem</STRONG>&#8221; type. Then, we can grab the &#8220;<STRONG>value</STRONG>&#8221; attribute and print it out:</P>
<P>&#21487;&#20197;&#20351;&#29992; list_begin &#33719;&#21462;&#38142;&#34920;&#30340;&#31532;&#19968;&#20010;&#20803;&#32032;&#65288;&#19981;&#26159;&#21736;&#20853;&#65289;</P>
<P>list_entry &#20989;&#25968;&#30340;&#20316;&#29992;&#26159;&#23558; list_elem &#31867;&#22411;&#36716;&#21270;&#20026; int_list_elem &#31867;&#22411;&#65292;&#25442;&#21477;&#35805;&#26469;&#35828;&#23601;&#26159;&#33719;&#21462;&#25351;&#23450; list_elem &#21464;&#37327;&#22312;&#25351;&#23450;&#38142;&#34920;&#20013;&#23545;&#24212;&#30340;&#38142;&#34920;&#20803;&#32032;<BR><BR><FONT size=3 face="Ubuntu Mono">/* Fetch elements from the list */ <BR>struct list_elem *first_list_element = list_begin (&amp;my_list); <BR>struct int_list_elem *first_integer = list_entry (first_list_element, struct int_list_elem, elem); <BR>printf("The first element is: %d\n", first_integer-&gt;value);</FONT></P>
<P></SPAN>By storing the prev and next pointers inside the structs themselves, we can avoid creating new &#8220;linked list element&#8221; containers. However, this also means that a <STRONG>list_elem</STRONG> can only be part of one list a time.</P>
<P>Additionally, our list should be homogeneous (it should only contain one type of element).</P><SPAN class=extract>
<P>The <STRONG>list_entry()</STRONG> macro works by computing the o&#64256;set of the <STRONG>elem</STRONG> &#64257;eld inside of &#8220;<STRONG>struct int_list_elem</STRONG>&#8221;.</P>
<P>&nbsp;<STRONG>list_entry()</STRONG> &#30340;&#21442;&#25968;&#21015;&#34920;&#38656;&#35201;&#26377;&#20197;&#19979;&#19996;&#35199;&#65306;&#31532;&#19968;&#20010;&#21442;&#25968;&#26159;&#25351;&#21521;&#38142;&#34920;&#20013;&#20803;&#32032; elem &#30340;&#25351;&#38024;&#65292;&#31532;&#20108;&#20010;&#26159;&#38142;&#34920;&#20803;&#32032;&#30340;&#31867;&#22411;&#65292;&#31532;&#19977;&#20010;&#26159;&#38142;&#34920;&#20803;&#32032;&#20013;&#31867;&#22411;&#20026; struct list_elem &#30340;&#21517;&#23383;</P></SPAN>
<P>In our example, this o&#64256;set is 4 bytes. To convert a pointer to a generic &#8220;<STRONG>struct list_elem</STRONG>&#8221; to a pointer to our custom &#8220;<STRONG>struct int_list_elem</STRONG>&#8221;, the <STRONG>list_entry()</STRONG> just needs to subtract 4 bytes! (It also casts the pointer, in order to satisfy the C type system.) Linked lists have 2 sentinel elements: the head and tail elements of the &#8220;<STRONG>struct list</STRONG>&#8221;. These sentinel elements can be distinguished by their NULL pointer values. Make sure to distinguish between functions that return the &#64257;rst actual element of a list and functions that return the sentinel head element of the list.</P>
<P>&nbsp;</P>
<P>There are also functions that sort a link list (using quicksort) and functions that insert an element into a sorted list. These functions require you to provide a list element comparison function (see <STRONG>lib/kernel/list.h</STRONG> for more details).