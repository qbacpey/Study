<SPAN class=headers>Title:</SPAN></B><SPAN class=RefText> G.5 GDB</SPAN></FONT><BR>
<P></P>
<P>You can read the GDB manual by typing <STRONG>info gdb</STRONG> at a terminal command prompt. Here&#8217;s a few commonly useful GDB commands: </P>
<P><STRONG>c</STRONG> Continues execution until ctrl+c or the next breakpoint.</P>
<P><STRONG>break function</STRONG> </P>
<P><STRONG>break &#64257;le:line</STRONG></P><STRONG><SPAN class=extract>
<P><STRONG>break *address</STRONG> Sets a breakpoint at <STRONG>function</STRONG>, at <STRONG>line</STRONG> within <STRONG>file</STRONG>, or <STRONG>address</STRONG>. (use a 0x pre&#64257;x to specify an address in hex.) </P>
<P>&#22914;&#26524;&#24819;&#35201;&#22312;&#26576;&#20010;&#22320;&#22336;&#35774;&#32622;&#26029;&#28857;&#30340;&#35805;&#65292;&#19968;&#26041;&#38754;&#35201;&#22312;&#22320;&#22336;&#21442;&#25968;&#30340;&#21069;&#38754;&#21152;&#19978;&#8220;*&#8221;&#65292;&#21478;&#19968;&#26041;&#38754;&#22914;&#26524;&#26159;&#21313;&#20845;&#36827;&#21046;&#22320;&#22336;&#30340;&#35805;&#65292;&#38656;&#35201;&#22312;&#22320;&#22336;&#21069;&#38754;&#21152;&#19978;&#21069;&#32512;&#8220;0x&#8221;</P></SPAN></STRONG><SPAN class=extract>
<P>Use break main to make GDB stop when Pintos starts running.</P>
<P>&#22914;&#26524;&#24819;&#35753; GDB &#22312; Pintos &#24320;&#22987;&#36816;&#34892;&#30340;&#26102;&#20505;&#20013;&#26029;&#23427;&#30340;&#35805;&#65292;&#21487;&#20197;&#25191;&#34892; break main</P></SPAN><STRONG><SPAN class=extract>
<P><STRONG>p expression</STRONG> Evaluates the given expression and prints its value. If the expression contains a function call, that function will actually be executed.</P>
<P>&#22914;&#26524; print&nbsp;&#30340;&#21442;&#25968;&#26159;&#19968;&#20010;&#20989;&#25968;&#65292;&#37027;&#20040; GDB &#20250;&#22312;&#25191;&#34892;&#36825;&#20010;&#20989;&#25968;&#20043;&#21518;&#25171;&#21360;&#23427;&#30340;&#36820;&#22238;&#20540;</P></SPAN></STRONG><SPAN class=extract>
<P>&nbsp;<STRONG>l *address</STRONG> Lists a few lines of code around address. (use a 0x pre&#64257;x to specify an address in hex.) </P>
<P>&#22914;&#26524;&#24819;&#35201;&#21015;&#20986; address &#21608;&#22260;&#30340;&#20960;&#34892;&#20195;&#30721;&#65292;&#21487;&#20197;&#25191;&#34892; l *address</P></SPAN><STRONG><SPAN class=extract>
<P><STRONG>bt</STRONG> Prints a stack backtrace similar to that output by the backtrace program described above. </P>
<P>&#25171;&#21360;&#24403;&#21069; backtrace</P></SPAN></STRONG><STRONG><SPAN class=extract>
<P><STRONG>p/a address</STRONG> Prints the name of the function or variable that occupies address. (use a 0x pre&#64257;x to specify an address in hex.)</P>
<P>&#25171;&#21360;&#21344;&#25454;&#20102;&#22320;&#22336; address &#30340;&#21464;&#37327;&#25110;&#20989;&#25968;&#30340;&#21517;&#23383;</P></SPAN></STRONG><STRONG><SPAN class=extract>
<P><STRONG>debugpintos</STRONG> Attach debugger to a waiting Pintos process on the same machine. Shorthand for <STRONG>target remote localhost:1234</STRONG>.</P>
<P>&#23558;&#35843;&#35797;&#22120;&#36830;&#25509;&#21040;&#24403;&#21069;&#27491;&#22312;&#31561;&#24453;&#30340; Pintos &#36827;&#31243;&#19978;</P></SPAN></STRONG><STRONG><SPAN class=extract>
<P><STRONG>dumplist &amp;list type element</STRONG> Prints the elements of <STRONG>list</STRONG>, which should be a struct list that contains elements of the given <STRONG>type</STRONG> (without the word struct) in which <STRONG>element</STRONG> is the <STRONG>struct list_elem</STRONG> member that links the elements.</P>
<P>&#38142;&#34920;&#20803;&#32032;&#20013;&#31867;&#22411;&#20026; list_elem &#30340;&#23383;&#27573;&#30340;&#20316;&#29992;&#23601;&#26159;&#23558;&#36825;&#20010;&#38142;&#34920;&#20803;&#32032;&#24402;&#20837;&#26576;&#19968;&#20010;&#38142;&#34920;&#20013;&#65292;&#38142;&#34920;&#20803;&#32032;&#26377;&#22810;&#23569;&#20010;&#36825;&#31181;&#31867;&#22411;&#30340;&#23383;&#27573;&#65292;&#23601;&#20195;&#34920;&#36825;&#20010;&#38142;&#34920;&#20803;&#32032;&#21487;&#33021;&#21516;&#26102;&#23646;&#20110;&#22810;&#23569;&#20010;&#38142;&#34920;</P></SPAN></STRONG><SPAN class=extract>
<P>Example: <STRONG>dumplist &amp;all_list thread allelem</STRONG> prints all elements of struct thread that are linked in <STRONG>struct list all_list</STRONG> using the <STRONG>struct list_elem allelem</STRONG> which is part of struct thread.</P>
<P>&#20855;&#20307;&#26469;&#35828;&#65292;&#36825;&#20010;&#23439;&#30340;&#31532;&#19968;&#20010;&#21442;&#25968;&#23601;&#26159;&#23558;&#35201;&#25171;&#21360;&#30340;&#38142;&#34920;&#30340;&#22320;&#22336;&#65292;&#31532;&#20108;&#20010;&#20803;&#32032;&#23601;&#26159;&#38142;&#34920;&#20803;&#32032;&#30340;&#31867;&#22411;&#65292;&#31532;&#19977;&#20010;&#20803;&#32032;&#23601;&#26159;&#38142;&#34920;&#20803;&#32032;&#20013;&#65292;&#31867;&#22411;&#20026; list_elem &#30340;&#20803;&#32032;&#30340;&#21517;&#31216;&#65288;&#24403;&#28982;&#35201;&#30475;&#22909;&#36825;&#20010;&#20803;&#32032;&#26159;&#19981;&#26159;&#21644;&#31532;&#19968;&#20010;&#21442;&#25968;&#37324;&#36793;&#23545;&#24212;&#30340;&#65289;</P></SPAN><STRONG><SPAN class=extract>
<P><STRONG>btthread thread</STRONG> Shows the backtrace of <STRONG>thread</STRONG>, which is a pointer to the struct <STRONG>thread</STRONG> of the thread whose backtrace it should show. For the current thread, this is identical to the bt (backtrace) command.<BR>It also works for any thread suspended in <STRONG>schedule</STRONG>, provided you know where its kernel stack page is located.</P>
<P>btthread thread &#30340;&#20316;&#29992;&#26159;&#25171;&#21360;&#25351;&#23450; TCB&#65288;struct thread&#65289;&#23545;&#24212;&#32447;&#31243;&#30340; backtrace</P>
<P>&#23545;&#20110;&#24403;&#21069;&#32447;&#31243;&#26469;&#35828;&#65292;&#25191;&#34892;&#36825;&#26465;&#21629;&#20196;&#30340;&#25928;&#26524;&#31561;&#21516;&#20110;&#25191;&#34892; bt &#30340;&#25928;&#26524;&#65292;&#27492;&#22806;&#65292;&#20063;&#21487;&#20197;&#23558;&#20219;&#20309;&#26242;&#20572;&#20110;&#35843;&#24230;&#22120;&#20013;&#30340;&#32447;&#31243;&#30340; TCB &#20256;&#36827;&#21435;</P>
<P></SPAN></STRONG><STRONG><SPAN class=extract>&nbsp;</P>
<P><STRONG>btthreadlist list</STRONG> <STRONG>element</STRONG> shows the backtraces of all threads in <STRONG>list</STRONG>, the <STRONG>struct</STRONG> <STRONG>list</STRONG> in which the threads are kept. Specify <STRONG>element</STRONG> as the <STRONG>struct list_elem</STRONG> &#64257;eld used inside <STRONG>struct_thread</STRONG> to link the threads together.</P>
<P>btthreadlist list element &#23637;&#31034; list &#20013;&#30340;&#25152;&#26377;&#32447;&#31243;&#65292;element &#23601;&#26159;&#23558; thread &#32467;&#26500;&#20307;&#36830;&#25509;&#36215;&#26469;&#30340;&#23383;&#27573;&#30340;&#21517;&#31216;</P>
<P>Example: <STRONG>btthreadlist all_list allelem</STRONG> shows the backtraces of all threads contained in <STRONG>struct list all_list</STRONG>, linked together by <STRONG>allelem</STRONG>. This command is useful to determine where your threads are stuck when a deadlock occurs. Please see the example scenario below.</P>
<P>&#19978;&#36848;&#21629;&#20196;&#23637;&#31034;&#20102;&#25152;&#26377;&#21253;&#21547;&#22312;&#38142;&#34920; struct list all_list &#30340;&#32447;&#31243;&#65292;&#38142;&#34920;&#20803;&#32032;&#26159;&#36890;&#36807; allelem &#23383;&#27573;&#36830;&#25509;&#36215;&#26469;&#30340;</P>
<P>&#36825;&#26465;&#21629;&#20196;&#22312;&#30830;&#23450;&#24403;&#27515;&#38145;&#21457;&#29983;&#26102;&#65292;&#24403;&#21069;&#32447;&#31243;&#25152;&#22788;&#20301;&#32622;&#30340;&#26102;&#20505;&#38750;&#24120;&#26377;&#29992;</P></SPAN></STRONG><STRONG><SPAN class=extract>
<P><STRONG>btpagefault</STRONG> Print a backtrace of the current thread after a page fault exception. Normally, when a page fault exception occurs, GDB will stop with a message that might say:</P>
<P><FONT size=3 face="Ubuntu Mono">program received signal 0, signal 0. 0xc0102320 in intr0e_stub ()</FONT></P>
<P>In that case, the bt command might not give a useful backtrace. Use <STRONG>btpagefault</STRONG> instead.</P>
<P>&#22914;&#26524;&#22312;&#24403;&#21069;&#32447;&#31243;&#21457;&#29983; page fault &#20043;&#21518;&#24819;&#35201;&#26597;&#30475;&#24403;&#21069;&#32447;&#31243;&#30340; backtrace&#65292;&#23601;&#21487;&#20197;&#25191;&#34892; btpagefault &#21629;&#20196;</P>
<P>You may also use <STRONG>btpagefault</STRONG> for page faults that occur in a user process. In this case, you may wish to also load the user program&#8217;s symbol table using the <STRONG>loadusersymbols</STRONG> macro, as described above. </P>
<P>&#27492;&#22806;&#65292;&#22914;&#26524;&#24819;&#35201;&#26597;&#30475;&#21457;&#29983; page fault &#30340;&#29992;&#25143;&#36827;&#31243;&#30340; backtrace&#65292;&#21487;&#33021;&#21516;&#26102;&#20063;&#38656;&#35201;&#20351;&#29992; loadusersymbols &#21152;&#36733;&#29992;&#25143;&#31243;&#24207;&#30340;&#31526;&#21495;&#34920;</P>
<P></SPAN></STRONG><STRONG><SPAN class=extract>&nbsp;</P>
<P><STRONG>hook-stop</STRONG> GDB invokes this macro every time the simulation stops, which Bochs will do for every processor exception, among other reasons. If the simulation stops due to a page fault, hook-stop will print a message that says and explains further whether the page fault occurred in the kernel or in user code.</P>
<P>&#27599;&#24403;&#27169;&#25311;&#22120;&#26242;&#20572;&#30340;&#26102;&#20505; GDB &#37117;&#20250;&#35843;&#29992;&#36825;&#20010;&#23439;&#65292;&#22914;&#26524;&#27169;&#25311;&#22120;&#26159;&#22240;&#20026; page fault &#26242;&#20572;&#30340;&#65292;&#37027;&#20040; hook-stop &#23601;&#20250;&#25171;&#21360;&#19968;&#26465;&#28040;&#24687;&#35299;&#37322; page fault &#21457;&#29983;&#30340;&#21407;&#22240;</P>
<P>If the exception occurred from user code, hook-stop will say:</P>
<P>&#22914;&#26524; page fault &#21457;&#29983;&#22312;&#29992;&#25143;&#20195;&#30721;&#20013;&#65292;&#37027;&#20040;&#36825;&#20010;&#23439;&#23601;&#20250;&#25171;&#21360;&#22914;&#19979;&#20449;&#24687;<BR><BR><FONT size=3 face="Ubuntu Mono">pintos-debug: a page fault exception occurred in user mode <BR>pintos-debug: hit 'c' to continue, or 's' to step to intr_handler</FONT></P>
<P>In Project Userprog, a page fault in a user process leads to the termination of the process. You should expect those page faults to occur in the robustness tests where we test that your kernel properly termi- nates processes that try to access invalid addresses. To debug those, set a breakpoint in page_fault in exception.c, which you will need to modify accordingly.</P>
<P>&#22914;&#26524;&#24819;&#35201;&#35843;&#35797; page fault &#21487;&#20197;&#22312; exception.c &#30340; page_fault &#20989;&#25968;&#20013;&#35774;&#32622;&#26029;&#28857;</P>
<P>If the page fault did not occur in user mode while executing a user process, then it occurred in kernel mode while executing kernel code. In this case, hook-stop will print this message:</P>
<P><FONT size=3 face="Ubuntu Mono">pintos-debug: a page fault occurred in kernel mode</FONT></P>
<P>Followed by the output of the btpagefault command. </P>
<P>&#22914;&#26524; page fault &#27809;&#26377;&#21457;&#29983;&#22312;&#29992;&#25143;&#27169;&#24335;&#19979;&#65292;&#37027;&#20040; hook-stop &#23601;&#20250;&#25171;&#21360;&#36825;&#26465;&#20449;&#24687;&#24182;&#32039;&#38543;&#30528; btpagefault &#30340;&#36755;&#20986;</SPAN></STRONG></P>
<P><BR><BR></P><SPAN class=extract>
<P>loadusersymbols You can also use GDB to debug a user program running under Pintos. To do that, use the loadusersymbols macro to load the program&#8217;s symbol table:<BR>loadusersymbol program<BR>Where program is the name of the program&#8217;s executable (in the host &#64257;le system, not in the Pintos &#64257;le system). For example, you may issue:<BR>(gdb) loadusersymbols tests/userprog/exec-multiple add symbol table from file "tests/userprog/exec-multiple" at .text_addr = 0x80480a0<BR>After this, you should be able to debug the user program the same way you would the kernel, by placing breakpoints, inspecting data, etc. Your actions apply to every user program running in Pintos, not just to the one you want to debug, so be careful in interpreting the results: GDb does not know which process is currently active (because that is an abstraction the Pintos kernel creates). Also, a name that appears in both the kernel and the user program will actually refer to the kernel name. (The latter problem can be avoided by giving the user executable name on the GDB command line, instead<BR>of kernel.o, and then using loadusersymbols to load kernel.o.) loadusersymbols is implemented<BR>via GDB&#8217;s add-symbol-file command.</P>
<P></SPAN>