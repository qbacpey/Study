<STRONG><FONT color=blue>Operating Systems: Principles and Practice (Second Edition) Volume II : 4. Concurrency and Threads : </FONT></STRONG>
<H4 class=subsectionHead><SPAN class=headers>Title:</SPAN></B><SPAN class=RefText> 4.6.2 Deleting a Thread</SPAN></FONT></H4>
<P>&nbsp;<SPAN class=extract></P>
<P>&#31616;&#21333;&#26469;&#35828;&#65292;&#22914;&#26524;&#24819;&#35201;&#21024;&#38500;&#26576;&#20010;&#32447;&#31243;&#30340;&#35805;&#65292;&#38656;&#35201;&#20570;&#20004;&#20214;&#20107;&#24773;&#65306;&#65288;1&#65289;&#23558;&#32447;&#31243;&#20174;&#20934;&#22791;&#21015;&#34920;&#20013;&#31227;&#38500;&#65292;&#65288;2&#65289;&#37322;&#25918;&#20043;&#21069;&#20026;&#32447;&#31243;&#39044;&#20808;&#20998;&#37197;&#30340;&#31354;&#38388;&#65288;&#27604;&#22914;&#35828;&#26632;&#21644; TCB &#25152;&#21344;&#30340;&#31354;&#38388;&#65289;</P>
<P>When a thread calls thread_exit, there are two steps to deleting the thread: </P>
<UL class=itemize1>
<LI class=itemize>
<P>Remove the thread from the ready list so that it will never run again. </P>
<LI class=itemize>
<P>Free the per-thread state allocated for the thread.</P></LI></UL></SPAN><SPAN class=extract>
<P>Although this seems easy, there is an important subtlety: if a thread removes itself from the ready list and frees its own per-thread state, then the program may break. For example, if a thread removes itself from the ready list but an interrupt occurs before the thread finishes de-allocating its state, there is a memory leak: that thread will never resume to de-allocate its state. </P>
<P>&#36825;&#25351;&#30340;&#24212;&#35813;&#26159;&#23558;&#32447;&#31243; TCB &#20174;&#20934;&#22791;&#21015;&#34920;&#20013;&#31227;&#38500;&#20043;&#21518;&#65292;&#22312;&#37322;&#25918;&#32447;&#31243;&#29366;&#24577;&#20043;&#21069;&#65292;&#24688;&#22909;&#26377;&#19968;&#20010;&#20013;&#26029;&#25554;&#20102;&#36827;&#26469;&#65292;&#36825;&#23601;&#23548;&#33268;&#35843;&#24230;&#22120;&#19981;&#21487;&#33021;&#22312;&#24448;&#21518;&#30340;&#20219;&#20309;&#19968;&#27425;&#32447;&#31243;&#19978;&#19979;&#25991;&#20999;&#25442;&#20013;&#20999;&#25442;&#21040;&#35813;&#32447;&#31243;&#65288;&#27605;&#31455;&#22914;&#26524;&#32447;&#31243; TCB &#27809;&#26377;&#20986;&#29616;&#22312;&#20219;&#20309;&#38431;&#21015;&#20013;&#30340;&#35805;&#65292;&#35843;&#24230;&#22120;&#26159;&#19981;&#21487;&#33021;&#20026;&#20854;&#20998;&#37197; CPU &#26102;&#38388;&#30340;&#65289;</P></SPAN><SPAN class=extract>
<P>Worse, suppose that a thread frees its own state? Can the thread finish running the code in thread_exit&nbsp;if it does not have a stack? What happens if an interrupt occurs just after the running thread&#8217;s stack has been de-allocated? If the context switch code tries to save the current thread&#8217;s state, it will be writing to de-allocated memory, possibly to storage that another processor has re-allocated for some other data structure. The result could be corrupted memory, where the specific behavior depends on the precise sequence of events. Needless to say, such a bug would be very difficult to locate. </P>
<P>&#36825;&#37324;&#25552;&#21040;&#20102;&#19968;&#31181;&#26356;&#21152;&#31967;&#31957;&#30340;&#24773;&#20917;&#65292;&#22914;&#26524;&#32447;&#31243;&#22312;&#37322;&#25918;&#20013;&#26029;&#26632;&#20043;&#21518;&#65292;&#22312;&#25191;&#34892;&#23436;&#27605; thread_exit &#20043;&#21069;&#65292;&#20013;&#26029;&#21457;&#29983;&#20102;&#65292;&#37027;&#20040;&#32771;&#34385;&#21040;&#19978;&#19979;&#25991;&#20999;&#25442;&#30340;&#26102;&#20505;&#20869;&#26680;&#38656;&#35201;&#23558;&#32447;&#31243;&#29366;&#24577;&#20445;&#23384;&#21040;&#20013;&#26029;&#26632;&#37324;&#36793;&#65288;&#24819;&#24819;&#37027;&#24352;&#22270;&#65292;&#27599;&#20010;&#32447;&#31243;&#37117;&#26377;&#30528;&#33258;&#24049;&#30340;&#20013;&#26029;&#26632;&#65289;&#30828;&#20214;&#21644;&#20013;&#26029;&#22788;&#29702;&#31243;&#24207;&#20250;&#23558;&#32447;&#31243;&#29366;&#24577;&#20445;&#23384;&#21040;&#36825;&#20010;&#24050;&#32463;&#34987;&#37322;&#25918;&#20102;&#30340;&#20869;&#23384;&#31354;&#38388;&#12290;&#26356;&#26377;&#21487;&#33021;&#30340;&#26159;&#65292;&#36825;&#20010;&#31354;&#38388;&#24050;&#32463;&#34987;&#20854;&#20182;&#32447;&#31243;&#25152;&#20351;&#29992;&#20102;&#65292;&#20063;&#23601;&#26159;&#35828;&#65292;&#36825;&#21487;&#33021;&#20250;&#36896;&#25104;&#24847;&#26009;&#20043;&#22806;&#30340;&#25968;&#25454;&#35206;&#30422;&#29616;&#35937;</P>
<P>&#24635;&#30340;&#26469;&#35828;&#65292;&#26681;&#25454;&#19978;&#38754;&#30340;&#20363;&#23376;&#20854;&#23454;&#19981;&#38590;&#30475;&#20986;&#65292;&#22914;&#26524;&#19981;&#33021;&#20445;&#35777;&#20013;&#26029;&#30456;&#23545;&#20110;&#32447;&#31243;&#30340;&#36864;&#20986;&#25805;&#20316;&#26159;&#36879;&#26126;&#30340;&#65292;&#37027;&#20040;&#23601;&#20250;&#24341;&#21457;&#35768;&#22810;&#38590;&#20197;&#23519;&#35273;&#30340;&#38382;&#39064;</P></SPAN><SPAN class=extract>
<P>Fortunately, there is a simple fix: a thread never deletes its own state. Instead, some other thread must do it. On exit, the thread transitions to the FINISHED&nbsp;state, moves its TCB from the ready list to a list of <EM>finished</EM> threads the scheduler should never run. The thread can then safely switch to the next thread on the ready list. Once the finished thread is no longer running, it is safe for some <EM>other</EM> thread to free the state of the thread. </P>
<P>&#26080;&#35770;&#22914;&#20309;&#65292;&#23454;&#36341;&#20013;&#19968;&#20010;&#32447;&#31243;&#24517;&#23450;&#19981;&#21487;&#33021;&#20146;&#25163;&#21024;&#38500;&#33258;&#24049;&#30340;&#29366;&#24577;&#65292;&#32780;&#24517;&#39035;&#30001;&#20854;&#20182;&#32447;&#31243;&#26469;&#23436;&#25104;&#36825;&#19968;&#20214;&#20107;&#12290;&#25191;&#34892; thread_exit &#26102;&#65292;&#32447;&#31243;&#20250;&#36716;&#20026; FINISHED &#29366;&#24577;&#65292;&#20854; TCB &#20250;&#34987;&#31227;&#21160;&#21040;&#23436;&#25104;&#21015;&#34920;&#20013;&#65288;finished list&#65289;&#20013;&#12290;&#35843;&#24230;&#22120;&#27704;&#36828;&#19981;&#20250;&#25191;&#34892;&#20301;&#20110;&#23436;&#25104;&#21015;&#34920;&#20013;&#30340;&#32447;&#31243;&#65292;&#19968;&#26086;&#32447;&#31243;&#34987;&#31227;&#21160;&#21040;&#23436;&#25104;&#21015;&#34920;&#65292;&#37027;&#20040;&#30001;&#20854;&#20182;&#32447;&#31243;&#26469;&#37322;&#25918;&#27492;&#36827;&#31243;&#30340;&#29366;&#24577;&#23601;&#26159;&#19968;&#20214;&#38750;&#24120;&#23433;&#20840;&#30340;&#20107;&#24773;<BR></P>
<P></SPAN>