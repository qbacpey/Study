<H1 style='FONT-FAMILY: "Microsoft YaHei"; WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; COLOR: rgb(10,10,255); FONT-STYLE: normal; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; TEXT-INDENT: 0px; font-variant-ligatures: normal; font-variant-caps: normal; -webkit-text-stroke-width: 0px; text-decoration-style: initial; text-decoration-color: initial'><SPAN class=headers>Title:</SPAN></B><SPAN class=RefText> <SPAN class=headers>Title:</SPAN></B><SPAN class=RefText> The fork() System Call</SPAN></FONT></SPAN></H1>
<P><SPAN class=extract>System call<SPAN>&nbsp;</SPAN><B>fork()</B><SPAN>&nbsp;</SPAN>is used to create processes</SPAN>. <SPAN class=extract>It takes no arguments and returns a process ID</SPAN>. <SPAN class=extract>The purpose of<SPAN>&nbsp;</SPAN><B>fork()</B><SPAN>&nbsp;</SPAN>is to create a<SPAN>&nbsp;</SPAN><B><I>new</I></B><SPAN>&nbsp;</SPAN>process, which becomes the<SPAN>&nbsp;</SPAN><I>child</I><SPAN>&nbsp;</SPAN>process of the caller</SPAN>. <SPAN class=extract></P>
<P>After a new child process is created,<SPAN>&nbsp;</SPAN><B><I>both</I></B><SPAN>&nbsp;</SPAN>processes will execute the next instruction following the<SPAN>&nbsp;</SPAN><B><I>fork()</I></B><SPAN>&nbsp;</SPAN>system call. Therefore, we have to distinguish the parent from the child. This can be done by testing the returned value of<SPAN>&nbsp;</SPAN><B>fork()</B>:</P>
<UL>
<LI>If<SPAN>&nbsp;</SPAN><B>fork()</B><SPAN>&nbsp;</SPAN>returns a negative value, the creation of a child process was unsuccessful. 
<LI><B>fork()</B><SPAN>&nbsp;</SPAN>returns a zero to the newly created child process. 
<LI><B>fork()</B><SPAN>&nbsp;</SPAN>returns a positive value, the<SPAN>&nbsp;</SPAN><B><I>process ID</I></B><SPAN>&nbsp;</SPAN>of the child process, to the parent. The returned process ID is of type<SPAN>&nbsp;</SPAN><B>pid_t</B><SPAN>&nbsp;</SPAN>defined in<SPAN>&nbsp;</SPAN><B>sys/types.h</B>. Normally, the process ID is an integer. Moreover, a process can use function<SPAN>&nbsp;</SPAN><B>getpid()</B><SPAN>&nbsp;</SPAN>to retrieve the process ID assigned to this process</LI></UL>
<P></SPAN>.</P>
<P style='FONT-FAMILY: "Microsoft YaHei"; WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; COLOR: rgb(10,10,255); FONT-STYLE: normal; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; TEXT-INDENT: 0px; font-variant-ligatures: normal; font-variant-caps: normal; -webkit-text-stroke-width: 0px; text-decoration-style: initial; text-decoration-color: initial'><FONT size=2><SPAN><SPAN class=extract><FONT size=2><SPAN>Therefore, after the system call to<SPAN>&nbsp;</SPAN></SPAN><B>fork()</B><SPAN>, a simple test can tell which process is the child</SPAN></FONT></SPAN></SPAN><SPAN>.<SPAN>&nbsp;</SPAN></SPAN><B><SPAN class=extract><B>Please note that Unix will make an<SPAN>&nbsp;</SPAN><BLINK>exact</BLINK><SPAN>&nbsp;</SPAN>copy of the parent's address space and give it to the child. Therefore, the parent and child processes have<SPAN>&nbsp;</SPAN><BLINK>separate</BLINK><SPAN>&nbsp;</SPAN>address spaces</B></SPAN></B><SPAN>.</SPAN></FONT> </P>
<P>Let us take an example to make the above points clear. This example does not distinguish parent and the child processes. Click<SPAN>&nbsp;</SPAN><A href="https://www.csl.mtu.edu/cs4411.ck/www/NOTES/process/fork/fork-01.c"><B>here</B></A><SPAN>&nbsp;</SPAN>to download this file<SPAN>&nbsp;</SPAN><B>fork-01.c</B>.<BR><FONT size=2>#include&nbsp; &lt;stdio.h&gt;<BR>#include&nbsp; &lt;string.h&gt;<BR>#include&nbsp; &lt;sys/types.h&gt;<BR><BR>#define&nbsp;&nbsp; MAX_COUNT&nbsp; 200<BR>#define&nbsp;&nbsp; BUF_SIZE&nbsp;&nbsp; 100<BR><BR>void&nbsp; main(void)<BR>{<BR>&nbsp;&nbsp;&nbsp;&nbsp; pid_t&nbsp; pid;<BR>&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp; i;<BR>&nbsp;&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp; buf[BUF_SIZE];<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp; fork();<BR>&nbsp;&nbsp;&nbsp;&nbsp; pid = getpid();<BR>&nbsp;&nbsp;&nbsp;&nbsp; for (i = 1; i &lt;= MAX_COUNT; i++) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sprintf(buf, "This line is from pid %d, value = %d\n", pid, i);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; write(1, buf, strlen(buf));<BR>&nbsp;&nbsp;&nbsp;&nbsp; } <BR>}</FONT><BR></P>
<P style='FONT-FAMILY: "Microsoft YaHei"; WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; COLOR: rgb(10,10,255); FONT-STYLE: normal; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; TEXT-INDENT: 0px; font-variant-ligatures: normal; font-variant-caps: normal; -webkit-text-stroke-width: 0px; text-decoration-style: initial; text-decoration-color: initial'><FONT size=2><SPAN>Suppose the above program executes up to the point of the call to<SPAN>&nbsp;</SPAN></SPAN><B>fork()</B><SPAN><SPAN>&nbsp;</SPAN>(marked in red color):</SPAN></FONT> </P>
<P></P>
<CENTER><img border=2 src="https://www.csl.mtu.edu/cs4411.ck/www/NOTES/process/fork/fork-1.jpg"></CENTER><SPAN class=extract>
<P>If the call to<SPAN>&nbsp;</SPAN><B>fork()</B><SPAN>&nbsp;</SPAN>is executed successfully, Unix will</P>
<UL>
<LI>make two identical copies of address spaces, one for the parent and the other for the child. 
<LI>Both processes will start their execution at the next statement following the<SPAN>&nbsp;</SPAN><B>fork()</B><SPAN>&nbsp;</SPAN>call. In this case, both processes will start their execution at the assignment statement as shown below:</LI></UL>
<CENTER><img border=2 src="https://www.csl.mtu.edu/cs4411.ck/www/NOTES/process/fork/fork-2.jpg"></CENTER></SPAN>
<P><SPAN class=extract>Both processes start their execution right after the system call<SPAN>&nbsp;</SPAN><B>fork()</B>. Since both processes have identical but separate address spaces, those variables initialized<SPAN>&nbsp;</SPAN><B>before</B><SPAN>&nbsp;</SPAN>the<SPAN>&nbsp;</SPAN><B>fork()</B><SPAN>&nbsp;</SPAN>call have the same values in both address spaces. Since every process has its own address space, any modifications will be independent of the others. In other words, if the parent changes the value of its variable, the modification will only affect the variable in the parent process's address space. Other address spaces created by<SPAN>&nbsp;</SPAN><B>fork()</B><SPAN>&nbsp;</SPAN>calls will not be affected even though they have identical variable names</SPAN>.</P>
<P><SPAN class=extract>What is the reason of using<SPAN>&nbsp;</SPAN><B>write</B><SPAN>&nbsp;</SPAN>rather than<SPAN>&nbsp;</SPAN><B>printf</B>? It is because<SPAN>&nbsp;</SPAN><B>printf()</B><SPAN>&nbsp;</SPAN>is "buffered," meaning<SPAN>&nbsp;</SPAN><B>printf()</B><SPAN>&nbsp;</SPAN>will group the output of a process together. While buffering the output for the parent process, the child may also use<SPAN>&nbsp;</SPAN><B>printf</B><SPAN>&nbsp;</SPAN>to print out some information, which will also be buffered. As a result, since the output will not be send to screen immediately, you may not get the right order of the expected result. Worse, the output from the two processes may be mixed in strange ways. To overcome this problem, you may consider to use the "unbuffered"<SPAN>&nbsp;</SPAN><B>write</B></SPAN>.</P>
<P>If you run this program, you might see the following on the screen:</P>
<BLOCKQUOTE><PRE>     ................
This line is from pid 3456, value 13
This line is from pid 3456, value 14
     ................
This line is from pid 3456, value 20
This line is from pid 4617, value 100
This line is from pid 4617, value 101
     ................
This line is from pid 3456, value 21
This line is from pid 3456, value 22
     ................
</PRE></BLOCKQUOTE>
<P style='FONT-FAMILY: "Microsoft YaHei"; WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; COLOR: rgb(10,10,255); FONT-STYLE: normal; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; TEXT-INDENT: 0px; font-variant-ligatures: normal; font-variant-caps: normal; -webkit-text-stroke-width: 0px; text-decoration-style: initial; text-decoration-color: initial'><SPAN><FONT size=2>.</FONT></SPAN> </P>
<P>Consider one more simple example, which distinguishes the parent from the child. Click<SPAN>&nbsp;</SPAN><A href="https://www.csl.mtu.edu/cs4411.ck/www/NOTES/process/fork/fork-02.c"><B>here</B></A><SPAN>&nbsp;</SPAN>to download this file<SPAN>&nbsp;</SPAN><B>fork-02.c</B>.<BR><BR><FONT size=2>#include&nbsp; &lt;stdio.h&gt;<BR>#include&nbsp; &lt;sys/types.h&gt;<BR>#define&nbsp;&nbsp; MAX_COUNT&nbsp; 200<BR>void&nbsp; ChildProcess(void);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* child process prototype&nbsp; */<BR>void&nbsp; ParentProcess(void);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* parent process prototype */<BR>void&nbsp; main(void)<BR>{<BR>&nbsp;&nbsp;&nbsp;&nbsp; pid_t&nbsp; pid;<BR>&nbsp;&nbsp;&nbsp;&nbsp; pid = fork();<BR>&nbsp;&nbsp;&nbsp;&nbsp; if (pid == 0) <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ChildProcess();<BR>&nbsp;&nbsp;&nbsp;&nbsp; else <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ParentProcess();<BR>}<BR>void&nbsp; ChildProcess(void)<BR>{<BR>&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; i;<BR>&nbsp;&nbsp;&nbsp;&nbsp; for (i = 1; i &lt;= MAX_COUNT; i++)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("&nbsp;&nbsp; This line is from child, value = %d\n", i);<BR>&nbsp;&nbsp;&nbsp;&nbsp; printf("&nbsp;&nbsp; *** Child process is done ***\n");<BR>}<BR>void&nbsp; ParentProcess(void)<BR>{<BR>&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; i;<BR>&nbsp;&nbsp;&nbsp;&nbsp; for (i = 1; i &lt;= MAX_COUNT; i++)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("This line is from parent, value = %d\n", i);<BR>&nbsp;&nbsp;&nbsp;&nbsp; printf("*** Parent is done ***\n");<BR>}</FONT><BR></P>
<P style='FONT-FAMILY: "Microsoft YaHei"; WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; COLOR: rgb(10,10,255); FONT-STYLE: normal; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; TEXT-INDENT: 0px; font-variant-ligatures: normal; font-variant-caps: normal; -webkit-text-stroke-width: 0px; text-decoration-style: initial; text-decoration-color: initial'><FONT size=2><SPAN>In this program, both processes print lines that indicate (1) whether the line is printed by the child or by the parent process, and (2) the value of variable<SPAN>&nbsp;</SPAN></SPAN><B>i</B><SPAN>. For simplicity,<SPAN>&nbsp;</SPAN></SPAN><B>printf()</B></FONT><SPAN><FONT size=2><SPAN>&nbsp;</SPAN>is used</FONT>.</SPAN> </P>
<P>When the main program executes<SPAN>&nbsp;</SPAN><B>fork()</B>, an identical copy of its address space, including the program and all data, is created. System call<SPAN>&nbsp;</SPAN><B>fork()</B><SPAN>&nbsp;</SPAN>returns the child process ID to the parent and returns 0 to the child process. The following figure shows that in both address spaces there is a variable<SPAN>&nbsp;</SPAN><B>pid</B>. The one in the parent receives the child's process ID 3456 and the one in the child receives 0.</P>
<P></P>
<CENTER><img style="HEIGHT: 278px; WIDTH: 507px" border=2 src="https://www.csl.mtu.edu/cs4411.ck/www/NOTES/process/fork/fork-3.jpg" width=582 height=345></CENTER>
<P>Now both programs (<I>i.e.</I>, the parent and child) will execute independent of each other starting at the next statement:</P>
<P></P>
<CENTER><img style="HEIGHT: 303px; WIDTH: 483px" border=2 src="https://www.csl.mtu.edu/cs4411.ck/www/NOTES/process/fork/fork-4.jpg" width=583 height=344></CENTER>
<P>In the parent, since<SPAN>&nbsp;</SPAN><B>pid</B><SPAN>&nbsp;</SPAN>is non-zero, it calls function<SPAN>&nbsp;</SPAN><B>ParentProcess()</B>. On the other hand, the child has a zero<SPAN>&nbsp;</SPAN><B>pid</B><SPAN>&nbsp;</SPAN>and calls<SPAN>&nbsp;</SPAN><B>ChildProcess()</B><SPAN>&nbsp;</SPAN>as shown below:</P>
<P></P>
<CENTER><img style="HEIGHT: 288px; WIDTH: 479px" border=2 src="https://www.csl.mtu.edu/cs4411.ck/www/NOTES/process/fork/fork-5.jpg" width=582 height=345></CENTER>
<P>Due to the fact that the CPU scheduler will assign a time quantum to each process, the parent or the child process will run for some time before the control is switched to the other and the running process will print some lines before you can see any line printed by the other process. Therefore, the value of<SPAN>&nbsp;</SPAN><B>MAX_COUNT</B><SPAN>&nbsp;</SPAN>should be large enough so that both processes will run for at least two or more time quanta. If the value of<SPAN>&nbsp;</SPAN><B>MAX_COUNT</B><SPAN>&nbsp;</SPAN>is so small that a process can finish in one time quantum, you will see two groups of lines, each of which contains all lines printed by the same process.