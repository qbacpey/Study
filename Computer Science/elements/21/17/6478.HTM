<SPAN class=headers>Title:</SPAN></B><SPAN class=RefText> B.7 Program Startup Details</SPAN></FONT> 
<P></P><SPAN class=extract>
<P>The Pintos C library for user programs designates _start(), in lib/user/entry.c, as the entry point for user programs. This function is a wrapper around main() that calls exit() if main() returns:</P>
<P>&#36827;&#31243;&#30340;&#26729;&#20989;&#25968;&#65288;_start()&#65289;&#23454;&#29616;&#20301;&#20110; lib/user/entry.c &#20013;&#65292;&#23427;&#23454;&#38469;&#19978;&#23601;&#26159;&#29992;&#25143;&#31243;&#24207;&#30340;&#20837;&#21475;<BR><BR>&nbsp;&nbsp;&nbsp; void _start (int argc, char *argv[]) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit (main (argc, argv));<BR>&nbsp;&nbsp;&nbsp; }</P>
<P></SPAN><BR>&nbsp;</P><SPAN class=extract>
<P>The kernel must put the arguments for the initial function on the stack before it allows the user program to begin executing. The arguments are passed in the same way as the normal calling convention (see 80x86 Calling Convention).</P>
<P>&#20869;&#26680;&#38656;&#35201;&#22312;&#20801;&#35768;&#29992;&#25143;&#31243;&#24207;&#25191;&#34892;&#20043;&#21069;&#23558;&#26729;&#20989;&#25968;&#30340;&#21442;&#25968;&#25918;&#21040;&#29992;&#25143;&#26632;&#20013;</P></SPAN><SPAN class=extract>
<P>Consider how to handle arguments for the following example command: /bin/ls -l foo bar. First, break the command into words: /bin/ls, -l, foo, bar. Place the words at the top of the stack. Order doesn&#8217;t matter, because they will be referenced through pointers.</P>
<P>&#23545;&#20110;&#19978;&#36848;&#21442;&#25968;&#65292;&#39318;&#20808;&#30452;&#25509;&#23558;&#23427;&#20204;&#20840;&#37096;&#25918;&#20837;&#26632;&#20013;&#65288;&#27880;&#24847;&#35201;&#22312;&#26411;&#23614;&#21152;&#19978;&#31354;&#23383;&#31526;&#65289;&#12290;&#30001;&#20110;&#20043;&#21518;&#20250;&#20351;&#29992;&#22320;&#22336;&#24341;&#29992;&#23427;&#20204;&#30340;&#32536;&#25925;&#65292;&#22240;&#27492;&#39034;&#24207;&#24182;&#19981;&#37325;&#35201;</P></SPAN><SPAN class=extract>
<P>Then, push the address of each string plus a null pointer sentinel, on the stack, in right-to-left order. These are the elements of argv. The null pointer sentinel ensures that argv[argc] is a null pointer, as required by the C standard. The order ensures that argv[0] is at the lowest virtual address. </P>
<P>&#38543;&#21518;&#65292;&#23558;&#25351;&#21521;&#36825;&#20123;&#21442;&#25968;&#30340;&#25351;&#38024;&#65292;&#25353;&#29031;&#21442;&#25968;&#36755;&#20837;&#30340;&#20498;&#24207;&#65288;&#23454;&#38469;&#19978;&#23601;&#26159;&#35843;&#29992;&#32422;&#23450;&#20013;&#22768;&#26126;&#30340;&#21442;&#25968;&#21015;&#34920;&#30340;&#20837;&#26632;&#39034;&#24207;&#65289;&#21387;&#20837;&#26632;&#20013;&#65292;&#21516;&#26102;&#20063;&#38656;&#35201;&#21387;&#20837;&#19968;&#20010;&#31354;&#25351;&#38024;&#65292;&#30830;&#20445; argv[argc] &#26159;&#19968;&#20010;&#21736;&#20853;&#31354;&#25351;&#38024;</P></SPAN><SPAN class=extract>
<P>The x86 ABI requires that %esp be aligned to a 16-byte boundary at the time the call instruction is executed (e.g., at the point where all arguments are pushed to the stack), so make sure to leave enough empty space on the stack so that this is achieved.</P>
<P>&#30001;&#20110; x86 ABI &#35201;&#27714;&#22312;&#25191;&#34892; call &#25351;&#20196;&#20043;&#21069;&#65292;%ESP &#23545;&#20854; 16-byte&#65292;&#22240;&#27492;&#22312;&#35843;&#29992;&#20043;&#21069;&#38656;&#35201;&#23545;&#40784;&#22320;&#22336;</P></SPAN><SPAN class=extract>
<P>Then, push argv (the address of argv[0]) and argc, in that order. Finally, push a fake &#8220;return address&#8221;: although the entry function will never return, its stack frame must have the same structure as any other.</P>
<P>&#38543;&#21518;&#65292;&#20381;&#27425;&#23558; argv &#21644; argc &#21387;&#20837;&#26632;&#20013;&#65292;&#24182;&#21387;&#20837;&#19968;&#20010;&#20266;&#36820;&#22238;&#22320;&#22336;&#65288;&#20316;&#20026;&#26729;&#20989;&#25968;&#25191;&#34892;&#23436;&#27605;&#21518;&#30340;&#36820;&#22238;&#22320;&#22336;&#65292;&#23613;&#31649;&#26729;&#20989;&#25968;&#23454;&#38469;&#19978;&#27704;&#36828;&#19981;&#20250;&#36820;&#22238;&#65292;&#20294;&#26159;&#20026;&#20102;&#30830;&#20445;&#32467;&#26500;&#30340;&#19968;&#33268;&#24615;&#65292;&#36824;&#26159;&#38656;&#35201;&#36825;&#26679;&#20570;&#65289;</P></SPAN>
<P>The table below shows the state of the stack and the relevant registers right before the beginning of the userprogram, assuming PHYS_BASE is 0xc0000000:</P><SPAN class=extract>
<P>As shown above, your code should start the stack at the very top of the user virtual address space, in the page just below virtual address PHYS_BASE (de&#64257;ned in threads/vaddr.h).</P>
<P>&#27880;&#24847;&#65292;&#26729;&#20989;&#25968;&#30340; argv &#23383;&#31526;&#20018;&#30340;&#30495;&#27491;&#25152;&#22312;&#20301;&#32622;&#26159;&#29992;&#25143;&#26632;&#34394;&#25311;&#22320;&#22336;&#31354;&#38388;&#30340;&#39030;&#37096;&#65292;&#20063;&#23601;&#26159; PHYS_BASE &#30340;&#27491;&#19979;&#26041;</P>
<P>&#22914;&#26524;&#24819;&#35201;&#20462;&#25913; PHYS_BASE &#30340;&#35805;&#65292;&#21487;&#20197;&#22312; threads/vaddr.h &#20013;&#36827;&#34892;&#20462;&#25913;</P></SPAN><SPAN class=extract>
<P>You may &#64257;nd the non-standard hex_dump() function, declared in &lt;stdio.h&gt;, useful for debugging your argument passing code. Here&#8217;s what it would show in the above example:</P>
<P>&#22914;&#26524;&#24819;&#35201;&#35843;&#35797;&#21442;&#25968;&#20256;&#36882;&#20195;&#30721;&#30340;&#35805;&#65292;&#21487;&#20197;&#25191;&#34892; stdio.h &#20013;&#30340; hex_dump() &#20989;&#25968;</P>
<P></SPAN>