There are at least two reasonable ways to do this correctly:</P>
<P>&#26377;&#20004;&#31181;&#26041;&#24335;&#33021;&#26816;&#26597;&#29992;&#25143;&#20256;&#36882;&#32473;&#20869;&#26680;&#30340;&#22320;&#22336;&#26159;&#21542;&#21512;&#27861;&#65306;</P>
<P>&#8226; verify the validity of a user-provided pointer, then dereference it. If you choose this route, you&#8217;ll want to look at the functions in userprog/pagedir.c and in threads/vaddr.h. This is the simplest way to handle user memory access. </P>
<P>&#31532;&#19968;&#31181;&#26159;&#23436;&#20840;&#30830;&#35748;&#22320;&#22336;&#30340;&#21512;&#27861;&#24615;&#20043;&#21518;&#20877;&#23558;&#20854;&#35299;&#24341;&#29992;&#65292;&#36825;&#31181;&#26041;&#24335;&#38656;&#35201;&#20351;&#29992; userprog/pagedir.c &#20013;&#30340;&#20989;&#25968;&#21644; threads/vaddr.h &#20013;&#30340;&#20989;&#25968;</P>
<P>&#8226; check only that a user pointer points below PHYS_BASE, then dereference it. An invalid user pointer will cause a &#8220;page fault&#8221; that you can handle by modifying the code for page_fault() in userprog/exception.c. This technique is normally faster because it takes advantage of the processor&#8217;s MMU, so it tends to be used in real kernels (including Linux).</P>
<P>&#31532;&#20108;&#31181;&#26041;&#24335;&#26159;&#20165;&#30830;&#35748;&#25351;&#38024;&#20013;&#30340;&#22320;&#22336;&#26159;&#21542;&#25351;&#21521; PHYS_BASE &#30340;&#19979;&#26041;&#65292;&#22914;&#26524;&#26159;&#37027;&#20040;&#23601;&#23558;&#20854;&#35299;&#24341;&#29992;&#12290;&#32771;&#34385;&#21040;&#22320;&#22336;&#26412;&#36523;&#26377;&#21487;&#33021;&#19981;&#21512;&#27861;&#65292;&#22240;&#27492;&#38656;&#35201;&#20462;&#25913; page_fault() &#20989;&#25968;&#26469;&#24212;&#23545;&#36825;&#31181;&#24773;&#20917;