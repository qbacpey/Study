</FONT><STRONG><FONT style="BACKGROUND-COLOR: #f7e394" size=5></FONT></STRONG>As part of a system call, the kernel must often access memory through pointers provided by a user program. The kernel must be very careful about doing so, because the user can pass a null pointer, a pointer to unmapped virtual memory, or a pointer to kernel virtual address space (above PHYS_BASE). All of these types of invalid pointers must be rejected without harm to the kernel or other running processes, by terminating the o&#64256;ending process and freeing its resources. 
<P></P><SPAN class=extract>
<P>There are at least two reasonable ways to do this correctly:</P>
<P>&#26377;&#20004;&#31181;&#26041;&#24335;&#33021;&#26816;&#26597;&#29992;&#25143;&#20256;&#36882;&#32473;&#20869;&#26680;&#30340;&#22320;&#22336;&#26159;&#21542;&#21512;&#27861;&#65306;</P>
<P>&#8226; verify the validity of a user-provided pointer, then dereference it. If you choose this route, you&#8217;ll want to look at the functions in userprog/pagedir.c and in threads/vaddr.h. This is the simplest way to handle user memory access. </P>
<P>&#31532;&#19968;&#31181;&#26159;&#23436;&#20840;&#30830;&#35748;&#22320;&#22336;&#30340;&#21512;&#27861;&#24615;&#20043;&#21518;&#20877;&#23558;&#20854;&#35299;&#24341;&#29992;&#65292;&#36825;&#31181;&#26041;&#24335;&#38656;&#35201;&#20351;&#29992; userprog/pagedir.c &#20013;&#30340;&#20989;&#25968;&#21644; threads/vaddr.h &#20013;&#30340;&#20989;&#25968;</P>
<P>&#8226; check only that a user pointer points below PHYS_BASE, then dereference it. An invalid user pointer will cause a &#8220;page fault&#8221; that you can handle by modifying the code for page_fault() in userprog/exception.c. This technique is normally faster because it takes advantage of the processor&#8217;s MMU, so it tends to be used in real kernels (including Linux).</P>
<P>&#31532;&#20108;&#31181;&#26041;&#24335;&#26159;&#20165;&#30830;&#35748;&#25351;&#38024;&#20013;&#30340;&#22320;&#22336;&#26159;&#21542;&#25351;&#21521; PHYS_BASE &#30340;&#19979;&#26041;&#65292;&#22914;&#26524;&#26159;&#37027;&#20040;&#23601;&#23558;&#20854;&#35299;&#24341;&#29992;&#12290;&#32771;&#34385;&#21040;&#22320;&#22336;&#26412;&#36523;&#26377;&#21487;&#33021;&#19981;&#21512;&#27861;&#65292;&#22240;&#27492;&#38656;&#35201;&#20462;&#25913; page_fault() &#20989;&#25968;&#26469;&#24212;&#23545;&#36825;&#31181;&#24773;&#20917;</P>
<P></SPAN><SPAN class=extract>&nbsp;</P>
<P>In either case, you need to make sure not to &#8220;leak&#8221; resources. For example, suppose that your system call has acquired a lock or allocated memory with malloc(). If you encounter an invalid user pointer afterward, you must still be sure to release the lock or free the page of memory. If you choose to verify user pointers before dereferencing them, this should be straightforward. It&#8217;s more di&#64259;cult to handle if an invalid pointer causes a page fault, because there&#8217;s no way to return an error code from a memory access. Therefore, for those who want to try the latter technique, we&#8217;ll provide a little bit of helpful code:</P>
<P>&#21478;&#22806;&#36824;&#38656;&#35201;&#27880;&#24847;&#30830;&#20445;&#36164;&#28304;&#34987;&#23436;&#25972;&#37322;&#25918;&#65292;&#20855;&#20307;&#26469;&#35828;&#23601;&#26159;&#22914;&#26524;&#22320;&#22336;&#19981;&#21512;&#27861;&#65292;&#23545;&#20110;&#31532;&#19968;&#31181;&#24773;&#20917;&#26469;&#35828;&#65292;&#30001;&#20110;&#26159;&#22312;&#24341;&#21457; page_fault &#20043;&#21069;&#65292;&#38024;&#23545;&#22320;&#22336;&#30340;&#26657;&#39564;&#34892;&#20026;&#20013;&#21457;&#29616;&#22320;&#22336;&#19981;&#21512;&#27861;&#65292;&#37027;&#20040;&#20869;&#26680;&#23601;&#21487;&#20197;&#36820;&#22238;&#29992;&#25143;&#36827;&#31243;&#24182;&#37322;&#25918;&#36164;&#28304;&#12290;&#20294;&#26159;&#23545;&#20110;&#31532;&#20108;&#31181;&#24773;&#20917;&#26469;&#35828;&#65292;&#30001;&#20110;&#24050;&#32463;&#24341;&#21457;&#20102; page_fault &#22240;&#27492;&#27809;&#26377;&#21150;&#27861;&#20174;&#20869;&#23384;&#35775;&#38382;&#20013;&#36820;&#22238;&#38169;&#35823;&#30721;&#65292;&#20063;&#23601;&#27809;&#26377;&#21150;&#27861;&#37322;&#25918;&#37027;&#20123;&#36164;&#28304;&#12290;&#20026;&#27492;&#65292;&#25991;&#26723;&#20013;&#32473;&#20986;&#20102;&#19968;&#20123;&#24110;&#21161;&#20195;&#30721;&#65306;</P>
<P></SPAN><SPAN class=extract>&nbsp;</P>
<P>Each of these functions assumes that the user address has already been veri&#64257;ed to be below PHYS_BASE. They also assume that you&#8217;ve modi&#64257;ed page_fault() so that a page fault in the kernel merely sets eax to 0xffffffff and copies its former value into eip.</P>
<P>&#24110;&#21161;&#20195;&#30721;&#20013;&#30340;&#27599;&#20010;&#29992;&#25143;&#22320;&#22336;&#37117;&#38656;&#35201;&#22312; PHYS_BASE &#30340;&#19979;&#26041;&#65292;&#23427;&#20204;&#21516;&#26102;&#20063;&#20551;&#35774; page_fault() &#20989;&#25968;&#24050;&#32463;&#34987;&#20462;&#25913;&#22240;&#27492;&#20869;&#26680;&#20013;&#30340; page fault &#20165;&#23558; eax &#35774;&#32622;&#20026; 0xffffffff &#24182;&#23558;&#21069;&#32773;&#30340;&#20540;&#22797;&#21046;&#21040; EIP &#20013;</P></SPAN><SPAN class=extract>
<P>If you do choose to use the second option (rely on the processor&#8217;s MMU to detect bad user pointers), do not feel pressured to use the get_user and put_user functions from above. There are other ways to modify the page fault handler to identify and terminate processes that pass bad pointers as arguments to system calls, some of which are simpler and faster than using get_user and put_user to handle each byte.</P>
<P>&#19981;&#36807;&#65292;&#20854;&#23454;&#19981;&#20351;&#29992;&#19978;&#25991;&#25552;&#21040;&#30340; get &#21644; put &#20989;&#25968;&#20063;&#26159;&#21487;&#34892;&#30340;&#65292;&#20854;&#23454;&#20063;&#26377;&#20854;&#20182;&#21150;&#27861;&#33021;&#20462;&#25913; page_fault &#22788;&#29702;&#31243;&#24207;&#20196;&#20854;&#26631;&#35782;&#24182;&#32467;&#26463;&#34892;&#20026;&#38169;&#35823;&#30340;&#36827;&#31243;</P>
<P></SPAN>