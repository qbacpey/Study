<SPAN class=headers>Title:</SPAN></B><SPAN class=RefText> thread struct &#20013;&#23383;&#27573;&#30340;&#21547;&#20041;</SPAN></FONT> 
<P></P><SPAN class=extract>
<P>&#8226; Member of struct thread: tid_t tid</P>
<P>The thread&#8217;s thread identi&#64257;er or tid. Every thread must have a tid that is unique over the entire lifetime of the kernel. By default, tid_t is a typedef for int and each new thread receives the numerically next higher tid, starting from 1 for the initial process.</P>
<P>tid &#26159;&#32447;&#31243;&#30340;&#26631;&#35782;&#31526;&#65288;ID&#65289;&#27599;&#20010;&#32447;&#31243;&#22312;&#20854;&#22768;&#26126;&#21608;&#26399;&#20869;&#37117;&#38656;&#35201;&#26377;&#19968;&#20010;&#29420;&#19968;&#26080;&#20108;&#30340;&#32447;&#31243; id&#65292;&#19968;&#33324;&#26469;&#35828; tid_t &#37117;&#26159; int &#30340; typedef</P>
<P>&#23427;&#19968;&#33324;&#20250;&#20174; 1 &#24320;&#22987;&#36882;&#22686;</P></SPAN>
<P>&#8226; Member of struct thread: enum thread_status status</P>
<P>The thread&#8217;s state, one of the following:</P><SPAN class=extract>
<P>&#8211; Thread State: THREAD_RUNNING The thread is running. Exactly one thread is running at a given time. thread_current() returns the running thread.</P>
<P>&#24403; thread_status &#26159; THREAD_RUNNING &#30340;&#26102;&#20505;&#65292;&#20195;&#34920;&#32447;&#31243;&#27491;&#22312;&#36816;&#34892;&#65292;&#20219;&#24847;&#26102;&#21051;&#21482;&#33021;&#26377;&#19968;&#20010;&#32447;&#31243;&#26159;&#36825;&#20010;&#29366;&#24577;</P></SPAN><SPAN class=extract>
<P>thread_current() &#20250;&#36820;&#22238;&#24403;&#21069;&#27491;&#22312;&#36816;&#34892;&#30340;&#32447;&#31243;&#30340;&#32467;&#26500;&#20307;</P>
<P></SPAN><SPAN class=extract>&nbsp;</P>
<P>&#8211; Thread State: THREAD_READY The thread is ready to run, but it&#8217;s not running right now. The thread could be selected to run the next time the scheduler is invoked. Ready threads are kept in a doubly linked list called ready_list. </P>
<P>&#20934;&#22791;&#22909;&#36816;&#34892;&#30340;&#32447;&#31243;&#65288;&#29366;&#24577;&#20026; THREAD_READY&#65289;&#20250;&#34987;&#19968;&#20010;&#21517;&#20026; ready_list &#30340;&#21452;&#21521;&#38142;&#34920;&#25152;&#20445;&#23384;</P>
<P></SPAN><SPAN class=extract>&nbsp;</P>
<P>&#8211; Thread State: THREAD_BLOCKED The thread is waiting for something, e.g. a lock to become available, an interrupt to be invoked. The thread won&#8217;t be scheduled again until it transitions to the THREAD_READY state with a call to thread_unblock(). This is most conveniently done indirectly, using one of the Pintos synchronization primitives that block and unblock threads automatically.</P>
<P>&#24403;&#32447;&#31243;&#22240;&#20026;&#26576;&#31181;&#21407;&#22240;&#34987;&#38459;&#22622;&#26102;&#65288;&#38145;&#12289;&#31561;&#24453;&#34987;&#35843;&#29992;&#30340;&#20013;&#26029;&#65289;&#65292;&#23601;&#20250;&#22788;&#20110; THREAD_BLOCKED &#29366;&#24577;&#12290;&#30452;&#21040;&#32447;&#31243;&#30340;&#29366;&#24577;&#34987;&#36716;&#20026; THREAD_READY &#20043;&#21069;&#65292;&#32447;&#31243;&#37117;&#19981;&#20250;&#34987;&#35843;&#24230;&#22120;&#35843;&#24230;&#20026;&#36816;&#34892;&#12290;</P>
<P>&#22914;&#26524;&#24819;&#35201;&#23558;&#19968;&#20010;&#20301;&#20110;&#38459;&#22622;&#29366;&#24577;&#30340;&#32447;&#31243;&#36716;&#20026; THREADY_READY &#29366;&#24577;&#65292;&#38656;&#35201;&#35843;&#29992; thread_unblock &#20989;&#25968;&#12290;&#19968;&#33324;&#26469;&#35828;&#65292;&#36825;&#20010;&#20989;&#25968;&#37117;&#26159;&#36890;&#36807; Pintos &#30340;&#21516;&#27493;&#21407;&#35821;&#38388;&#25509;&#35843;&#29992;&#30340;</P></SPAN><SPAN class=extract>
<P>&#8211; Thread State: THREAD_DYING The thread has exited and will be destroyed by the scheduler after switching to the next thread.</P>
<P>&#24403;&#32447;&#31243;&#22788;&#20110; THREAD_DYING &#29366;&#24577;&#26102;&#65292;&#20195;&#34920;&#27492;&#32447;&#31243;&#24050;&#32463;&#36864;&#20986;&#65292;&#21516;&#26102;&#22312;&#20999;&#25442;&#21040;&#21478;&#19968;&#20010;&#32447;&#31243;&#20043;&#21518;&#65292;&#23601;&#20250;&#34987;&#35843;&#24230;&#22120;&#21024;&#38500;&#65288;&#25481;&#23427;&#30340;&#32447;&#31243;&#32467;&#26500;&#20307;&#65289;</P>
<P></SPAN><SPAN class=extract>&nbsp;</P>
<P>&#8226; Member of struct thread: char name[16] </P>
<P>The thread&#8217;s name as a string, or at least the &#64257;rst few characters of it.</P>
<P>&#32447;&#31243;&#30340;&#21517;&#23383;&#65288;&#23383;&#31526;&#20018;&#65289;&#33267;&#23569;&#26159;&#21069;&#20960;&#20010;&#23383;&#31526;</P></SPAN><SPAN class=extract>
<P>&#8226; Member of struct thread: uint8_t *stack</P>
<P>Every thread has its own stack to keep track of its state. When the thread is running, the CPU&#8217;s stack pointer register tracks the top of the stack and this member is unused. But when the CPU switches to another thread, this member saves the thread&#8217;s stack pointer. No other members are needed to save the thread&#8217;s registers, because the other registers that must be saved are saved on the stack.</P>
<P>&#26632;&#20013;&#25152;&#20445;&#23384;&#30340;&#20869;&#23481;&#23601;&#26159;&#32447;&#31243;&#22788;&#20110;&#38750; THREAD_RUNNING &#29366;&#24577;&#26102;&#23492;&#23384;&#22120;&#20013;&#30340;&#20540;</P>
<P>&#20855;&#20307;&#26469;&#35828;&#65292;&#36825;&#20010;&#25351;&#38024;&#30340;&#20869;&#23481;&#32447;&#31243;&#30340;&#26632;&#12290;&#24403;&#32447;&#31243;&#27491;&#22312;&#36816;&#34892;&#30340;&#26102;&#20505;&#65292;&#30001;&#20110; CPU &#30340;&#26632;&#25351;&#38024;&#23492;&#23384;&#22120;&#20250;&#25351;&#21521;&#32447;&#31243;&#30340;&#26632;&#65292;&#22240;&#27492;&#36825;&#20010;&#20540;&#24182;&#19981;&#20250;&#34987;&#21551;&#29992;&#12290;&#20294;&#26159;&#24403;&#21457;&#29983;&#19978;&#19979;&#25991;&#20999;&#25442;&#30340;&#26102;&#20505;&#65292;&#36825;&#37324;&#38754;&#23601;&#20250;&#20445;&#23384;&#32447;&#31243;&#30340;&#26632;&#25351;&#38024;</P></SPAN><SPAN class=extract>
<P>When an interrupt occurs, whether in the kernel or a user program, an &#8220;struct intr_frame&#8221; is pushed onto the stack. When the interrupt occurs in a user program, the &#8220;struct intr_frame&#8221; is always at the very top of the page.</P>
<P>&#24403;&#20013;&#26029;&#21457;&#29983;&#26102;&#65292;&#26080;&#35770;&#24403;&#21069;&#31243;&#24207;&#26159;&#20869;&#26680;&#31243;&#24207;&#36824;&#26159;&#29992;&#25143;&#31243;&#24207;&#65292;&#32467;&#26500;&#20307;&#8220;intr_frame&#8221;&#37117;&#20250;&#34987;&#25512;&#20837;&#26632;&#20013;&#65292;&#22914;&#26524;&#20013;&#26029;&#21457;&#29983;&#22312;&#29992;&#25143;&#31243;&#24207;&#25191;&#34892;&#36807;&#31243;&#20013;&#65292;&#37027;&#20040;&#27492;&#32467;&#26500;&#20307;&#24635;&#26159;&#20250;&#20301;&#20110;&#39029;&#30340;&#26368;&#39030;&#37096;</P></SPAN><SPAN class=extract>
<P>&#8226; Member of struct thread: int priority</P>
<P>A thread priority, ranging from PRI_MIN (0) to PRI_MAX (63). Lower numbers correspond to lower priorities, so that priority 0 is the lowest priority and priority 63 is the highest. Pintos currently ignores these priorities, but you will implement priority scheduling in this project.</P>
<P>priority &#20013;&#23558;&#20250;&#21547;&#26377;&#32447;&#31243;&#30340;&#20248;&#20808;&#32423;&#25968;&#25454;&#65292;&#25968;&#25454;&#20174; 0 &#21040; 63&#65292;&#29087;&#30693;&#36234;&#20302;&#32447;&#31243;&#20248;&#20808;&#32423;&#36234;&#20302;</P></SPAN><SPAN class=extract>
<P>&#8226; Member of struct thread: struct list_elem allelem</P>
<P>This &#8220;list element&#8221; is used to link the thread into the list of all threads. Each thread is inserted into this list when it is created and removed when it exits. The thread_foreach() function should be used to iterate over all threads.</P>
<P>list_elem &#20250;&#34987;&#29992;&#26469;&#23558;&#32447;&#31243;&#21644;&#25152;&#26377;&#32447;&#31243;&#30340;&#21015;&#34920;&#36830;&#25509;&#36215;&#26469;&#65292;&#27599;&#24403;&#32447;&#31243;&#34987;&#21019;&#24314;&#30340;&#26102;&#20505;&#37117;&#20250;&#34987;&#28155;&#21152;&#21040;&#36825;&#20010;&#21015;&#34920;&#20013;&#65292;&#27599;&#24403;&#32447;&#31243;&#34987;&#21024;&#38500;&#30340;&#26102;&#20505;&#37117;&#20250;&#34987;&#20174;&#36825;&#20010;&#34920;&#20013;&#31227;&#38500;</P>
<P>&#22914;&#26524;&#24819;&#35201;&#36941;&#21382;&#36825;&#20010;&#34920;&#30340;&#35805;&#65292;&#21487;&#20197;&#20351;&#29992; thread_foreach &#20989;&#25968;</SPAN></P><SPAN class=extract>
<P>&#8226; Member of struct thread: struct list_elem elem</P>
<P>A &#8220;list element&#8221; used to put the thread into doubly linked lists, either ready_list (the list of threads ready to run) or a list of threads waiting on a semaphore in sema_down(). It can do double duty because a thread waiting on a semaphore is not ready, and vice versa.</P>
<P>&#36825;&#20010;&#23383;&#27573;&#26159;&#20026;&#20102;&#33021;&#23558;&#32447;&#31243;&#25918;&#20837;&#21452;&#21521;&#38142;&#34920;&#20013;&#65292;&#36825;&#20010;&#21452;&#21521;&#38142;&#34920;&#26082;&#21487;&#20197;&#26159; ready_list&#65292;&#20063;&#21487;&#20197;&#26159;&#31561;&#24453; sema_down &#21457;&#26469;&#30340;&#20449;&#21495;&#37327;&#30340;&#32447;&#31243;&#21015;&#34920;</P>
<P>&#30001;&#20110;&#19968;&#20010;&#32447;&#31243;&#19981;&#33021;&#21516;&#26102;&#22788;&#20110;&#19978;&#38754;&#25552;&#21040;&#30340;&#20004;&#31181;&#29366;&#24577;&#65292;&#22240;&#27492;&#36825;&#20010;&#23383;&#27573;&#33021;&#21516;&#26102;&#20805;&#24403;&#20004;&#31181;&#19981;&#21516;&#30340;&#35282;&#33394;</P></SPAN><SPAN class=extract>
<P>&#8226; Member of struct thread: uint32_t *pagedir</P>
<P>(Used in Projects Userprog and Filesys.) The page table for the process, if this is a user process.</P>
<P>&#22914;&#26524;&#36825;&#26159;&#20010;&#29992;&#25143;&#36827;&#31243;&#30340;&#35805;&#65292;&#37027;&#20040;&#36825;&#20010;&#25351;&#38024;&#23601;&#20250;&#25351;&#21521;&#36827;&#31243;&#30340;&#39029;&#34920;</P></SPAN><SPAN class=extract>
<P>&#8226; Member of struct thread: unsigned magic</P>
<P>Always set to THREAD_MAGIC, which is just an arbitrary number de&#64257;ned in threads/thread.c, and used to detect stack over&#64258;ow. thread_current() checks that the magic member of the running thread&#8217;s struct thread is set to THREAD_MAGIC. Stack over&#64258;ow tends to change this value, triggering the assertion. For greatest bene&#64257;t, as you add members to struct thread, leave magic at the end.</P>
<P>&#36825;&#23454;&#38469;&#19978;&#26159;&#20316;&#20026; TCB &#21644;&#32447;&#31243;&#26632;&#20004;&#20010;&#20132;&#30028;&#21736;&#20853;&#20540;&#23384;&#22312;&#32780;&#34987;&#35774;&#32622;&#30340;&#37327;&#65292;&#23427;&#30340;&#23450;&#20041;&#20301;&#20110; threads/thread.c &#20013;&#30340; THREAD_MAGIC &#20013;</P>
<P>thread_current &#34987;&#35843;&#29992;&#26102;&#20250;&#26816;&#26597;&#36825;&#20010;&#21464;&#37327;&#20013;&#30340;&#20540;&#26159;&#21542;&#31561;&#20110; THREAD_MAGIC &#22914;&#26524;&#19981;&#31561;&#20110;&#23601;&#20250;&#35302;&#21457;&#26029;&#35328;</P>
<P>&#21478;&#22806;&#65292;&#24448;&#21518;&#27599;&#21521; TCB &#20013;&#28155;&#21152;&#26032;&#23383;&#27573;&#30340;&#26102;&#20505;&#65292;&#19968;&#23450;&#35201;&#23558;&#36825;&#20010;&#39764;&#27861;&#20540;&#25918;&#22312;&#32447;&#31243;&#32467;&#26500;&#20307;&#30340;&#26368;&#21518;</P>
<P></SPAN>