</FONT><STRONG><FONT style="BACKGROUND-COLOR: #f7e394" size=5></FONT></STRONG><SPAN class=extract>
<P></P>
<P>Virtual memory in Pintos is divided into two regions: user virtual memory and kernel virtual memory. </P>
<P>PIntos &#20013;&#30340;&#34394;&#25311;&#20869;&#23384;&#34987;&#20998;&#20026;&#20004;&#20010;&#21306;&#22495;&#65292;&#19968;&#37096;&#20998;&#26159;&#29992;&#25143;&#34394;&#25311;&#20869;&#23384;&#65292;&#21478;&#19968;&#37096;&#20998;&#26159;&#20869;&#26680;&#34394;&#25311;&#20869;&#23384;</P></SPAN><SPAN class=extract>
<P>User virtual memory ranges from virtual address 0 up to PHYS_BASE, which is de&#64257;ned in threads/vaddr.h and defaults to 0xc0000000 (3 GB). </P>
<P>&#40664;&#35748;&#24773;&#20917;&#19979;&#65292;&#29992;&#25143;&#34394;&#25311;&#20869;&#23384;&#26159;&#20174; 0 &#21040; 0xc0000000 &#36825;&#22359;&#31354;&#38388;&#65292;&#22823;&#32422;&#26159; 3GB</P></SPAN><SPAN class=extract>
<P>Kernel virtual memory occupies the rest of the virtual address space, from PHYS_BASE up to 4 GB.</P>
<P>&#20869;&#26680;&#34394;&#25311;&#20869;&#23384;&#36825;&#21344;&#25454;&#20102;&#21097;&#20313;&#30340; 1 GB &#20869;&#23384;&#31354;&#38388;&#65292;&#20063;&#23601;&#26159;&#20174; 0xc0000000 &#21040; 4 GB &#36825;&#20123;&#31354;&#38388;</P></SPAN><SPAN class=extract>
<P>User virtual memory is per-process. When the kernel switches from one process to another, it also switches user virtual address spaces by changing the processor&#8217;s page directory base register (see pagedir_activate() in userprog/pagedir.c). </P>
<P>&#29992;&#25143;&#30340;&#34394;&#25311;&#20869;&#23384;&#26159;&#36827;&#31243;&#29420;&#31435;&#20998;&#37197;&#30340;&#65292;&#27599;&#24403;&#20869;&#26680;&#25191;&#34892;&#36827;&#31243;&#20999;&#25442;&#26102;&#65292;&#23427;&#37117;&#20250;&#36890;&#36807;&#20462;&#25913;&#22788;&#29702;&#22120;&#30340; page directory base register &#26469;&#20999;&#25442;&#29992;&#25143;&#30340;&#34394;&#25311;&#22320;&#22336;&#31354;&#38388;&#65288;&#20855;&#20307;&#26469;&#35828;&#26159;&#36890;&#36807;&#25191;&#34892; pagedir_activate() &#20989;&#25968;&#20462;&#25913;&#65292;&#36825;&#20010;&#20989;&#25968;&#20301;&#20110; userprog/pagedir.c &#25991;&#20214;&#20013;&#65289;</P></SPAN><SPAN class=extract>
<P>struct thread contains a pointer to a process&#8217;s page table.</P>
<P>&#32447;&#31243; TCB &#20013;&#21253;&#21547;&#19968;&#20010;&#25351;&#21521;&#36827;&#31243;&#39029;&#34920;&#30340;&#25351;&#38024;</P></SPAN><SPAN class=extract>
<P>Kernel virtual memory is global. </P>
<P>&#20869;&#26680;&#30340;&#34394;&#25311;&#20869;&#23384;&#31354;&#38388;&#26159;&#20840;&#23616;&#30340;</P></SPAN><SPAN class=extract>
<P>It is always mapped the same way, regardless of what user process or kernel thread is running. In Pintos, kernel virtual memory is mapped one-to-one to physical memory, starting at PHYS_BASE. That is, virtual address PHYS_BASE accesses physical address 0, virtual address PHYS_BASE + 0x1234 accesses physical address 0x1234, and so on up to the size of the machine&#8217;s physical memory.</P>
<P>&#20869;&#26680;&#30340;&#34394;&#25311;&#20869;&#23384;&#31354;&#38388;&#24635;&#26159;&#20250;&#20197;&#19968;&#31181;&#22266;&#23450;&#30340;&#26041;&#24335;&#36827;&#34892;&#26144;&#23556;&#65292;&#26080;&#35770;&#24403;&#21069;&#27491;&#22312;&#36816;&#34892;&#20160;&#20040;&#29992;&#25143;&#36827;&#31243;&#25110;&#20869;&#26680;&#32447;&#31243;&#12290;&#20063;&#23601;&#26159;&#35828;&#65292;&#20869;&#26680;&#30340;&#34394;&#25311;&#20869;&#23384;&#31354;&#38388;&#20013;&#30340;&#26576;&#20010;&#22320;&#22336;&#24635;&#26159;&#20250;&#21644;&#29289;&#29702;&#20869;&#23384;&#31354;&#38388;&#20013;&#30340;&#26576;&#20010;&#22320;&#22336;&#30456;&#26144;&#23556;&#12290;&#20855;&#20307;&#26469;&#35828;&#65292;&#34394;&#25311;&#22320;&#22336; PHYS_BASE &#24635;&#26159;&#20250;&#26144;&#23556;&#21040;&#29289;&#29702;&#22320;&#22336; 0 &#20013;</P></SPAN><SPAN class=extract>
<P>A user program can only access its own user virtual memory.</P><SPAN class=extract><SPAN class=extract>
<P>&#29992;&#25143;&#36827;&#31243;&#21482;&#33021;&#35775;&#38382;&#33258;&#24049;&#30340;&#34394;&#25311;&#20869;&#23384;&#31354;&#38388;</P>
<P></SPAN>&nbsp;</P>
<P>An attempt to access kernel virtual memory causes a page fault, handled by page_fault() in userprog/exception.c, and the process will be terminated.</P>
<P>&#29992;&#25143;&#36827;&#31243;&#30340;&#20219;&#20309;&#38024;&#23545;&#20869;&#26680;&#34394;&#25311;&#20869;&#23384;&#31354;&#38388;&#30340;&#35775;&#38382;&#37117;&#20250;&#24341;&#21457; page fault&#65292;page fault &#20250;&#34987; page_fault &#20989;&#25968;&#25152;&#22788;&#29702;&#65288;&#36825;&#20010;&#20989;&#25968;&#20301;&#20110; userprog/exception.c &#20013;&#65289;&#38543;&#21518;&#35813;&#36827;&#31243;&#20250;&#34987;&#30452;&#25509;&#32456;&#27490;</P></SPAN></SPAN><SPAN class=extract>
<P>Kernel threads can access both kernel virtual memory and, if a user process is running, the user virtual memory of the running process. However, even in the kernel, an attempt to access memory at an unmapped user virtual address will cause a page fault.</P>
<P>&#20869;&#26680;&#32447;&#31243;&#33021;&#35775;&#38382;&#20869;&#26680;&#34394;&#25311;&#20869;&#23384;&#31354;&#38388;&#21644;&#27491;&#22312;&#36816;&#34892;&#30340;&#29992;&#25143;&#36827;&#31243;&#30340;&#34394;&#25311;&#20869;&#23384;&#31354;&#38388;&#65292;&#21333;&#22914;&#26524;&#20869;&#26680;&#32447;&#31243;&#35797;&#22270;&#35775;&#38382;&#23578;&#26410;&#34987;&#26144;&#23556;&#21040;&#29289;&#29702;&#22320;&#22336;&#30340;&#34394;&#25311;&#22320;&#22336;&#65292;&#20063;&#20250;&#24341;&#21457; page fault</P></SPAN><SPAN class=extract>
<P>Typical Memory Layout Conceptually, each process is free to lay out its own user virtual memory however it chooses. In practice, user virtual memory is laid out like this:</P>
<P>&#19968;&#33324;&#26469;&#35828;&#65292;&#29992;&#25143;&#36827;&#31243;&#30340;&#34394;&#25311;&#20869;&#23384;&#31354;&#38388;&#24067;&#23616;&#22914;&#19979;&#65306;</P>
<P></SPAN>