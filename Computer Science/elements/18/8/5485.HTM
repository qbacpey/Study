While inside the kernel, the process can be pre-empted by a timer interrupt or I/O event, and a higher priority process or kernel thread can run in its place. The PCB and kernel stack for the preempted process stores both its current kernel state, as well as the user-level state saved when the process initiated the system call.</P>
<P>&#24403;&#29992;&#25143;&#32447;&#31243;&#22240;&#20026;&#26576;&#31181;&#21407;&#22240;&#34987;&#25805;&#20316;&#31995;&#32479;&#25152;&#25429;&#33719;&#24182;&#25191;&#34892;&#20013;&#26029;&#22788;&#29702;&#31243;&#24207;&#20195;&#30721;&#26102;&#65292;&#23427;&#20173;&#26377;&#21487;&#33021;&#34987;&#35832;&#22914;&#35745;&#26102;&#22120;&#20013;&#26029;&#12289;IO &#20107;&#20214;&#12289;&#39640;&#20248;&#20808;&#32423;&#20869;&#26680;&#36827;&#31243;&#25110;&#32447;&#31243;&#25171;&#26029;&#65292;&#36825;&#26102;&#20505;&#36827;&#31243;&#21644; PCB &#20013;&#26082;&#20250;&#20445;&#23384;&#24403;&#21069;&#20869;&#26680;&#29366;&#24577;&#65292;&#20063;&#20250;&#20445;&#23384;&#29992;&#25143;&#36827;&#31243;&#34987;&#20013;&#26029;&#26102;&#30340;&#29366;&#24577;