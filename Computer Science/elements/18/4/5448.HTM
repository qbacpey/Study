<SPAN><SPAN class=extract>
<P class="q-text qu-display--block qu-wordBreak--break-word qu-textAlign--start"><SPAN>The timer interrupt handler invokes the process scheduler as any code in a monolithic kernel invokes any other code: By direct function invocation. The timer interrupt handler and the process scheduler's main entry point are both in the kernel's address space and in the same object file. Kernel code can thus call or jump from the timer interrupt handler to the process scheduler just as function<SPAN>&nbsp;</SPAN></SPAN><CODE class="q-inline qu-bg--gray_ultralight qu-color--gray qu-overflowX--auto qu-textAlign--left qu-borderRadius--small qu-whiteSpace--pre-wrap"><FONT face="Courier New">foo()</FONT></CODE><SPAN><SPAN>&nbsp;</SPAN>may call function<SPAN>&nbsp;</SPAN></SPAN><CODE class="q-inline qu-bg--gray_ultralight qu-color--gray qu-overflowX--auto qu-textAlign--left qu-borderRadius--small qu-whiteSpace--pre-wrap"><FONT face="Courier New">bar()</FONT></CODE><SPAN>.</SPAN></P>
<P class="q-text qu-display--block qu-wordBreak--break-word qu-textAlign--start"><SPAN>(That's the generic answer. Specific operating systems differ, of course. On Linux, the timer interrupt sets a flag, and the kernel then invokes the scheduler later, when about to return to process context. But the point remains: There's nothing magical about how this works.)</SPAN></P>
<P class="q-text qu-display--block qu-wordBreak--break-word qu-textAlign--start"><SPAN><SPAN>&#35745;&#26102;&#22120;&#20013;&#26029;&#22788;&#29702;&#31243;&#24207;&#21487;&#20197;&#30452;&#25509;&#20687;&#35843;&#29992;&#20989;&#25968;&#19968;&#26679;&#35843;&#29992;&#20869;&#26680;&#32447;&#31243;&#35843;&#24230;&#22120;&#65292;&#20294;&#26159;&#26681;&#25454; OS &#30340;&#19981;&#21516;&#65292;&#20855;&#20307;&#23454;&#29616;&#26041;&#24335;&#21487;&#33021;&#26377;&#24046;&#24322;&#12290;&#27604;&#22914;&#22312; Linux &#20013;&#65292;&#35745;&#26102;&#22120;&#20013;&#26029;&#20250;&#35774;&#32622;&#19968;&#20010;&#26071;&#26631;&#65292;&#38543;&#21518;&#20869;&#26680;&#20250;&#22312;&#23558;&#35201;&#36820;&#22238;&#36827;&#31243;&#19978;&#19979;&#25991;&#30340;&#26102;&#20505;&#35843;&#29992;&#35843;&#24230;&#22120;</SPAN></SPAN></P></SPAN></SPAN>
<P class="q-text qu-display--block qu-wordBreak--break-word qu-textAlign--start"><SPAN>Your point of confusion is perhaps in understanding how the system, upon receiving a timer interrupt, knows to invoke the timer interrupt handler in the first place? The system knows where and how to invoke the timer interrupt handler because the kernel tells it. How this is done varies from system to system, but generally the kernel writes the memory address of the function that represents its timer interrupt handler into a register or memory I/O region on the<SPAN>&nbsp;</SPAN></SPAN><SPAN>interrupt controller</SPAN><SPAN>. When the processor is interrupted by an interrupt, it then halts the execution of the current context, saves it registers, and jumps to the previously-registered interrupt handler for that interrupt line.</SPAN></P>
<HR SuperMemo>

<P class="q-text qu-display--block qu-wordBreak--break-word qu-textAlign--start"><SPAN>A timer interrupt does not invoke a process scheduler.</SPAN></P>
<P class="q-text qu-display--block qu-wordBreak--break-word qu-textAlign--start"><SPAN>A timer interrupt like any other interrupt invokes an interrupt handler. There can be different reasons for a timer interrupt. A user may request a pause or sleep for a while waiting for something to happen. A program may be waiting for a user response within a specific amount of time. A device request may time-out for some reason without getting a response status from the device. The system decided how much time a current process should have before another process is run.</SPAN></P>
<P class="q-text qu-display--block qu-wordBreak--break-word qu-textAlign--start"><SPAN>The handler for a timer interrupt needs to save the information about the interrupt, make a quick determination about the next step to process the interrupt, setting flags for the system to<SPAN>&nbsp;</SPAN></SPAN><SPAN>schedule the process<SPAN>&nbsp;</SPAN></SPAN><SPAN>to handle the cause of the interrupt, reset and re enable interrupts and return the system back to the run state it was in before the interrupt occurred.</SPAN></P>
<P class="q-text qu-display--block qu-wordBreak--break-word qu-textAlign--start"><SPAN>The next time the system is given control, it will see that the process has been scheduled and will decide if it should be invoked or if a higher priority process should be given control.</SP