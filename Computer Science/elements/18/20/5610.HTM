Related and possible duplicate:<SPAN>&nbsp;</SPAN><A href="https://stackoverflow.com/questions/2035568/why-do-stacks-typically-grow-downwards">Why do stacks typically grow downwards?</A>. 
<P></P>
<P>On some ISAs (like x86), a downward-growing stack is baked in. (e.g.<SPAN>&nbsp;</SPAN><CODE><FONT face="Courier New">call</FONT></CODE><SPAN>&nbsp;</SPAN>decrements SP/ESP/RSP before pushing a return address, and exceptions / interrupts push a return context onto the stack so even if you wrote inefficient code that avoided the<SPAN>&nbsp;</SPAN><CODE><FONT face="Courier New">call</FONT></CODE><SPAN>&nbsp;</SPAN>instruction, you can't escape hardware usage of at least the kernel stack, although user-space stacks can do whatever you want.)</P>
<P>On others (like MIPS where there's no implicit stack usage), it's a software convention.</P>
<HR>

<P>The rest of the layout follows from that: you want as much room as possible for downward stack growth and/or upward heap growth before they collide. (Or allowing you to set larger limits on their growth.)</P>
<P><SPAN class=extract>Depending on the OS and executable file format, the linker may get to choose the layout, like whether text is above or below BSS and read-write data. The OS's program loader must respect where the linker asks for sections to be loaded (at least relative to each other, for executables that support ASLR of their static code/data/BSS).</SPAN> Normally such executables use PC-relative addressing to access static data, so ASLRing the text<SPAN>&nbsp;</SPAN><EM>relative</EM><SPAN>&nbsp;</SPAN>to the data or bss would require runtime fixups (and isn't done).</P>
<P>Or position-<EM>dependent</EM><SPAN>&nbsp;</SPAN>executables have all their segments loaded at fixed (virtual) addresses, with only the stack address randomized.</P>
<P><SPAN class=extract>The "heap" isn't normally a real thing, especially in systems with virtual memory so each process can have their own private virtual address space. Normally you have some space reserved for the stack, and everything outside that which isn't already mapped is fair game for malloc (actually its underlying<SPAN>&nbsp;</SPAN><CODE><FONT face="Courier New">mmap(MAP_ANONYMOUS)</FONT></CODE><SPAN>&nbsp;</SPAN>system calls) to choose when allocating new pages. But yes even modern glibc's<SPAN>&nbsp;</SPAN><CODE><FONT face="Courier New">malloc</FONT></CODE><SPAN>&nbsp;</SPAN>on modern Linux does still use<SPAN>&nbsp;</SPAN><CODE><FONT face="Courier New">brk()</FONT></CODE><SPAN>&nbsp;</SPAN>to move the "program break" upward for small allocations, increasing the size of "the heap" the way your diagram shows.</SPAN>