<STRONG>Operating Systems: Principles and Practice (Second Edition) Volume II : </STRONG>
<P></P>
<H3 class=sectionHead><SPAN class=headers>Title:</SPAN></B><SPAN class=RefText> 4.10 Summary and Future Directions</SPAN></H3>
<H3 class=sectionHead><SPAN class=RefText><FONT size=3 face=&#26041;&#27491;&#26032;&#20070;&#23435;&#31616;&#20307;>Concurrency is ubiquitous &#8212; not only do most smartphones, servers, desktops, laptops, and tablets have multiple cores, but users have come to expect a responsive interface at all times, I/O latencies have become gigantic compared to computer instruction cycle times, and servers must be able to process large numbers of simultaneous requests.</FONT></SPAN></H3>
<P>Although threads are not the only possible solution to these issues, they are a general-purpose technique that can be applied to a wide range of concurrency issues. In our view, multi-threaded programming is a skill that every professional programmer must master. </P>
<P>In this chapter, we have discussed: </P>
<UL class=itemize1>
<LI class=itemize>
<P><B>The thread abstraction.</B> <SPAN class=extract>Threads are a set of concurrent activities, each of which executes sequentially at unpredictable speed.</SPAN> </P>
<LI class=itemize>
<P><B>A simple thread API.</B> Thread libraries, whether for use in the operating system kernel or in application code, provide the ability to perform an asynchronous procedure call. </P>
<LI class=itemize>
<P><B>Thread implementations.</B> The core of any implementation of preemptive multi-threading is the ability to save one thread&#8217;s state and restore another&#8217;s. The thread system keeps track of the saved state of all threads not currently running; it switches threads between READY&nbsp;and RUNNING&nbsp;as needed. The implementation of multi-threading can be in the kernel or at user-level, depending on the goals of the system. <SPAN class=extract>In our view, most systems in the future will have both a kernel-level thread system for managing concurrency in the operating system, and a lightweight thread system for expressing parallelism at the application level.</SPAN> </P>
<LI class=itemize>
<P><B>Alternative abstractions.</B> Practical alternatives to threads exist for two important domains: event-driven programming for servers as well as data parallel programming for multiprocessors.</P></LI></UL>
<P>Technology trends suggest that concurrent programming will only increase in importance over time. After several decades in which computer architects were able to make individual processor cores run faster and faster, we have reached a point where the performance of individual cores is leveling off and where further speedups will have to come from parallel processing. </P>
<P>The best programming model for expressing and managing parallelism is still an active area of research, but it seems likely that threads will remain an important option for decades to come. <A id=x1-36001r63 name=x1-36001r63></A></P>
<H4 class=subsectionHead>4.10.1 <A id=x1-370001 name=x1-370001></A>Historical Notes</H4>
<P>The extreme engineering complexity and bugginess of commercial operating systems in the 1960&#8217;s led researchers to investigate alternatives. One direct result of this experience was modern software engineering: the systematic management of complex implementation tasks through the careful control of feature lists, module testing, assertions, and so forth. </P>
<P>Another consequence was the use of threads for managing concurrency. One of the most influential papers in computer science history is Dijkstra&#8217;s description of his THE system&nbsp;[<A data-9uzdtcnnj6xqoalwmdp3qa='{"name": "OEBPS/Text/part0000.xhtml", "frag": "XDijkstra:1968:SLS:363095.363143"}'>48</A>]. Dijkstra argued for constructing operating systems as a series of layered abstractions, with communicating threads implementing each layer. Within a decade, the research community was convinced. When Xerox PARC built the Alto in the late 1970&#8217;s, the Alto&#8217;s operating system was built from the ground up using threads. The Alto demonstrated most of the technology we now take for granted with personal computers: bit-mapped display, menus, windowing, mice, Ethernet, and email. We base much of our description of thread programming on the experiences from that project&nbsp;[<A data-9uzdtcnnj6xqoalwmdp3qa='{"name": "OEBPS/Text/part0000.xhtml", "frag": "XLampson:1980:EPM:358818.358824"}'>98</A>]. </P>
<P>Widespread commercial adoption of threads took much longer, however. By the early 1990&#8217;s, the widespread adoption of client-server computing led to several commercially important operating systems written from scratch using threads, including Microsoft&#8217;s Windows NT, SUN Microsystems Solaris, and Linux. Client operating systems followed, and by the late 1990&#8217;s, with Apple&#8217;s introduction of OS X, all major commercial operating systems were based on threads. At about the same time, the interface to thread libraries became standardized, starting with POSIX in 1995. Likewise, modern programming languages such as Java were designed with constructs for creating and synchronizing threads. </P>
<P>The increasing importance of parallel processing led to the development of very lightweight user-level thread implementations, as there is little point to parallelizing an application unless it improves performance. By the early 90&#8217;s, scheduler activations were developed to integrate user-level and kernel threads&nbsp;[<A data-9uzdtcnnj6xqoalwmdp3qa='{"name": "OEBPS/Text/part0000.xhtml", "frag": "XAnderson:1992:SAE:146941.146944"}'>2</A>]. </P>
<P>Even so, the topic of whether threads are a better programming model than the alternatives remains an active one&nbsp;[<A data-9uzdtcnnj6xqoalwmdp3qa='{"name": "OEBPS/Text/part0000.xhtml", "frag": "Xtyma"}'>159</A>]. Several prominent operating systems researchers have argued that normal programmers should almost never use threads because (a) it is just too hard to write multi-threaded programs that are correct and (b) most things that threads are commonly used for can be accomplished in other, safer ways&nbsp;[<A data-9uzdtcnnj6xqoalwmdp3qa='{"name": "OEBPS/Text/part0000.xhtml", "frag": "Xousterhoutbadthreads"}'>129</A>,&nbsp;<A data-9uzdtcnnj6xqoalwmdp3qa='{"name": "OEBPS/Text/part0000.xhtml", "frag": "XvanRenesse:1998:GPC:319195.319208"}'>160</A>]. These are important arguments to understand &#8212; even if you disagree with them, they point out pitfalls with using threads that are important to avoid. <A id=Q1-1-66 name=Q1-1-66></A><A id=Q1-1-67 name=Q1-1-67></A></P><A id=x1-380001 name=x1-380001>