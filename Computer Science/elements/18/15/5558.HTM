<B><SPAN class=headers>Title:</SPAN></B><SPAN class=RefText> 4.8 Implementing Multi-Threaded Processes : Scheduler Activations</SPAN></FONT>.</B> 
<P></P>
<P>To address these issues, some operating systems have added explicit support for user-level threads. One such model, implemented most recently in Windows, is called <EM><A data-9uzdtcnnj6xqoalwmdp3qa='{"name": "OEBPS/Text/part0000.xhtml", "frag": "glo:scheduler activations"}'>scheduler activations</A></EM>. In this approach, the user-level thread scheduler is notified (or activated) for every kernel event that might affect the user-level thread system. For example, if one thread blocks in a system call, the activation informs the user-level scheduler that it should choose another thread to run on that processor. </P>
<P><SPAN class=extract>&#35843;&#24230;&#22120;&#28608;&#27963;&#65288;scheduler activation&#65289;&#25351;&#30340;&#26159;&#24403;&#21457;&#29983;&#26576;&#20123;&#36275;&#20197;&#24433;&#21709;&#29992;&#25143;&#32423;&#32447;&#31243;&#31995;&#32479;&#30340;&#20107;&#20214;&#30340;&#26102;&#20505;&#65292;&#20869;&#26680;&#20250;&#20351;&#29992;&#19968;&#31181;&#31867;&#20284;&#20110;&#20449;&#21495;&#25110;&#32773;&#35828;&#19978;&#34892;&#35843;&#29992;&#30340;&#26041;&#24335;&#36890;&#30693;&#29992;&#25143;&#32423;&#35843;&#24230;&#22120;&#65292;&#35753;&#29992;&#25143;&#32423;&#35843;&#24230;&#22120;&#21435;&#22788;&#29702;&#36825;&#20214;&#20107;&#65288;&#27604;&#22914;&#35828;&#23558;&#24403;&#21069;&#32447;&#31243;&#24402;&#20837;&#20934;&#22791;&#38431;&#21015;&#65292;&#22909;&#35753;&#20854;&#20182;&#22788;&#29702;&#22120;&#33021;&#25191;&#34892;&#27492;&#32447;&#31243;&#65289;</SPAN></P><SPAN class=extract>
<P>Scheduler activations are like upcalls or signals, except that they do not return to the kernel; instead, they directly perform user-level thread suspend and resume. </P>
<P>&#35843;&#24230;&#22120;&#28608;&#27963;&#24182;&#19981;&#20250;&#36820;&#22238;&#20869;&#26680;&#65292;&#32780;&#26159;&#30452;&#25509;&#23558;&#25511;&#21046;&#26435;&#20132;&#32473;&#29992;&#25143;&#32447;&#31243;</P></SPAN>
<P></P>
<P>Various operations trigger a scheduler activation upcall: </P>
<OL class=enumerate1>
<LI class=enumerate><A id=x1-31002x1 name=x1-31002x1></A>
<P><B><SPAN class=extract><B>Increasing the number of virtual processors.</B> When a program starts, it receives an activation to inform the program that it has been assigned a virtual processor: that activation runs the main thread and any other threads that might be created. <BR>&#24403;&#31243;&#24207;&#21551;&#21160;&#26102;&#65292;&#23427;&#20250;&#25509;&#21463;&#21040;&#19968;&#20010;&#28608;&#27963;&#65292;&#36890;&#30693;&#35813;&#31243;&#24207;&#24050;&#32463;&#34987;&#32473;&#20104;&#20102;&#19968;&#20010;&#34394;&#25311;&#22788;&#29702;&#22120;&#65292;&#31243;&#24207;&#23601;&#33021;&#22312;&#35813;&#34394;&#25311;&#22788;&#29702;&#22120;&#19978;&#36816;&#34892;&#20027;&#32447;&#31243;&#25110;&#32773;&#20854;&#20182;&#32447;&#31243;&#20102;&#12290;&#20043;&#21069;&#25552;&#21040;&#27599;&#19968;&#20010;&#29289;&#29702;&#22788;&#29702;&#22120;&#19978;&#37117;&#30001;&#19968;&#20010;&#20869;&#26680;&#32447;&#31243;&#22312;&#36816;&#34892;&#35843;&#24230;&#22120;&#65292;&#36824;&#26159;&#24863;&#35273;&#36825;&#37324;&#25152;&#35859;&#30340;&#34394;&#25311;&#22788;&#29702;&#22120;&#23454;&#38469;&#19978;&#23601;&#26159;&#20043;&#21069;&#25552;&#21040;&#30340;&#20869;&#26680;&#32447;&#31243;&#65292;&#27605;&#31455;&#20043;&#21069;&#25552;&#21040;&#30340;&#20869;&#26680;&#32447;&#31243;&#35843;&#24230;&#37027;&#22359;&#65292;&#23601;&#26159;&#30001;&#35843;&#24230;&#22120;&#26469;&#25191;&#34892;&#20869;&#26680;&#32447;&#31243;&#30340;&#65292;&#25152;&#20197;&#36825;&#37324;&#20869;&#26680;&#32447;&#31243;&#25191;&#34892;&#29992;&#25143;&#32423;&#35843;&#24230;&#22120;&#20043;&#21518;&#65292;&#29992;&#25143;&#32423;&#35843;&#24230;&#22120;&#22312;&#20869;&#26680;&#32447;&#31243;&#30340;&#29615;&#22659;&#19979;&#25191;&#34892;&#29992;&#25143;&#32447;&#31243;&#30340;&#20195;&#30721;&#65292;&#24212;&#35813;&#36825;&#26679;&#26469;&#29702;&#35299;&#36825;&#20010;&#19996;&#35199;</SPAN></B><BR><BR><SPAN class=extract>&#30001;&#29992;&#25143;&#32423;&#35843;&#24230;&#22120;&#26469;&#20998;&#37197;&#29992;&#25143;&#32423;&#32447;&#31243;&#23545;&#34394;&#25311;&#22788;&#29702;&#22120;&#30340;&#20351;&#29992;&#26102;&#38388;&#65292;&#25152;&#35859;&#34394;&#25311;&#22788;&#29702;&#22120;&#30340;&#20351;&#29992;&#26102;&#38388;&#23454;&#38469;&#19978;&#26159;&#20869;&#26680;&#32447;&#31243;&#30340;&#25191;&#34892;&#26102;&#38388;&#65292;&#26159;&#36825;&#20010;&#24847;&#24605;&#21527;</SPAN><BR><SPAN class=extract>To assign another virtual processor to the program, the kernel makes another activation upcall on the new processor; the user-level scheduler can pull a waiting thread off the ready list and run it. <BR>&#22914;&#26524;&#24819;&#35201;&#32473;&#31243;&#24207;&#21478;&#19968;&#20010;&#34394;&#25311;&#22788;&#29702;&#22120;&#65292;&#20869;&#26680;&#38656;&#35201;&#22312;&#21478;&#19968;&#20010;&#34394;&#25311;&#22788;&#29702;&#22120;&#19978;&#20877;&#21521;&#31243;&#24207;&#25191;&#34892;&#19978;&#34892;&#35843;&#29992;&#65288;&#20272;&#25720;&#30528;&#26159;&#21478;&#22806;&#21551;&#21160;&#19968;&#20010;&#20869;&#26680;&#32447;&#31243;&#65292;&#28982;&#21518;&#36825;&#20010;&#20869;&#26680;&#32447;&#31243;&#20877;&#25191;&#34892;&#29992;&#25143;&#35843;&#24230;&#22120;&#65289;&#65292;&#36825;&#26102;&#20505;&#29992;&#25143;&#32423;&#35843;&#24230;&#22120;&#23601;&#33021;&#20174;&#20934;&#22791;&#38431;&#21015;&#20013;&#21462;&#20986;&#19968;&#20010;&#32447;&#31243;&#24182;&#35753;&#23427;&#22312;&#36825;&#20010;&#34394;&#25311;&#22788;&#29702;&#22120;&#19978;&#36816;&#34892;&#20102;</SPAN></P>
<LI class=enumerate><A id=x1-31004x2 name=x1-31004x2></A><B><SPAN class=extract>
<P><B>Decreasing the number of virtual processors.</B> When the kernel preempts a virtual processor (e.g., to give the processor to a different process), the kernel makes an upcall on one of the other processors assigned to the parallel program. The thread system can then move the preempted user-level thread onto the ready list, so that a different processor can run it. <BR>&#24403;&#20869;&#26680;&#25250;&#20808;&#19968;&#20010;&#34394;&#25311;&#22788;&#29702;&#22120;&#26102;&#65288;&#31867;&#20284;&#20110;&#20043;&#21069;&#25552;&#21040;&#30340; time-slice&#65289;&#20869;&#26680;&#23601;&#38656;&#35201;&#28608;&#27963;&#20854;&#20182;&#32473;&#20104;&#35813;&#31243;&#24207;&#30340;&#34394;&#25311;&#22788;&#29702;&#22120;&#65292;&#35813;&#31243;&#24207;&#30340;&#32447;&#31243;&#31995;&#32479;&#23601;&#33021;&#23558;&#34987;&#25250;&#20808;&#30340;&#29992;&#25143;&#32423;&#32447;&#31243;&#31227;&#21160;&#21040;&#31561;&#24453;&#38431;&#21015;&#20013;&#65288;&#23454;&#38469;&#19978;&#23601;&#26159;&#35753;&#32447;&#31243;&#31995;&#32479;&#30340;&#35843;&#24230;&#22120;&#25110;&#32773;&#35828;&#21035;&#30340;&#32447;&#31243;&#23558;&#36825;&#20010;&#32447;&#31243;&#30340;&#29366;&#24577;&#20445;&#23384;&#21040;&#20854;&#23545;&#24212;&#30340; TCB &#20013;&#65289;&#36825;&#26679;&#20854;&#20182;&#34394;&#25311;&#22788;&#29702;&#22120;&#23601;&#33021;&#36816;&#34892;&#36825;&#20010;&#32447;&#31243;&#20102;</P></SPAN></B>
<LI class=enumerate><A id=x1-31006x3 name=x1-31006x3></A><B><SPAN class=extract>
<P><B>Transition to WAITING.</B> When a user-level thread blocks in the kernel waiting for I/O, the kernel similarly makes an upcall to notify the user-level scheduler that it needs to take action, e.g., to choose another thread to run while waiting for the I/O to complete. <BR>&#24403;&#26576;&#20010;&#29992;&#25143;&#32423;&#32447;&#31243;&#22240;&#20026; IO &#20107;&#20214;&#25110;&#32773;&#21035;&#30340;&#20160;&#20040;&#20107;&#20214;&#65288;thread_join&#65289;&#34987;&#38459;&#22622;&#26102;&#65292;&#20869;&#26680;&#20250;&#28608;&#27963;&#29992;&#25143;&#23618;&#35843;&#24230;&#22120;&#65292;&#35753;&#23427;&#20570;&#20986;&#19968;&#23450;&#30340;&#34892;&#21160;&#65288;&#27604;&#22914;&#35828;&#35753;&#20854;&#20182;&#32447;&#31243;&#20351;&#29992;&#36825;&#20010;&#34394;&#25311;&#22788;&#29702;&#22120;&#65311;&#65289;</P>
<P></SPAN></B><A id=x1-31008x4 name=x1-31008x4></A><B><SPAN class=extract>&nbsp;</P>
<P><B>Transition from WAITING&nbsp;to READY.</B> When the I/O completes, the kernel makes an upcall to notify the scheduler that the suspended thread can be resumed. <BR>&#24403; IO &#20107;&#20214;&#23436;&#25104;&#26102;&#65292;&#20869;&#26680;&#20250;&#28608;&#27963;&#35843;&#24230;&#22120;&#65292;&#35753;&#23427;&#37325;&#21551;&#34987;&#26242;&#20572;&#30340;&#32447;&#31243;</P></SPAN></B>
<LI class=enumerate><A id=x1-31010x5 name=x1-31010x5></A><B><SPAN class=extract>
<P><B>Transition from RUNNING&nbsp;to idle.</B> When a user-level activation finds an empty ready list (i.e., it has no more work to do), it can make a system call into the kernel to return the virtual processor for use by some other process.<BR>&#24403;&#29992;&#25143;&#32423;&#28608;&#27963;&#65288;&#35843;&#24230;&#22120;&#65311;&#65289;&#21457;&#29616;&#20934;&#22791;&#38431;&#21015;&#20026;&#31354;&#65292;&#23427;&#23601;&#20250;&#25191;&#34892;&#31995;&#32479;&#35843;&#29992;&#65292;&#24182;&#23558;&#34394;&#25311;&#22788;&#29702;&#22120;&#36820;&#22238;&#32473;&#20869;&#26680;</P>
<P></SPAN></B><SPAN class=extract>&nbsp;</P>
<OL class=enumerate1>
<LI class=enumerate>
<P>As a result, most thread management functions &#8212; thread_create, thread_yield, thread_exit, and thread_join, as well as the synchronization functions described in Chapter&nbsp;<A data-9uzdtcnnj6xqoalwmdp3qa='{"name": "OEBPS/Text/part0000.xhtml", "frag": "x1-390005"}'>5</A> &#8212; are implemented as procedure calls within the process. Yet the user-level thread system always knows exactly how many virtual processors it has been assigned and is in complete control of what runs on those processors.</P></LI></OL>
<P>&#29992;&#25143;&#32423;&#35843;&#24230;&#31995;&#32479;&#24635;&#26159;&#30693;&#36947;&#24212;&#29992;&#31243;&#24207;&#24403;&#21069;&#25345;&#26377;&#26377;&#22810;&#23569;&#20010;&#34394;&#25311;&#22788;&#29702;&#22120;&#65292;&#24182;&#23545;&#36825;&#20123;&#34394;&#25311;&#22788;&#29702;&#22120;&#19978;&#31350;&#31455;&#22312;&#36816;&#34892;&#20160;&#20040;&#25317;&#26377;&#30528;&#23436;&#20840;&#30340;&#25484;&#25511;&#65292;&#36825;&#37324;&#30340;&#34394;&#25311;&#22788;&#29702;&#22120;&#24212;&#35813;&#26159;&#23545;&#25805;&#20316;&#31995;&#32479;&#30828;&#20214;&#36164;&#28304;&#30340;&#37327;&#21270;&#65292;&#24212;&#35813;&#19981;&#26159;&#26576;&#31181;&#8220;&#26412;&#20070;&#29305;&#26377;&#30340;&#35828;&#27861;&#8221;&#32780;&#26159;&#19968;&#31181;&#30495;&#27491;&#23384;&#22312;&#30340;&#25216;&#26415;&#65292;&#24212;&#35813;&#23601;&#26159; IBM &#30340;&#37027;&#31687;&#25991;&#31456;&#37324;&#30340;&#19996;&#35199;<BR></P>
<P></SPAN><BR>&nbsp;</P></LI></OL>