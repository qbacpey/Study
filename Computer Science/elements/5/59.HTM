<STRONG><FONT color=blue>: </FONT></STRONG>
<H4 class=subsectionHead><SPAN class=headers><SPAN class=headers>Title:</SPAN></B><SPAN class=RefText> 2.4.4 Interrupt Masking</SPAN></FONT></SPAN></H4>
<H4 class=subsectionHead><SPAN class=RefText></SPAN></FONT><FONT color=#000000 size=4 face=&#26041;&#27491;&#26032;&#20070;&#23435;&#31616;&#20307;>Interrupts arrive asynchronously; the processor could be executing either user or kernel code when an interrupt arrives. In certain regions of the kernel &#8212; such as inside interrupt handlers themselves, or inside the CPU scheduler &#8212; taking an interrupt could cause confusion. </FONT><SPAN class=extract><FONT color=#000000 size=4 face=&#26041;&#27491;&#26032;&#20070;&#23435;&#31616;&#20307;>If an interrupt handler is interrupted, we cannot set the stack pointer to point to the base of the kernel&#8217;s interrupt stack &#8212; doing so would obliterate the state of the first handler.</FONT> </SPAN><SPAN class=extract></H4>
<P>To simplify the kernel design, the hardware provides a privileged instruction to temporarily defer delivery of an interrupt until it is safe to do so. On the x86 and several other processors, this instruction is called <EM><A data-ixbpernmnjoud4qz9ktzkg='{"name": "OEBPS/Text/part0000.xhtml", "frag": "glo:interrupt disable"}'>disable interrupts</A></EM>. However, this is a misnomer: the interrupt is only deferred (masked), and not ignored. Once a corresponding <EM><A data-ixbpernmnjoud4qz9ktzkg='{"name": "OEBPS/Text/part0000.xhtml", "frag": "glo:interrupt enable"}'>enable interrupts</A></EM> instruction is executed, any pending interrupts are delivered to the processor. The instructions to mask and unmask interrupts must be privileged; otherwise, user code could inadvertently or maliciously disable the hardware timer, allowing the machine to freeze. </P>
<P></SPAN><SPAN class=extract>If multiple interrupts arrive while interrupts are disabled, the hardware delivers them in turn when interrupts are re-enabled. However, since the hardware has limited buffering for pending interrupts, some interrupts may be lost if interrupts are disabled for too long a period of time. Generally, the hardware will buffer one interrupt of each type; the interrupt handler is responsible for checking the device hardware to see if multiple pending I/O events need to be processed</SPAN>. </P>
<P></P>
<DIV class=sidebar align=center>
<HR>

<TABLE cellPadding=10>
<TBODY>
<TR>
<TD style="BACKGROUND-COLOR: #f0f0f0" align=left>
<P width=0><SPAN class=sidebar_name><B><I>Interrupt handlers: top and bottom halves</I></B></SPAN> </P>
<P><SPAN class=extract>When a machine invokes an interrupt handler because some hardware event occurred (e.g., a timer expired, a key was pressed, a network packet arrived, or a disk I/O completed), the processor hardware typically masks interrupts while the interrupt handler executes. While interrupts are disabled, another hardware event will not trigger another invocation of the interrupt handler until the interrupt is re-enabled</SPAN>. </P><SPAN class=extract><SPAN class=extract>
<P><SPAN class=extract>Some interrupts can trigger a large amount of processing, and it is undesirable to leave interrupts masked for too long. Hardware I/O devices have a limited amount of buffering, which can lead to dropped events if interrupts are not processed in a timely fashion. For example, keyboard hardware can drop keystrokes if the keyboard buffer is full. Interrupt handlers are therefore divided into a <EM>top half </EM>and a <EM>bottom half </EM>. Unfortunately, this terminology can differ a bit from system to system; in Linux, the sense of top and bottom are reversed. In this book, we adopt the more common (non-Linux) usage</SPAN>. </P>
<P>The interrupt handler&#8217;s bottom half is invoked by the hardware and executes with interrupts masked. It is designed to complete quickly. The bottom half typically saves the state of the hardware device, resets it so that it can receive a new event, and notifies the scheduler that the top half needs to run. At this point, the bottom half is done, and it can re-enable interrupts and return to the interrupted task or (if the event is high priority) switch to the top half but with interrupts enabled. When the top half runs, it can do more general kernel tasks, such as parsing the arriving packet, delivering it to the correct user-level process, sending an acknowledgment, and so forth. The top half can also do operations that require the kernel to wait for exclusive access to shared kernel data structures, the topic of Chapter&nbsp;5</P>
<P></SPAN></SPAN>. </P>
<P></P></TD></TR></TBODY></TABLE>
<HR>
</DIV>
<P><SPAN class=extract>If the processor takes an interrupt in kernel mode with interrupts enabled, it is safe to use the current stack pointer rather than resetting it to the base of the interrupt stack. This approach can recursively push a series of handlers&#8217; states onto the stack; then, as each one completes, its state is popped from the stack, and the earlier handler is resumed where it left off</SPAN>. <A id=x1-44001r70 name=x1-44001r70></A>