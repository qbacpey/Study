<SPAN class=extract>
<P>Asynchronous I/O allows progress by many concurrent operating system requests. This approach gives rise to an <EM><A data-9uzdtcnnj6xqoalwmdp3qa='{"name": "OEBPS/Text/part0000.xhtml", "frag": "glo:event-driven programming"}'>event-driven programming</A></EM> pattern where a thread spins in a loop; each iteration gets and processes the next I/O event. To process each event, the thread typically maintains for each task a <EM><A data-9uzdtcnnj6xqoalwmdp3qa='{"name": "OEBPS/Text/part0000.xhtml", "frag": "glo:continuation"}'>continuation</A></EM>, a data structure that keeps track of a task&#8217;s current state and next step.</P>
<P>&#20107;&#20214;&#39537;&#21160;&#22411;&#32534;&#31243;&#65288;event-driven programming&#65289;&#25351;&#30340;&#26159;&#32447;&#31243;&#20250;&#25191;&#34892;&#19968;&#20010;&#24490;&#29615;&#65292;&#22312;&#24490;&#29615;&#30340;&#27599;&#19968;&#27425;&#36845;&#20195;&#20013;&#38500;&#20197;&#19968;&#20010; IO &#20107;&#20214;&#12290;&#20026;&#27492;&#65292;&#32447;&#31243;&#38656;&#35201;&#20026;&#27599;&#19968;&#20010; IO &#20107;&#20214;&#21333;&#29420;&#22320;&#32500;&#25252;&#19968;&#20010;&#35745;&#31639;&#32493;&#20307;&#65288;continuation&#65289;&#65292;&#29992;&#20197;&#36861;&#36394;&#20107;&#20214;&#24403;&#21069;&#30340;&#29366;&#24577;&#20197;&#20415;&#30830;&#23450;&#19979;&#19968;&#27493;&#21160;&#20316;&#12290;</P>
<P>&#20043;&#25152;&#20197;&#38656;&#35201;&#20351;&#29992;&#35745;&#31639;&#32493;&#20307;&#36319;&#36394;&#20107;&#20214;&#29366;&#24577;&#65292;&#26159;&#22240;&#20026; IO &#20107;&#20214;&#24448;&#24448;&#38656;&#35201;&#20998;&#25104;&#19981;&#21516;&#38454;&#27573;&#26469;&#23436;&#25104;&#65292;&#38454;&#27573;&#30452;&#25509;&#30340;&#26102;&#38388;&#38388;&#38548;&#24448;&#24448;&#19981;&#21487;&#24573;&#35270;&#65292;&#27604;&#26041;&#35828; TCP &#30340;&#19977;&#27425;&#25569;&#25163;&#12290;</P></SPAN>
<P></P>
<P>For example, handling a web request can involve a series of I/O steps: (a) make a network connection, (b) read a request from the network connection, (c) read the requested data from disk, and (d) write the requested data to the network connection. If a single thread is handling requests from multiple different clients at once, it must keep track of where it is in that sequence for each client. </P>
<P>Further, the network may divide a client&#8217;s request into several packets so that the server needs to make several read calls to assemble the full packet. The server may be doing this request assembly for multiple clients at once. Therefore, it needs to keep several per-client variables (e.g., a request buffer, the number of bytes expected, and the number of bytes received so far). When a new message arrives, the thread uses the network connection&#8217;s port number to identify which client sent the request and retrieves the appropriate client&#8217;s variables using this port number/client ID. It can then process the data.</P>
<P>&#24635;&#32780;&#35328;&#20043;&#23601;&#26159;&#22914;&#26524;&#35201;&#35753;&#19968;&#20010;&#32447;&#31243;&#30417;&#21548;&#25152;&#26377;&#36830;&#25509;&#30340; IO &#25968;&#25454;&#30340;&#35805;&#65292;&#32447;&#31243;&#23601;&#38656;&#35201;&#20026;&#27599;&#20010; IO &#20107;&#20214;&#32500;&#25252;&#19968;&#20010; continuation&#65292;&#27605;&#31455;&#19968;&#20010; IO &#20107;&#20214;&#21487;&#33021;&#38656;&#35201;&#26377;&#24456;&#22810;&#27493;&#25165;&#33021;&#24443;&#24213;&#23436;&#25104;&#65288;&#27604;&#22914;&#35828; TCP &#32593;&#32476;&#36830;&#25509;&#65311;&#65289;&#25152;&#20197;&#36825;&#20010;&#32447;&#31243;&#19968;&#26041;&#38754;&#23601;&#38656;&#35201;&#36319;&#36394; IO &#25191;&#34892;&#30340;&#29366;&#24577;&#65292;&#21478;&#19968;&#26041;&#38754;&#38656;&#35201;&#26126;&#30830;&#21040;&#26469;&#30340;&#25968;&#25454;&#23646;&#20110;&#24403;&#21069;&#27491;&#22312;&#36827;&#34892;&#30340;&#21738;&#19968;&#20010; IO