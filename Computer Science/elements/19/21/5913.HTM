Although superficially different, overlapping I/O is fundamentally the same whether using asynchronous I/O and event-driven programming or synchronous I/O and threads. In either case, the program blocks until the next task can proceed, restores the state of that task, executes the next step of that task, and saves the task&#8217;s state until it can take its next step. The differences are: (1) whether the state is stored in a continuation or TCB and (2) whether the state save/restore is done explicitly by the application or automatically by the thread system. 
<P></P>
<P><SPAN class=extract>&#21333;&#32447;&#31243;&#36319;&#36394;&#22810;&#20219;&#21153;&#65292;&#36824;&#26159;&#22810;&#32447;&#31243;&#36319;&#36394;&#22810;&#20219;&#21153;</SPAN></P>
<P><SPAN class=extract>&#20351;&#29992;&#24322;&#27493; IO &#32467;&#21512;&#20107;&#20214;&#39537;&#21160;&#22411;&#32534;&#31243;&#19982;&#20351;&#29992;&#21516;&#27493; IO &#32467;&#21512;&#32447;&#31243;&#32534;&#31243;&#30340;&#20849;&#21516;&#28857;&#22312;&#20110;&#65306;&#35774;&#27861;&#29992;&#20854;&#20182;&#20107;&#20214;&#35206;&#30422; IO &#35774;&#22791;&#30340;&#25191;&#34892;&#26102;&#38388;</SPAN></P>
<P><SPAN class=extract>&#20351;&#29992;&#24322;&#27493; IO &#32467;&#21512;&#20107;&#20214;&#39537;&#21160;&#22411;&#32534;&#31243;&#19982;&#20351;&#29992;&#21516;&#27493; IO &#32467;&#21512;&#32447;&#31243;&#32534;&#31243;&#30340;&#19981;&#21516;&#28857;&#22312;&#20110;&#65306;&#65288;1&#65289;&#29366;&#24577;&#34987;&#20445;&#23384;&#21040; TCB &#20013;&#36824;&#26159; continuation &#20013;&#65288;2&#65289;&#25152;&#20445;&#23384;&#30340;&#29366;&#24577;&#26159;&#32447;&#31243;&#29366;&#24577;&#36824;&#26159; IO &#20107;&#20214;&#30340;&#29366;&#24577;&#65288;3&#65289;&#29366;&#24577;&#26159;&#34987;&#24212;&#29992;&#26174;&#24335;&#20445;&#23384;&#36824;&#26159;&#34987;&#32447;&#31243;&#31995;&#32479;&#33258;&#21160;&#20445;&#23384;</SPAN>