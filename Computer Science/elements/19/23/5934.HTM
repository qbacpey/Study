<B><SPAN class=headers>Title:</SPAN></B><SPAN class=RefText> 4.8.2 Implementing User-Level Threads Without Kernel Support : Preemptive User-level Threads</SPAN></FONT>.</B> </FONT>
<P>However, it is possible on most operating systems to implement preemption among user-level threads executing within a process. As we discussed in Chapter&nbsp;2, most operating systems provide an upcall mechanism to deliver asynchronous event notification to a process; on UNIX these are called signal handlers. Typical events or signals include the user hitting &#8220;Escape&#8221; or on UNIX &#8220;Control-C&#8221;; this informs the application to attempt to cleanly exit. Another common event is a timer interrupt to signal elapsed real time. </P>
<P>To deliver an event, the kernel suspends the process execution and then resumes it running at a handler specified by the user code, typically on a separate upcall or signal stack. </P><SPAN class=extract>
<P>&#20869;&#26680;&#20026;&#20102;&#20999;&#23454;&#22320;&#23558;&#20449;&#21495;&#20132;&#20184;&#32473;&#29992;&#25143;&#36827;&#31243;&#65292;&#20869;&#26680;&#20250;&#26242;&#20572;&#36827;&#31243;&#30340;&#25191;&#34892;&#24182;&#24674;&#22797;&#20026;&#29992;&#25143;&#20195;&#30721;&#25152;&#22768;&#26126;&#30340;&#20449;&#21495;&#22788;&#29702;&#31243;&#24207;&#65288;&#32780;&#19981;&#26159;&#29992;&#25143;&#36827;&#31243;&#65289;&#65292;&#19968;&#33324;&#26469;&#35828;&#21516;&#26102;&#20250;&#23558;&#26632;&#24674;&#22797;&#20026;&#19968;&#20010;&#29305;&#21035;&#30340;&#19978;&#34892;&#35843;&#29992;&#26632;&#25110;&#32773;&#35828;&#20013;&#26029;&#26632;</P>
<P></SPAN>
<P></P>To implement preemptive multi-threading for some process P : 
<P></P>
<OL class=enumerate1>
<LI class=enumerate><A id=x1-30002x1 name=x1-30002x1></A>
<P><SPAN class=extract>The user-level thread library makes a system call to register a timer signal handler and signal stack with the kernel. <BR>&#39318;&#20808;&#65292;&#22312;&#35843;&#29992;&#29992;&#25143;&#32423;&#32447;&#31243;&#24211;&#20013;&#19982;&#21019;&#24314;&#32447;&#31243;&#30456;&#20851;&#30340;&#20989;&#25968;&#20043;&#21518;&#65292;&#29992;&#25143;&#32447;&#31243;&#24211;&#20250;&#25191;&#34892;&#19968;&#20010;&#31995;&#32479;&#35843;&#29992;&#65292;&#20854;&#20316;&#29992;&#26159;&#22312;&#20869;&#26680;&#20013;&#27880;&#20876;&#19968;&#20010;&#35745;&#26102;&#20449;&#21495;&#22788;&#29702;&#31243;&#24207;&#20197;&#21450;&#20449;&#21495;&#26632;&#65288;&#27880;&#20876;&#20449;&#21495;&#26632;&#20272;&#35745;&#23601;&#26159;&#23558;&#20449;&#21495;&#26632;&#30340;&#20301;&#32622;&#21457;&#32473;&#20182;&#65289;</SPAN></P>
<LI class=enumerate><A id=x1-30004x2 name=x1-30004x2></A>
<P><SPAN class=extract>When a hardware timer interrupt occurs, the hardware saves P &#8217;s register state and runs the kernel&#8217;s handler. <BR>&#21457;&#29983;&#30828;&#20214;&#35745;&#26102;&#20013;&#26029;&#26102;&#65288;&#24182;&#38750;&#30001;&#32447;&#31243;&#24211;&#30340;&#34892;&#20026;&#23548;&#33268;&#65292;&#26159;&#30828;&#20214;&#30340;&#33258;&#21160;&#34892;&#20026;&#65289;&#30828;&#20214;&#20250;&#25191;&#34892;&#21644;&#26222;&#36890;&#20013;&#26029;&#19968;&#26679;&#30340;&#34892;&#20026;&#65292;&#20445;&#23384;&#29366;&#24577;&#12289;&#35843;&#29992;&#20013;&#26029;&#22788;&#29702;&#31243;&#24207;&#31561;</SPAN></P>
<LI class=enumerate><A id=x1-30006x3 name=x1-30006x3></A><SPAN class=extract>
<P>Instead of restoring P &#8217;s register state and resuming P where it was interrupted, the kernel&#8217;s handler copies P &#8217;s saved registers onto P &#8217;s signal stack. <BR>&#20013;&#26029;&#22788;&#29702;&#31243;&#24207;&#20250;&#23558;&#20013;&#26029;&#26632;&#37324;&#36793;&#30340;&#32447;&#31243;&#29366;&#24577;&#25335;&#36125;&#21040;&#20449;&#21495;&#26632;&#65292;&#30830;&#20445;&#20449;&#21495;&#22788;&#29702;&#31243;&#24207;&#33021;&#24674;&#22797;&#21040;&#32447;&#31243;&#30340;&#19978;&#19979;&#25991;</P>
<P></SPAN><A id=x1-30008x4 name=x1-30008x4></A><SPAN class=extract>&nbsp;</P>
<P>The kernel resumes execution in P at the registered signal handler on the signal stack. <BR>&#20013;&#26029;&#22788;&#29702;&#31243;&#24207;&#38543;&#21518;&#20250;&#20462;&#25913;&#20013;&#26029;&#26632;&#20013;&#30340;&#25968;&#25454;&#65292;&#30830;&#20445;&#36820;&#22238;&#26102;&#33021;&#24674;&#22797;&#20449;&#21495;&#22788;&#29702;&#31243;&#24207;&#30340;&#19978;&#19979;&#25991;&#65288;&#21033;&#29992;&#20043;&#21069;&#31995;&#32479;&#35843;&#29992;&#27880;&#20876;&#30340;&#32467;&#26524;&#65289;&#24182;&#36820;&#22238;&#21040;&#20449;&#21495;&#22788;&#29702;&#31243;&#24207;&#20013;</P>
<P></SPAN><A id=x1-30010x5 name=x1-30010x5></A><SPAN class=extract>&nbsp;</P>
<P>The signal handler copies the processor state of the preempted user-level thread from the signal stack to that thread&#8217;s TCB. <BR>&#20449;&#21495;&#22788;&#29702;&#31243;&#24207;&#20250;&#23558;&#32447;&#31243;&#29366;&#24577;&#20445;&#23384;&#21040;&#23545;&#24212;&#32447;&#31243;&#30340; TCB &#20013;</P></SPAN>
<LI class=enumerate><A id=x1-30012x6 name=x1-30012x6></A><SPAN class=extract>
<P>The signal handler chooses the next thread to run, re-enables the signal handler (the equivalent of re-enabling interrupts), and restores the new thread&#8217;s state from its TCB into the processor. execution with the state (newly) stored on the signal stack.<BR>&#20449;&#21495;&#22788;&#29702;&#31243;&#24207;&#38543;&#21518;&#20250;&#36873;&#25321;&#25509;&#19979;&#26469;&#35201;&#36816;&#34892;&#30340;&#32447;&#31243;&#12289;&#21551;&#29992;&#20449;&#21495;&#12289;&#24182;&#23558;&#26032;&#32447;&#31243;&#30340;&#29366;&#24577;&#24674;&#22797;&#21040;&#22788;&#29702;&#22120;&#24403;&#20013;&#65292;&#24182;&#25191;&#34892;&#26032;&#32447;&#31243;&#65288;&#19968;&#33324;&#26469;&#35828;&#19981;&#26159;&#23558;&#26032;&#32447;&#31243;&#29366;&#24577;&#20445;&#23384;&#21040;&#20449;&#21495;&#26632;&#20013;&#65292;&#28982;&#21518;&#20449;&#21495;&#22788;&#29702;&#31243;&#24207;&#36864;&#20986;&#26102;&#33258;&#28982;&#32780;&#28982;&#30340;&#24674;&#22797;&#21527;&#65311;&#36824;&#26159;&#35828;&#36825;&#37324;&#30340;&#34892;&#20026;&#23454;&#38469;&#19978;&#26159;&#25928;&#27861;&#20043;&#21069;&#30340; thread_switch &#21602;&#65311;&#30452;&#25509;&#24555;&#36895;&#20999;&#25442;&#21040;&#26032;&#32447;&#31243;&#30340;&#25191;&#34892;&#65292;&#27605;&#31455;&#20449;&#21495;&#22788;&#29702;&#31243;&#24207;&#20063;&#20301;&#20110;&#29992;&#25143;&#27169;&#24335;&#65289;</P>
<P></SPAN><SPAN class=extract>&nbsp;</P>
<OL class=enumerate1>
<LI class=enumerate>
<P>This approach virtualizes interrupts and processor exceptions, providing a user-level process with a very similar picture to the one the kernel gets when these events occur.</P></LI></OL>
<P>&#36825;&#37324;&#35828;&#30340;&#34394;&#25311;&#21270;&#24212;&#35813;&#25351;&#30340;&#26159;&#32473;&#29992;&#25143;&#32447;&#31243;&#25552;&#20379;&#34394;&#25311;&#21270;&#20043;&#21518;&#30340;&#35745;&#26102;&#22120;&#20013;&#26029;&#65288;&#27605;&#31455;&#22312;&#36825;&#31181;&#22330;&#26223;&#19979;&#35745;&#26102;&#22120;&#20013;&#26029;&#30340;&#30495;&#27491;&#24433;&#21709;&#23545;&#35937;&#26159;&#36827;&#31243;&#32780;&#19981;&#26159;&#32447;&#31243;&#65292;&#22240;&#27492;&#38656;&#35201;&#27169;&#25311;&#35745;&#26102;&#22120;&#20013;&#26029;&#23545;&#20869;&#26680;&#32447;&#31243;&#30340;&#20013;&#26029;&#65289;&#65292;&#20934;&#30830;&#26469;&#35828;&#23601;&#26159;&#35753;&#20449;&#21495;&#22788;&#29702;&#31243;&#24207;&#27169;&#25311;&#8220;&#22914;&#26524;&#29992;&#25143;&#32447;&#31243;&#26159;&#19968;&#20010;&#20869;&#26680;&#32447;&#31243;&#30340;&#35805;&#21457;&#29983;&#20013;&#26029;&#24182;&#20986;&#29616;&#32447;&#31243;&#20999;&#25442;&#26102;&#20250;&#20986;&#29616;&#20160;&#20040;&#34892;&#20026;&#8221;</SPAN>